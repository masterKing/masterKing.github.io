<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2019/04/04/2019-04-04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>#关于设计模式</p>
<table>
<thead>
<tr>
<th>*</th>
<th>*</th>
<th align="left">创建型</th>
<th align="left">结构型</th>
<th align="left">行为型</th>
</tr>
</thead>
<tbody><tr>
<td>范围</td>
<td>类</td>
<td align="left">Factory Method</td>
<td align="left">Adapter(类)</td>
<td align="left">Interpreter<br/>Template Method</td>
</tr>
<tr>
<td>*</td>
<td>对象</td>
<td align="left">Abstract Factory<br/>Builder<br/>Prototype<br/>Singleton</td>
<td align="left">Adapter(对象)<br/>Bridge<br/>Composite<br/>Decorator<br/>Facade<br/>Flyweight<br/>Proxy<br/></td>
<td align="left">Chain of Responsibility<br/>Command<br/>Iterator<br/>Mediator<br/>Memento<br/>Observer<br/>State<br/>Stragegy<br/>Visitor</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个报错</title>
    <url>/2019/04/25/2019-04-25-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="Undefined-symbols-for-architecture-arm64"><a href="#Undefined-symbols-for-architecture-arm64" class="headerlink" title="Undefined symbols for architecture arm64"></a>Undefined symbols for architecture arm64</h1><img src="/2019/04/25/2019-04-25-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99/Snip20190425_23.png" class="">

<p>上面这个报错经常会遇到…但是一直不知道是为啥出现的…今天碰巧知道了出现的原因</p>
<p>错误出现的步骤是这样的</p>
<ul>
<li><ol>
<li>首先我新建了 Director 和 ConcreteBuild 两个类</li>
</ol>
</li>
<li><ol start="2">
<li>在 viewController.m 中我使用这两个类写了一些代码</li>
</ol>
</li>
<li><ol start="3">
<li>这个时候我觉得这两个类写的不好不想要了,于是全部删除了…</li>
</ol>
</li>
</ul>
<p>但此时在 viewController.m 中的代码还没有移除掉;再次编译运行的时候就会报</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> architecture arm64:</span><br><span class="line"><span class="string">&quot;\_OBJC\_CLASS\_$\_Director&quot;</span>, referenced from:</span><br><span class="line">objc-class-ref <span class="keyword">in</span> ViewController.o</span><br></pre></td></tr></table></figure>

<p>知道了错误产生的原因之后,再解决问题就很容易了…去 viewController.m 文件中把相关的代码全删了就好了…</p>
<p>只是有点儿疑惑为什么 xcode 不报找不到头文件 Director 或 ConcreteBuild 错误,而报这个 Undefined symbols for architecture arm64: 错误…一脸懵</p>
]]></content>
  </entry>
  <entry>
    <title>MBProgressHUD源码解析</title>
    <url>/2020/06/24/2020-06-24-MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="MBProgressHUD"><a href="#MBProgressHUD" class="headerlink" title="MBProgressHUD"></a>MBProgressHUD</h1><p>从入行以来,就经常听说,学习编程进步最快的方式,就是阅读优秀作品的源码…</p>
<p>那么,今天我来阅读一下MBProgressHUD这个库的源码…</p>
<p>查看一下文件,非常简单的俩个MBProgressHUD.h和MBProgressHUD.m文件</p>
<p>没什么说的,从MBProgressHUD.h文件开始看吧;</p>
<p>头文件首先声明了一个自定义的类 <code>MBBackgroundView</code> 和 一个协议 <code>MBProgressHUDDelegate</code>,自定义类放在这里声明一下,应该是因为<code>MBProgressHUD</code>里面使用到了<code>MBBackgroundView</code>类,且<code>MBProgressHUD</code>的声明与实现都放在了<code>MBBackgroundView</code>的前面,将<code>MBBackgroundView</code>的位置挪到比<code>MBProgressHUD</code>靠前的地方就不需要提前声明了,这个很简单,不需要多说了吧;而代理协议<code>MBProgressHUDDelegate</code>,对于做过iOS的开发人来说,应该说是再熟悉不过了…</p>
<p>接下来声明了一个供外部使用的变量<code>extern CGFloat const MBProgressMaxOffset;</code>,使用<code>extern</code>修饰了的变量能够在其他文件也可以访问到;往下查看头文件的时候,发现是为了给属性<code>offset</code>使用的,注释里面写到可以使用CGPointMake(0.f, MBProgressMaxOffset)来使HUD的位置处于底部边缘的中心位置</p>
<p>然后是4个自定义类型,<code>MBProgressHUDMode``MBProgressHUDAnimation``MBProgressHUDBackgroundStyle``MBProgressHUDCompletionBlock</code>;这四个类型也都比较简单,见名字大概就知道是什么意思了,简单提一下;<br><code>MBProgressHUDMode</code>mode翻译过来叫(设备的)模式,方式,风格,样式…在这里取风格或者样式应该更加恰当;它有6种不同的样式:</p>
<ul>
<li><code>MBProgressHUDModeIndeterminate </code>	&#x2F;&#x2F;iOS系统原生的UIActivityIndicatorView</li>
<li><code>MBProgressHUDModeDeterminate </code>	&#x2F;&#x2F;一个圆形的饼状进度视图样式</li>
<li><code>MBProgressHUDModeDeterminateHorizontalBar </code>	&#x2F;&#x2F;一个水平的条状进度视图样式</li>
<li><code>MBProgressHUDModeAnnularDeterminate </code>	&#x2F;&#x2F;圆环形的进度视图样式</li>
<li><code>MBProgressHUDModeCustomView </code>	&#x2F;&#x2F;自定义视图样式</li>
<li><code>MBProgressHUDModeText </code> &#x2F;&#x2F;纯文字样式</li>
</ul>
<p><code>MBProgressHUDAnimation</code>动画类型</p>
<ul>
<li><code>MBProgressHUDAnimationFade</code> &#x2F;&#x2F;淡入淡出</li>
<li><code>MBProgressHUDAnimationZoom</code> &#x2F;&#x2F;出现时放大,消失时缩小</li>
<li><code>MBProgressHUDAnimationZoomOut</code> &#x2F;&#x2F;缩小</li>
<li><code>MBProgressHUDAnimationZoomIn</code> &#x2F;&#x2F;放大</li>
</ul>
<p><code>MBProgressHUDBackgroundStyle</code>背景风格</p>
<ul>
<li><code>MBProgressHUDBackgroundStyleSolidColor</code> &#x2F;&#x2F;纯色</li>
<li><code>MBProgressHUDBackgroundStyleBlur</code> &#x2F;&#x2F;模糊,毛玻璃效果</li>
</ul>
<p><code>MBProgressHUDCompletionBlock</code>是一个无返回值无参数的block</p>
<p>接来下是<code>MBProgressHUD</code>的正式声明了<br>首先是7个方法声明</p>
<p>前三个为类方法:</p>
<p><code>+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (nullable MBProgressHUD *)HUDForView:(UIView *)view;</code></p>
<p>后面为对象方法:</p>
<p><code>- (instancetype)initWithView:(UIView *)view;</code></p>
<p><code>- (void)showAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay;</code></p>
<p>每个方法的注释都很详细,不需要多介绍什么的,接下来看看属性</p>
<p><code>@property (weak, nonatomic) id&lt;MBProgressHUDDelegate&gt; delegate;</code><br><code>@property (copy, nullable) MBProgressHUDCompletionBlock completionBlock;</code><br>这两个属性都是用来回传HUD消失事件的,代理协议里面也只有一个HUD已经隐藏的方法</p>
<p><code>@property (assign, nonatomic) NSTimeInterval graceTime;</code>这个属性很有意思,一开始我理解成下面那个属性<code>minShowTime</code>了,往下看到<code>minShowTime</code>之后,我才发现理解错了;这个属性的意思是:如果有graceTime,那么HUD在graceTime之后才显示.作用就是不让时间非常短的任务显示HUD(嗯,用处好像不是很大,我看了下我们项目,没有一个地方使用…)举个例子:我们一般会在网络请求发起之前显示HUD,在网络请求返回时隐藏HUD,在不考虑下面<code>minShowTime</code>属性的情况下,如果这个时间间隔非常短,就会出现显示了HUD瞬间就消失了的尴尬情况,那么这个时候,设置一个graceTime,对于那些时间非常短的异步任务就根本不会显示也没有必要显示HUD了</p>
<p><code>@property (assign, nonatomic) NSTimeInterval minShowTime;</code>这个属性的作用就容易理解多了,最小显示时间;同样也是为了解决时间间隔很短的异步任务问题,你还察觉不到就结束了,那么这个HUD压根就看不见…所以加上这么一个时间</p>
<p><code>@property (assign, nonatomic) BOOL removeFromSuperViewOnHide;</code>这个也是非常好理解,隐藏的时候是否从父视图移除</p>
<h6 id="下面的属性时跟外观-Appearance-相关的"><a href="#下面的属性时跟外观-Appearance-相关的" class="headerlink" title="下面的属性时跟外观(Appearance)相关的"></a>下面的属性时跟外观(Appearance)相关的</h6><p><code>@property (assign, nonatomic) MBProgressHUDMode mode;</code> 样式<br><code>@property (strong, nonatomic, nullable) UIColor *contentColor</code> 内容颜色<br><code>@property (assign, nonatomic) MBProgressHUDAnimation animationType</code> 显示或隐藏时的动画类型<br><code>@property (assign, nonatomic) CGPoint offset</code> 相对于视图中心的边框偏移量<br><code>@property (assign, nonatomic) CGFloat margin</code> HUD边缘和HUD元素之间的间距<br><code>@property (assign, nonatomic) CGSize minSize</code> HUD边框的最小尺寸<br><code>@property (assign, nonatomic, getter = isSquare) BOOL square</code> 如果可能的话，强制HUD尺寸相等。<br><code>@property (assign, nonatomic, getter=areDefaultMotionEffectsEnabled) BOOL defaultMotionEffectsEnabled</code> 当启用时，bezel center会受到设备加速计数据的轻微影响</p>
<h6 id="进度相关属性-Progress"><a href="#进度相关属性-Progress" class="headerlink" title="进度相关属性(Progress)"></a>进度相关属性(Progress)</h6><p><code>@property (assign, nonatomic) float progress;</code> 进度指示器的进度,取值0.0~1.0,默认为0.0</p>
<h6 id="进度对象相关属性-ProgressObject"><a href="#进度对象相关属性-ProgressObject" class="headerlink" title="进度对象相关属性(ProgressObject)"></a>进度对象相关属性(ProgressObject)</h6><p><code>@property (strong, nonatomic, nullable) NSProgress *progressObject;</code> 不是太明白干什么的</p>
<h6 id="视图相关属性-Views"><a href="#视图相关属性-Views" class="headerlink" title="视图相关属性(Views)"></a>视图相关属性(Views)</h6><p><code>@property (strong, nonatomic, readonly) MBBackgroundView *bezelView;</code> 包含文本标签和指示器(或者自定义视图)的边框视图<br><code>@property (strong, nonatomic, readonly) MBBackgroundView *backgroundView;</code> 覆盖整个HUD区域，放置在bezelView后面的视图<br><code>@property (strong, nonatomic, nullable) UIView *customView;</code> 当HUD样式为MBProgressHUDModeCustomView的时候,显示的视图;视图应该实现intrinsicContentSize方法已显示正确的大小,为了得到最好的效果,建议使用37x37像素<br><code>@property (strong, nonatomic, readonly) UILabel *label;</code> 显示在活动指示器下方的文本标签,HUD会自动调整大小以适应整个文本<br><code>@property (strong, nonatomic, readonly) UILabel *detailsLabel;</code> 一个标签，其中包含一个可选的详细信息消息，显示在labelText消息下面。细节文本可以跨越多行。<br><code>@property (strong, nonatomic, readonly) UIButton *button;</code> 放在标签下面的按钮。只有在添加target和action后才可见。</p>
<p>好了,MBProgressHUD的方法属性就这些了…<br>接下来看看MBProgressHUD头文件里,其他的类的声明;</p>
<p>首先是<code>MBRoundProgressView</code>这个应该是饼图样式时使用到的视图,只有4个属性<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *progressTintColor;</code> 指示器进度的颜色<br><code>@property (nonatomic, strong) UIColor *backgroundTintColor;</code> 指示器背景色<br><code>@property (nonatomic, assign, getter = isAnnular) BOOL annular;</code> 是否环形,不是很清楚什么效果…</p>
<p>然后是<code>MBBarProgressView</code>,这个应该是一个扁平的进度条视图<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *lineColor;</code> 条状边框线颜色<br><code>@property (nonatomic, strong) UIColor *progressRemainingColor;</code> 条状背景色<br><code>@property (nonatomic, strong) UIColor *progressColor;</code> 条状进度颜色</p>
<p>最后是<code>MBBackgroundView</code>,这个是背景视图<br><code>@property (nonatomic) MBProgressHUDBackgroundStyle style;</code> 背景样式,毛玻璃或者纯色,iOS7和它之后都是毛玻璃效果,之前是纯色<br><code>@property (nonatomic) UIBlurEffectStyle blurEffectStyle;</code> 模糊效果样式<br><code>@property (nonatomic, strong) UIColor *color;</code> 背景色</p>
<p>以上就是MBProgressHUD.h文件的全部内容了,其实还有一部分,是遗弃的旧版本的代码就不看了</p>
<p>下面,我来看看.m文件源码,这才是重点啊</p>
]]></content>
  </entry>
  <entry>
    <title>OC与iOS混编</title>
    <url>/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<h1 id="记录一下-OC-和-Swift-混编的问题"><a href="#记录一下-OC-和-Swift-混编的问题" class="headerlink" title="记录一下,OC 和 Swift 混编的问题"></a>记录一下,OC 和 Swift 混编的问题</h1><p>在OC项目中,需要使用 Swift 的时候,一般情况下,在你的 OC 项目中新建一个 Swift 文件的时候,系统会自动提示你是否需要配置一个 Objective-C 桥接头文件,如下图:</p>
<img src="/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/Snip20190412_4.png" class="">

<p>点击最右侧的创建桥接头文件,系统就会帮你配置创建并配置好一个桥接头文件…这个桥接头文件的作用是,让你可以在 Swift 代码中使用 OC 中的类;只需要将你需要在 Swift 代码中使用的类的头文件在桥接头文件中导入一下就可以使用了;如果一不小心点击了 Don’t Create 按钮,那就需要你自己再手动创建一个头文件,将它配置成桥接头文件,才可以使用.配置步骤如下:</p>
<ol>
<li>创建一个头文件 <img src="/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/Snip20190412_5.png" class="">
 <img src="/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/Snip20190412_6.png" class=""></li>
<li>配置成为OC桥接头文件  <img src="/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/Snip20190412_7.png" class=""></li>
</ol>
<p>在里面导入 OC 的头文件,就可以在 Swift 代码中使用了</p>
<p>如果是想要在 OC 的代码中使用 Swift 的类的话,这个就更加简单了,只需要导入一个系统自动生成的头文件就可以访问了,这个头文件在项目目录中看不到;但是在上图标记 ③ 的框框下面你可以看到它的名字,直接导入这个头文件就可以使用了,需要注意的是系统并不会自动补全这个头文件…没有提示,需要你自己一个一个字母敲进去</p>
<hr/>

<p>再来说一下,在 Swift 项目中,想要使用 OC 代码;跟上面的步骤是一样的,第一次在 Swift 项目中创建 OC 类的时候,系统就会提示你是否创建 Objective-C 桥接头文件;这个头文件的作用跟上是一样的,让你可以在 Swift 代码中使用 OC 的类,只需在这个头文件导入 OC 类就行了…在 OC 代码中想要使用 Swift 类也跟上面一样,导入系统自动生成的那个头文件就可以使用了</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之一：快速入门Flutter</title>
    <url>/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/</url>
    <content><![CDATA[<p>flutter 现在是越来越火了，现在作为一个 iOS 开发，如果你不会 flutter 都好像不算个正常人似的？而且现在的 flutter 情况，有点像 2012 年那会儿刚刚兴起的 iOS，Android 开发一样，会点皮毛 UI 就可以提升不少身价…这些年过来，有无数的前端跨平台框架兴起。却只有 flutter 一家独秀，说明它还是有两把刷子的。今天这篇文章内容是基于 Mac 和 Android Studio 基础来开发 flutter 的，如果你还没有配置好开发环境，可以在网上搜索，或者直接到官网安装。这篇文章主要用来记录我学习 flutter 的过程，如果你也对 flutter 感兴趣可以跟着一起练习。</p>
<p>配置好 Flutter 环境之后，开始创建我们的第一个 Flutter 工程</p>
<h1 id="创建第一个-Flutter-工程"><a href="#创建第一个-Flutter-工程" class="headerlink" title="创建第一个 Flutter 工程"></a>创建第一个 Flutter 工程</h1><p>打开 iTerm2，cd 到 ~&#x2F;AndroidStudioProjects 目录，输入以下命令，没有 iTerms 的使用 Mac 系统自带的 Terminal 也行。<br></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flutter create flutter_demo</span><br></pre></td></tr></table></figure>

<p>这里需要注意，AndroidStudio 项目名称不能使用大写字母，这里推荐使用小写字母加下划线给工程命名。</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/c12dd5b7513e4a3a87c4249d6bff3e5a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>打开对应的目录，可以看到新建了一个 <code>flutter_demo</code> 目录</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/f65f809f540045a594d2e8c4207eb44d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png"><br>

<p>接下来，cd 到 <code>flutter_demo</code> 目录，在终端输入 <code>flutter run</code> 命令，它就会运行项目，如果你电脑连接了真机，就会自动运行到真机上，没有真机会去寻找模拟器并运行，模拟器也没有，就会打开一个 Chrome 网页运行项目 (flutter 项目目前可以运行在 iOS，Android，web 上)。我这里连上了 iPhone 真机，运行项目会报一个 BUILD FAILED 的错误:</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/01063bff94594693889713336801ab99~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>原因是 flutter_demo 项目生成的 iOS 项目默认的 bundle identifier 咱们用不了，去 iOS 项目里面修改一下就好了</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/7869a380e58e4bb4bee43d7632f9ad63~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里注意我们免费的开发者证书，在 iPhone 上最多安装 3 个开发中的 APP，多了就安装不了，删掉之前的 APP 就好了，再次运行 <code>flutter run</code> </p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/12983baee1574506aabf12d1383af6ed~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>可以看到这里给出了 flutter 运行的一些关键命令，Hot reload 热重载，这个特性对我们开发 UI 时还是比原生的体验好不少的，它不用我们重新运行项目就能看到 UI 的一些改变。Hot restart 热重启，意思不用退出 APP，就直接重新运行了。此时真机上就打开了我们的第一个 flutter 工程的 APP</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/0b9a168158354713a31d3103001fd8f8~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<h1 id="HelloFlutter"><a href="#HelloFlutter" class="headerlink" title="HelloFlutter"></a>HelloFlutter</h1><p>上面是通过命令创建一个 flutter 项目，当然在实际开发过程我，我们一般不会这么操作。使用 Android Studio 来创建 flutter 项目。没有这个选项的同学，在 Android Studio 的插件里面选择 flutter 并安装就有了，如果提示还需要安装 Dart 就一块安装了，flutter 使用的是 Dart 语言。iOS 开发者没必要被这个新语言给吓到了，现代的语言基本都差不了太多，敲着敲着就熟悉了</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/65f2784c45fc45728781cfd1d77a618c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>点击后会出现以下界面，目前我们选择 Flutter App 就好了</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/c2ad2dcb3a05426fae1347fab30f7054~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>下一个界面会让我们设置工程名称，工程位置，工程描述，工程组织，Android 语言，iOS 语言等等…我这里设置工程名称为 hello_flutter，其他的默认选择就好了…也可以根据你自己的需要选择</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/6b9e58c9ee274fe695c3094500da4961~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>点击 Finish 之后就可以看到完整的工程目录了，flutter 工程的主入口，跟我们 iOS 项目一样有一个 main.m 文件，flutter 的是 main.dart 文件，可以看到这个文件里面已经有不少初始的代码了，今天是我们第一次接触 flutter 项目，就不要这里的代码，全部删掉，我们从第一行代码开始自己敲出来</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/8caf387fbb084bf681dac3caa7863f7f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/fad716135bad4cc986a89968f01bc083~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<ul>
<li>导入 material.dart 头文件(相当于 iOS 中 UIKit)</li>
<li>写一个 main() 函数作为主入口</li>
<li>调用 runAPP() 函数</li>
<li>Center 类是用来布局的类，表示一个位置，child 属性表示他有的子控件的意思。Text 类就是我们文本类，有点儿我们 iOS 的 UILabel 的意思，Text 类的第一个参数就是具体的文本，省略了参数名，第二个参数 <code>textDirection</code> 表示文本显示方向，我们习惯的从左至右就是 <code>TextDirection.ltr</code>，left to right。像一些阿拉伯语言，希伯来语的文字就是从右到左显示的，我这里试了一下 hello world 的方向并没有变化，可能还需要其他设置吧…<br></li>
</ul>
<p>运行之后 iPhone 显示如下：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/1fcd588320c3486f9b78bf16e0ef090e~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<h1 id="自定义-Widget"><a href="#自定义-Widget" class="headerlink" title="自定义 Widget"></a>自定义 Widget</h1><p>flutter 里面的 Widget 类叫作小部件，是 flutter 里面经常用到的，它分为有状态的 Stateful 和 Stateless 无状态的。其中无状态的比较简单，我们先自定义一个类 CustomWidget 继承自 StatelessWidget。我们自定义的 Widget 想要显示到屏幕上需要实现一个 build 的函数，系统会调用这个函数来渲染我们想要显示到屏幕上的内容</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/2644086b52ce4c129b4166634f3aea71~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这个时候，如何将我们的 hello flutter 显示到屏幕呢，可以看到 runApp 函数里面有一个 Center 类，我们 CustomWidget 类的 build 方法也是返回的一个 Center 类，所以可以直接将我们 CustomWidget 初始化给 runApp 作参数</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/1b0fe8e697f143da87ae575c721bfce7~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>有些时候，我们发现 hot reload 无法更新界面，可以使用 hot restart，如果 hot restart 还是无法更新界面，那就需要重新运行一下就可以了。此时我们发现 main() 函数里面就只有一句调用 runApp() 代码，在 Dart 语言中，函数定义如果只有一句代码，那么可以省略成如下箭头形式</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/6622e630312b4d46a4570b12b32f55e4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="设置文字样式-style"><a href="#设置文字样式-style" class="headerlink" title="设置文字样式 style"></a>设置文字样式 style</h1><p>按住 command 再用鼠标左键点击 Text 类，就会跳到一个 text.dart 文件，会看到一个 this.style 属性，再次按住 command 点击，会来到 style 的声明部分：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/c20f3fc043974b2b956dbd6b28eebd80~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里的 final 表示不可变，常量的意思，类似于 Swift 里面的 let。可以看到 style 是一个 TextStyle 类型，查看 TextStyle 类，会发现里面很多的属性，比如 color，backgroundColor，fontSize，fontWeight…这些都是很熟悉的属性,接下来我们设置一下 hello flutter 的一些文字样式</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/4d1565a3e89643599da97f6eb93f3f19~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>使用 Android Studio 快捷键 command + \ 查看界面</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/681e54bc6ba244e383e6c42c94dfdb10~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<h1 id="Material-App"><a href="#Material-App" class="headerlink" title="Material App"></a>Material App</h1><p>在 flutter 提供的头文件 material.dart 中，提供了一个快速构建 APP 的类型 MaterialApp，我们可以使用它来快速构建一个 APP 的基础框架。<br></p>
<p>我们先新建一个App类来写我们的代码</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/921de45df974425b96a8552edd7167ec~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png"><br>

<p>然后我们在 App 的 build 方法中，返回一个 MaterialApp 类，如果 MaterialApp 不传入任何参数的话，运行后会发现APP整个屏幕变成红色，并且显示了一行文字，意思是出错了之类的，说明我们的 MaterialApp 应该是需要传入一个必要的参数的。</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/abd8214222cc4924b43e1749ddceceae~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>没错就像我们 iOS 的 APP 同样需要一个 rootViewController 一样，MaterialApp 函数需要一个 home 参数，home 参数可以传一个 Widget 类，如果传入我们刚刚写的 CustomWidget 类，运行后发现有了一点不一样的地方</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/cbd25bca31084862b6aa3ce68862a221~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<p>右上角有一个 debug 的图标，hello flutter 下面也出现了两条横线。</p>
<p>flutter 还提供了一个 Scaffold 的类，这个类翻译过来叫作脚手架，有点像是我们 iOS 中的一些基础控制器(比如 UITabBarController，UINavigationController)的封装。我们来使用一下这个类，这个 Scaffold 类有一个 appBar 的属性，这个属性就跟我们的 UINavigationController 的 UINavigationBar 一样，appBar 是一个 AppBar 类型，它的 title 属性可以传入一个 Widget，我们传入一个 Text 类试试看。Scaffold 类除了 appBar 属性，还有一个 body 属性表示的内容，把这个 body 设置为我们刚刚的 CustomWidget，看看是什么效果，代码如下：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/2ba07c4727cd42bcbeb8768167858493~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>APP上显示效果：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/b0436c60496843b0bb0d3a20d7f0b96d~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<p>这个时候，是不是发现像那么回事了</p>
<p>MaterialApp 还有一个 theme 的属性，这个属性用了配置 app 的主题，设置一下主题颜色代码如下：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/5f097b85ecd74b42ac0374d7276c94bb~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>APP上显示效果：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/a72cec5174ba4c989c6fea7452e13aa6~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<h1 id="初探-ListView"><a href="#初探-ListView" class="headerlink" title="初探 ListView"></a>初探 ListView</h1><p>在探索 ListView 之前，我们先把模型实现一下，我们这里展示的一组关于汽车的图片和名字，就定义一个 Car 类，我们新建一个 car 文件用来存放我们的模型代码，代码如下：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/6f71fd16e1b14a1fb632819077a9d0d6~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>再定义一个数组，用来存放一组汽车模型，我这里放了一组网络图片，你可以直接使用，也可以自己在网上找几张图片，填入模型数组中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;Car&gt; cars = [</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;保时捷918 Spyder&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-7d8be6ebc4c7c95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;兰博基尼Aventador&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-e3bfd824f30afaac?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;法拉利Enzo&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-a1d64cf5da2d9d99?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;Zenvo ST1&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-bf883b46690f93ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;迈凯伦F1&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-5a7b5550a19b8342?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;萨林S7&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-2e128d18144ad5b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;科尼赛克CCR&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-01ced8f6f95219ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;布加迪Chiron&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-7fc8359eb61adac0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;轩尼诗Venom GT&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-d332bf510d61bbc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;西贝尔Tuatara&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-3dd9a70b25ae6bc9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  )</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>然后回到 main.dart 文件新建一个 Home 类，用来存放我们 ListView 相关代码,和 Xcode 一样 Android Studio 同样有代码块功能，直接输入 stl 就会出现提示，回车就会生成 StatelessWidget 类相关代码。我们将 Scaffold 相关的代码挪到 Home 中来。</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/76d90981bd244df4b58afd63c041a279~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>接下来就是正式开始使用 ListView 了，ListView 跟其他一般的类不太一样，它的初始化需要调用 build 方法，并且传入两个参数，一个是 itemCount，一个是 itemBuilder，有点类似我们 UITableView 的 cellForRow 方法，只不过我们 UITableView 使用的是代理的设计，而这里的 ListView 使用的代码块回调的设计。</p>
<p>这里说一个 Android Studio 的比 Xcode 好用的地方，如图的 itemCount 使用了 cars.length 但是提示 cars 报错，是因为没有导入 car.dart 文件，给了个小红灯泡。这个时候，我们光标移动到 Car 类上，然后使用 option + 回车 会弹出一个菜单，再按一次回车就可以导入我们的 car.dart 文件了</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/e624caad2d2d40a9a9699f96f04b43b0~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>itemBuilder 属性就是一个代码块，用来配置每个 item 的样式，我们可以先统一返回一个 Text 文本看看效果。</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/b8a2cb6254db46db93612495dcfbde64~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>显示效果就是类似于 tableView 一样的一行行的文本</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/775d0ccc95184864bf9e70703aa7f3c4~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<p>接下来介绍一个类似于 UIView 的容器类 Container，它跟 UIView 类似，可以设置一些颜色，间距，子控件之类的，我们来试一下，将 Text 改为 Container，child 属性就是子控件的意思，再给 child 设置为 Text，文本就是 cars 里面的 name，代码如下：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/98718e624fc1481fad5769b121af4fb5~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>再看一下显示效果</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/ce681f02eddb45d79b66ccdfa7e9c97c~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<p>那么如果我们现在想要显示图片加文字的话应该怎么做呢？这里再介绍一个 Column 类,和前面介绍 Center 类类似，同样是属于布局的类，Column 表示上下的布局，因为我们想把图片和文字上下摆放，所以需要用到 Column 这个类。然后关于图片的显示，这里我们先不讲怎么去网络请求，而是直接使用 Image 类提供的一个方法去加载网络图片，代码如图：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/044d760fbdcf429795ed49a93628557f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>显示效果如图：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/abbc32c8ac5949178defa602be8aad6d~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<p>这个时候，你应该也猜到了，如果挪动 children 里面 Text 和 Image 和顺序，会发现图片和文字的顺序就交换了，是不是很容易理解。如果想要调整图片和文字之间的间距怎么调呢，使用 SizedBox 类，传一个 height 就可以调整间距了，也可以继续使用 Container，代码如下：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/552a4140323044e8a58255513de3f513~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>如果觉得 itemBuilder 的代码太长，也可以将它的代码封装到一个方法里面，例如我这里使用 iOS 中的 _cellForRow 来命名这个方法。使用下划线的意义的是表示这是一个私有方法。</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/9a121339036140b0bb7ca047ceebfe76~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>APP 右上角会发现有一个 debug 图标，这个图标的显示在 MaterialApp 类里面有一个属性可以控制显示隐藏。</p>
<p><code>debugShowCheckedModeBanner: false</code></p>
<h1 id="常用-Widget-介绍"><a href="#常用-Widget-介绍" class="headerlink" title="常用 Widget 介绍"></a>常用 Widget 介绍</h1><p>在介绍常用 Widget 之前，我们想把刚刚写的 ListView 相关代码，封装到一个文件内，这样方便以后我们回头学习。listView_demo 代码如下：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/446b4ffe8afc45e99221bf5cd3afeee1~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这个时候，main.dart 文件内的 Home 类的 build 方法里，返回我们的 ListViewDemo 初始化方法就行了。</p>
<p>然后再新建一个新的 base_widget 文件，用来存放我们将要介绍的基础 Widget 代码。</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/8f77023a8d4244d783be32abf79463cd~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>可以在 main.dart 文件中直接使用我的 BaseWidgetDemo 初始化方法，这样我们就不需要再去 main.dart 文件修改代码了。每介绍一个新 Widget 直接修改 BaseWidgetDemo 的 build 方法返回值为我们的自定义类 xxxDemo() 就好了</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/76bc9786e7e84c9980e1ebee1a9b551b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>第一个介绍是 Text</p>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/41880af972fc45689907bd150a538fa0~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>Text 我们一开始讲过了，这里就再讲一点关于字符串相关的，如果需要拼接字符串可以使用 $ 符号，如果字符串中有特殊符号，那就使用 ${}。其他 Text 常用的属性，跟我们 iOS 中都差不太多，需要注意的是 Text 的样式，是在 style 里面设置的。下面看一下 APP 显示的效果</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/d993b732bdd5495a88814dc8d3374742~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<h2 id="RichText"><a href="#RichText" class="headerlink" title="RichText"></a>RichText</h2><p>RichText 就是富文本，它的 text 属性可以传一个 TextSpan 的类，这个 TextSpan 类可以设置 text 文本，设置 style 样式，还可以设置 children 子控件，这样就可以无限加花样拼接各种字符串在一起，代码如下</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/b1945fbc5bbb43cba0faa548f46bd6ce~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>APP上显示的效果：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/63e6b01de12b44449ce52f68f56b069d~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<h2 id="Container，Row"><a href="#Container，Row" class="headerlink" title="Container，Row"></a>Container，Row</h2><p>Container 是个容器，Row 是个用于布局的类，跟 Column，Center 类似，根据代码查看一下 APP 的显示，就能大概明白意思了，代码如下：</p>
<img src="/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/29e91abfa353405685dee33de2c27584~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>APP显示如下：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之一：快速入门Flutter/34a8ba5c9b5c446ab0dfc9ad49864494~tplv-k3u1fbpfcp-watermark.jpg"/>
</div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天介绍了 Flutter 里面的许多的基础 Widget，有用于布局的 Center，Row，Column…有用于显示文本的 Text，RichText，TextSpan…有列表展示 ListView，有基础架构 Scaffold，MaterialApp 类，虽然东西有点多，但基本还没有什么难以理解的内容</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年10月了黑苹果还香吗？性价比超高黑苹果台式机搭配&amp;黑苹果安装教程</title>
    <url>/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>最近一段时间对 iOS 逆向开发进行了一定的研究，之前也更新过一段时间的相关文章（后续由于搬家，不幸感染病毒🦠等一些原因断更了个把月），在学习和探索过程中，非常明显的感受到逆向分析对电脑的性能要求很高尤其是 CPU，在使用逆向分析工具 ghidra，hopper 等程序对 MachO 文件进行分析的时候，常常一分析就要等上大几个小时，而且我使用了 n 年的 MacBook Pro 在分析过程中 CPU 温度总是会飙升到 90 度以上，同时 CPU 散热风扇转速也高达 4500 转以上，甚至经常满转速 6000 转运行，噪音可想而知。等待的时间，加上风扇的噪音真的会让人失去耐性，忍无可忍之下决定购买一台性能强劲的，性价比超高的 Mac 电脑。</p>
<p>翻到苹果官网查看，动辄 3 万，5 万，甚至高达 10 万+ 的 iMac，Mac Pro，随随便便几千元的选配，让人直呼**，好奇是什么配置居然敢卖到如此价格，研究一番配置才发现价格真的是太离谱了。。。呃，苹果产品从来就不是主打一个性价比的啊。于是让人想到何不自己动手组装一台台式电脑，既能安装 windows 打打游戏娱乐放松，又能安装黑苹果日常学习工作使用。但是要注意安装黑苹果并不是一件简单，方便，快速，愉悦的事情。而且不建议在公司使用黑苹果，网上看到会收到 Apple 的律师函，尤其是一些大公司。个人作为兴趣爱学习交流使用倒也不必担心那么多。</p>
<p>对组装电脑配置和苹果 Mac 产品有些了解的人应该都知道，苹果的产品毫无性价比，尤其是台式电脑，同等配置的产品，苹果卖的贵很多，的确不可否认的是苹果的产品做的非常优秀，不论是电脑还是手机，从硬件，软件到外观设计，都属于一流的水平。笔记本电脑的确没有几家公司能做到像 MacBook 这样的水平，所以你不想要台式电脑，MacBook 还是可以推荐上车的，台式机是真的不推荐购买。但如果你是富哥想买台式机，有 MacOS 需求，对性能又没有特别高的要求，也不想折腾的，那还是直接去购买 iMac，Mac Pro 吧。但本人不是富哥，对性能还有一定的要求，还愿意折腾的选择自己组装台式机安装黑苹果就是最好的选择。</p>
<h1 id="黑苹果的现状与未来"><a href="#黑苹果的现状与未来" class="headerlink" title="黑苹果的现状与未来"></a>黑苹果的现状与未来</h1><p>最近这两年还能赶上黑苹果的末班车，再过个三五年，最多可能不超过 10 年，市面上所有 Intel + AMD 的白苹果被苹果公司抛弃，不再支持安装最新的 MacOS 系统的时候，应该就再也看不到黑苹果了。</p>
<p>今年 6 月 5 号，最后一代 Intel CPU （至强系列，属于服务器CPU） + AMD GPU 的 Mac Pro 停产了。而最后一代的家用桌面级 CPU 也就是 Intel 酷睿 10910 的 iMac （搭配的 GPU 是 RX 5700XT） 也已经早在 2022 年 3 月 8 号停产了。数据来源：<a href="https://everymac.com/">everymac</a> 。经过网上对黑苹果的一番研究，特别是 GitHub 上的一个开源项目 <a href="https://dortania.github.io/OpenCore-Install-Guide/">OpenCore</a>，感谢开源，感谢hacker，国内的大部分教程其实都是对这个项目的中文翻译加自己的整理，建议想要安装黑苹果的不管英文行的不行的都先看看这个（网页有翻译工具，阅读起来也没那么困难）得出以下一些结论：</p>
<p>到写这篇文章为止，目前能安装黑苹果的最顶级搭配，应该是：</p>
<ul>
<li>CPU i9 13900KS + GPU RX 6950XT，最近刚出的 14 代酷睿还不确定能不能安装黑苹果。</li>
</ul>
<p>最后一代能最完美实现黑苹果的顶级搭配：</p>
<ul>
<li>CPU i9 10910 + GPU RX 5700XT，这个是苹果 iMac 最后一代桌面级 Intel CPU + AMD GPU 产品，已于 2022 年 3 月 8 号停产，之后的 iMac 都是搭配苹果自研的 M 芯片了。购买跟这个同样的配置完全不担心黑苹果安装的问题，完美适配的问题。2022 年 3 月的机型配置，这个配置用个三五年也完全不成问题。</li>
</ul>
<p>个人经过对价格，性能一番分析之后认为，目前最具性价比的黑苹果搭配是：</p>
<ul>
<li>CPU i9 11900KF + GPU RX 6600XT。</li>
</ul>
<h1 id="配件选择"><a href="#配件选择" class="headerlink" title="配件选择"></a>配件选择</h1><p>组装一台台式电脑所需的配件大概是以下 8 个部分。其中对安装黑苹果影响最大的就是 CPU，GPU 了，其次是硬盘，最后稍微可能有点影响的就是内存了，最新的 DDR5 内存频率太高的不太推荐，听说是会影响黑苹果系统的稳定性。其余的就跟能否安装黑苹果没有任何关系了。我将有影响的配件放在前面讲，后续没有影响的配件都简单带过。</p>
<h2 id="CPU-的选择"><a href="#CPU-的选择" class="headerlink" title="CPU 的选择"></a>CPU 的选择</h2><p>原本以为 10 代的 CPU 会比 11 代的 CPU 会更便宜，毕竟是电子产品，年代又更久远一些，万万没有想到 10 代酷睿不知道是有哪些魔力，居然卖的比 11 代酷睿更贵。目前，11900KF 不过 ¥1200 出头，RX 6600XT 如果接受矿卡的话，也只需要 ¥1100 上下，不接受矿卡的可以选择 RX 6650XT。而且性能功耗也比 iMac 最后一代的 RX 5700XT 更加优秀。这样 CPU + GPU 买下来也只需要 ¥2300 左右。而如果买 10910 或者 10900K&#x2F;KF 的话光一个 CPU 就差不多要这个价钱了。其中 </p>
<ul>
<li>10910 价格在 ¥2050 左右。</li>
<li>10900KF 价格在 ¥1950 左右。</li>
<li>10900K 的价格要 ¥2300 以上。</li>
</ul>
<p>这样光一个 CPU 的价格就赶上 11900KF + RX 6600XT 的组合了，性能却还不如这个组合。当然如果你没有 GPU 的需求，购买 10900K 使用它的核显也是可以的。10900K 的核显理论上也能搭配 4k 显示器日常使用。</p>
<p>12 代 i5 12600 及以上等级的 CPU 和 13 代的 i5 13490F 及以上等级的 CPU 单核性能理论上都比 i9 11900KF 强一些（<a href="https://www.mydrivers.com/zhuanti/tianti/cpu/index.html">CPU性能天梯图</a>），但是这几代产品不像魔幻的 10 代酷睿，都是一分钱一分货，都要比 11900KF 贵上一些。如果不追求很高的性价比，希望性能更强一些的，也可以选择这两款或以上的 CPU。</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/11900KF.jpg" class="" alt="11900KF">

<h2 id="GPU-的选择"><a href="#GPU-的选择" class="headerlink" title="GPU 的选择"></a>GPU 的选择</h2><p>其实本来是打算照着苹果的最后一代 Intel iMac 的配置去搭配台式机的，这样不用担心能不能成功安装黑苹果，MacOS 系统能不能完美支持。也就是 10 代 i9 搭配 RX 5700XT。但是 10 代酷睿 i9 的价格让我放弃了这个想法，发现了更具性价比的 11 代 i9，于是想着既然 CPU 提升了一个等级，那么显卡要不也提升一下等级吧，RX 6600XT 性能略强于 RX 5700XT（<a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">显卡性能天梯图</a>），功耗却比 RX 5700XT 更低，价格也只贵了两三百元左右，这就是电子产品技术的进步吧，新出的产品性能比老产品强，功耗还要比老产品低。</p>
<p>至于为什么不选择更好的 RX 6800，RX 6800XT，RX 6900XT 的原因（6700系列目前不支持黑苹果），一个是由于价格原因，这几张显卡都不是 1k+ 能够拿得下来的。第二是由于本人对显卡的需求也不是那么高，RX 6600XT 在 1k 分辨率下也能无压力的运行。甚至在 2k 分辨率下也可以流畅运行满足大部分需求。搭配 4k，5k 显示器日常使用也完全没有问题，iMac 搭配的显卡 RX 5700XT 性能差不多就是配置的 5k 显示器，日常使用肯定没问题，当然如果你想要这张显卡搭配 4k 及以上分辨率显示器在 Windows 下愉快玩大型3A游戏，那可能还是有点强卡所难了，要么降低游戏的分辨率，要么直接上最顶级的 RX 6900XT&#x2F;6950XT。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘部分不是我这篇文章的重点，大部分硬盘都是没问题的，只有某些 nvme 硬盘无法安装，推荐看一下 <a href="https://hpglw.com/cdc6109c.html">这篇文章</a>。本人选择的前段时间性价比很高的宏碁掠夺者 GM7000 2T 带独立缓存，对于开发者来说应该是特别适合的。实测安装黑苹果没有问题。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>本人选择的是金百达银爵 16g * 2 3200 Mhz DDR4。搭配后面的主板开启 XMP 之后轻轻松松上到 3600 Mhz。虽然我也不甚了解现在越来越高的内存频率有什么特别大的实际作用。。。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>已经上到 i9 处理器了，主板毫无疑问推荐 Z 系列主板。Intel CPU 和主板搭配有个规律，就是 CPU 代数和主板芯片组有一个 6 的差距，比如：</p>
<ul>
<li>10 代 i9，那么搭配的主板芯片组应该是 Z490，但其实大部分 Z490 芯片组更新 BIOS 之后也能安装 11 代 CPU。</li>
<li>11 代 i9，那么搭配的主板芯片组应该是 Z590，Z590 芯片组可以安装 10 代和 11 代的 CPU。</li>
<li>12 代 i9，推荐搭配的主板芯片组是 Z690，大部分 Z690 芯片组更新 BIOS 也能安装 13 代 CPU。</li>
<li>13 代 i9，推荐搭配的主板芯片组是 Z790</li>
</ul>
<p>大概这样理解是没有问题的，只是有一些主板的兼容性好一点，多兼容几代 CPU，其实关键的地方在于 CPU 的针脚是否发生变化。主板个人选择的是某爱国嘉的 Z590M GAMING X，选择 MATX 主板的原因是不想要那么大的机箱。但是目前这款主板已经不好买到了，二手市场也几乎见不到几块了，不在乎机箱尺寸的可以选择常规 ATX 大小主板 Z590 GAMING X，这款市面上还是有不少在售卖的。</p>
<h2 id="CPU散热器"><a href="#CPU散热器" class="headerlink" title="CPU散热器"></a>CPU散热器</h2><p>CPU散热器的选择大体上分为两种，风冷和水冷。本人并不喜欢和信任水冷所以优先考虑的是风冷，11900KF 这种 11 代顶级 CPU 在满载的时候的发热量巨大，原本考虑的是利民风冷之王 FC140 ，无奈在准备购买的时候听客服说，这款产品会挡住 Z590M GAMING X 这款主板的内存，无法考证客服的说法。但按客服的推荐，选择了一款新出的利民 PS120 综合比较下来散热不输 FC140 ，尺寸也较小一圈不挡内存。</p>
<p>遗憾的是，经过实测这款散热器即使换上了台达的 12cm 3000 转暴力风扇也无法让 11900KF 不降频通过烤机测试。不过这是在开启了 AVX512 指令集的情况下。实测关闭了 AVX512 指令集之后，可以不降频通过烤机测试，温度在 80 多度左右。说实话我也一直想尝试搞懂这个 AVX512 指令集的实际作用，奈何太专业了，没搞明白。所以如果你不介意的话，关闭它之后 PS120 完全可以压制住 11900KF 这个 CPU。</p>
<p>但如果你实在介意买了这颗 CPU ，还不能完全使用它的功能，还要关闭这个虽然不知道有什么实际用途的 AVX512 指令集。那么还是建议上顶级的 240 水冷，或者 360 水冷吧。由于我机箱的限制，最多只能上到 240 水冷。不过目前并没有换的打算，因为我实在想不到除了烤机测试，还有哪些场景下能够让 CPU 满载运行很长时间。实在有这个需求了，关掉 AVX512 指令集在 PS120 的压制下也能长期满载运行。</p>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>电源的选择最重要的是功率。根据你的 CPU 和 GPU 的搭配选择适合的功率，不然你的电脑可能连开机都成问题。一开始本人并不是特别了解，随便看到几篇抖音说 RX 6600XT 显卡搭配 600W 电源就行了。于是一开始买了个 600W 的长城 V6 600W 金牌全模组电源，结果在装机的时候常常发生显示器点不亮的情况，有时候重新开机几次又能点亮，有时候开机多次也无法点亮。甚至一度怀疑是显卡，或者主板的问题去了。。。后来在 <a href="https://seasonic.com/wattage-calculator">SEASONIC<em>海韵电源</em></a> 和 <a href="https://www.msi.cn/power-supply-calculator">MSI 微星</a> 的官网找到了电源功率计算器这个工具，计算下来才发现，我的配置 i9 11900KF + RX 6600XT 最低要求的电源功率也要 650W ，推荐上 700W 及以上功率的电源更好，这样可以应对以后配件升级的情况。至于其他的什么电容啊，80PLUS认证，模组化啊，本人倒觉得不是那么必要，功率才是必须要选择对的。由于本人并没有后期升级的打算，于是就换成了长城的 V7 700W 金牌全模组电源。</p>
<h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><p>机箱之前说过，本人不喜欢特别大的机箱，电脑的发展历史，就是越做越小的一段历史。现在的商家为了把产品卖出更高的价格，往往高配置的电脑喜欢搭配巨大的机箱。。。本人真的是接受不了。所以选择了一块 mATX 主板，那么机箱自然也是选择搭配 mATX 主板的小机箱。本人选择的是旅行者，机箱上方附带一个把手，可以很方便的一只手提起来。机箱不自带风扇，本人额外购买了两把台达 12cm 3000转静音温控风扇，只要 ¥17 元人民币1把。真的是物美价廉，风量比太多所谓的品牌风扇大多了。</p>
<h1 id="安装-Hackintosh"><a href="#安装-Hackintosh" class="headerlink" title="安装 Hackintosh"></a>安装 Hackintosh</h1><p>硬件都选配好了，接下来就是安装系统了。如果你选择的是 10 代酷睿 CPU，那么按照 OpenCore 官方文档的步骤来进行黑苹果安装，会十分的顺利，因为 OpenCore 目前对 10 代及以内的 CPU 的文档都特别详细。10 代之后的 CPU 有一些官方文档没有明确写明的地方需要自己摸索。</p>
<p>安装黑苹果的步骤，概括的来说，跟安装 window 没有太大区别，多了一个自己配置 EFI 文件的步骤。</p>
<h2 id="1-将-U-盘制作成系统安装盘"><a href="#1-将-U-盘制作成系统安装盘" class="headerlink" title="1. 将 U 盘制作成系统安装盘"></a>1. 将 U 盘制作成系统安装盘</h2><p>制作 U 盘系统安装盘的方式多种多样，这里我只讲诉我自己的使用过的方式，就是在 MacOS 上制作。其他的方式自己参考 <a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/">OpenCore文档</a>。</p>
<h3 id="1-1-下载-macOS-安装程序"><a href="#1-1-下载-macOS-安装程序" class="headerlink" title="1.1 下载 macOS 安装程序"></a>1.1 下载 macOS 安装程序</h3><p>使用 App Store 搜索你想要安装的 Mac OS 系统，下面以 macOS Ventura 为例。</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/01.png" class="" alt="image.png">

<p>点击获取就可以等待下载完成了。。。下载完成之后可以在启动台中看到，如下图所示：</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/02.png" class="" alt="Xnip2023-10-18_14-58-49.png">

<p>在等待下载的过程中，可以先执行下一步格式化 U 盘。</p>
<h3 id="1-2-格式化-U-盘"><a href="#1-2-格式化-U-盘" class="headerlink" title="1.2 格式化 U 盘"></a>1.2 格式化 U 盘</h3><p>U 盘大小建议至少是 16G 以上的。</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/03.png" class="" alt="image.png">

<p>然后点击右上角的抹掉，之后按照下图的选择进行抹掉操作。</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/04.png" class="" alt="Xnip2023-10-18_16-52-01.png">

<p>这里的名称一定要记住，后面还要用到的。我的建议是改成 OpenCoreUSB，当然这个无所谓，只要记得后面要用到就行。</p>
<h3 id="1-3-将-U-盘制作成系统安装盘"><a href="#1-3-将-U-盘制作成系统安装盘" class="headerlink" title="1.3 将 U 盘制作成系统安装盘"></a>1.3 将 U 盘制作成系统安装盘</h3><p>等到 macOS 安装程序下载好了之后，也即是在 1.1 中的第二张图片那样，在启动台中能看到安装 macOS Ventura 了。打开系统自带的终端app，输入以下指令（友情提示，太长的指令可以输入前几个字母之后按 TAB 键自动补全）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ Ventura.app/Contents/Resources/createinstallmedia --volume /Volumes/OpenCoreUSB</span><br></pre></td></tr></table></figure>
<p>输入电脑开机密码之后，再输入 y 按回车确认。安装时间有点慢，取决于你的 U 盘读写速度。如下图所示</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/05.png" class="" alt="Xnip2023-10-18_17-33-34.png">

<p>跟上面结果一样就表示你的U盘系统安装盘制作好了</p>
<h2 id="2-配置-EFI-文件夹"><a href="#2-配置-EFI-文件夹" class="headerlink" title="2. 配置 EFI 文件夹"></a>2. 配置 EFI 文件夹</h2><p>安装黑苹果的步骤当中，最麻烦的就是这一步了。很多人会去网上搜索跟自己配置相同的人分享出来的 EFI 文件。但是实际上往往很难搜到完全相同的配置，或者即使是完全相同的配置依然是无法成功安装黑苹果。所以还是推荐照着 OpenCore 官方文档的步骤一步步自己动手配置 EFI 文件最靠谱。我这里会大概讲一下我自己配置的过程，具体的很多细节可以查阅官方文档中。</p>
<h3 id="2-1-下载-OpenCore-最新的版本"><a href="#2-1-下载-OpenCore-最新的版本" class="headerlink" title="2.1 下载 OpenCore 最新的版本"></a>2.1 下载 OpenCore <a href="https://github.com/acidanthera/OpenCorePkg/releases/">最新的版本</a></h3><p>这里会有 Debug 和 Release 两个版本，虽然官方推荐第一次使用选择 Debug 版本，但是我个人的经验来看还是建议直接选择 Release 版本，因为只要是按照教程一步步来的，基本不会出现问题，而就算你使用 Debug 版本出现了报错，也基本上看不懂任何一点报错的代码。。。太抽象了，反正我的确是用过 Debug 版本也遇到无法安装的情况，结果就是完全看不懂一点报错信息，也搜不到任何相关的资料。反而是认认真真照着教程又重新配置了几遍，才成功安装上的，最后还要回过头将所有 Debug 版本文件替换为 Release 版本。</p>
<p>我们将要使用的 EFI 文件夹：</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/06.png" class="" alt="image.png">

<h3 id="2-2-挂载-U-盘上的-EFI-分区"><a href="#2-2-挂载-U-盘上的-EFI-分区" class="headerlink" title="2.2 挂载 U 盘上的 EFI 分区"></a>2.2 挂载 U 盘上的 EFI 分区</h3><p>在前面格式化 U 盘的过程中，我们选择的格式化方案会在 U 盘上自动创建一个隐藏的没有挂载到系统的 EFI 分区，现在需要将这个分区挂载到系统上，以便我们操作这个分区。挂载的方式有很多种</p>
<ul>
<li>有通过终端纯命令行的方式 <a href="https://github.com/corpnewt/MountEFI">MountEFI</a>。</li>
<li>也有通过使用一个 app 的图形化的方式 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。</li>
</ul>
<p>以下是使用 OpenCore Configurator 的截图。</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/07.png" class="" alt="image.png">

<p>挂载之后就可以看到 U 盘的隐藏 EFI 分区了。然后将上一步中下载的 EFI 文件夹复制到这个 EFI 分区中。注意 EFI 分区下有一个 EFI 文件夹不要搞糊涂了。</p>
<h3 id="2-3-添加文件到各个子文件中"><a href="#2-3-添加文件到各个子文件中" class="headerlink" title="2.3 添加文件到各个子文件中"></a>2.3 添加文件到各个子文件中</h3><p>从现在开始，要确保我们所有的操作都是对 U 盘 EFI 分区的 EFI 文件夹进行操作。现在，先简单认识一下 EFI 文件夹里的子文件夹：</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/08.png" class="" alt="image.png">

<ul>
<li><p>ACPI：说实话，这个文件夹我一直没有完全搞明白，翻译的内容，英文的缩写太多了，只知道这里面的内容大概跟 CPU 架构和电源管理等内容相关，官方文档只讲到了 10 代酷睿，后面的 11，12，13 以及刚出的 14 代酷睿并不在官方文档中，但我从其他资料中看到，10 代之后的酷睿 CPU 都可以按照 10 代酷睿的那样配置。所以按照我的配置，我们需要以下三个文件：</p>
  <img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/09.png" class="" alt="image.png">
<ul>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-AWAC.aml">SSDT-AWAC.aml</a></li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-EC-USBX-DESKTOP.aml">SSDT-EC-USBX-DESKTOP.aml</a> </li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-PLUG-DRTNIA.aml">SSDT-PLUG-DRTNIA.aml</a></li>
</ul>
</li>
<li><p>Drivers：固件驱动程序是 OpenCore 在 UEFI 环境中使用的驱动程序。大部分情况下我们只需要两个文件</p>
  <img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/10.png" class="" alt="image.png">
<ul>
<li><a href="https://github.com/acidanthera/OcBinaryData/blob/master/Drivers/HfsPlus.efi">HfsPlus.efi</a></li>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenRuntime.efi</a></li>
</ul>
<p>  虽然下载的 OpenCore 自带的 Drivers 里面会有很多文件，其中也包括上面这些文件，但我个人还是建议删掉自带的所有 efi 文件，点击上面的链接自己下载。因为自带的文件有些名字都改了，搞的人不知道该怎么处理。</p>
</li>
<li><p>Kexts：kext 是一个内核扩展，您可以将其视为 macOS 的驱动程序。大多数 kext 都可以在 <a href="https://dortania.github.io/builds/">构建存储库</a> 中找到已编译好的。每次有新提交时都会编译此处的 Kext。对于我的配置，需要以下这些文件</p>
  <img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/11.png" class="" alt="image.png">
<ul>
<li><a href="https://dortania.github.io/builds/?product=Lilu&viewall=true">Lilu.kext</a> 用于修补许多处理器的补丁，也是很多其他内核扩展的基础。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCProcessor.kext</a> 用于监控 Intel CPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">SMCRadeonGPU.kext</a> 用于监控 GPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">RadeonSensor.kext</a> 还有一个 RadeonGadget 是一个 app 用于在右上角显示 GPU 温度的，需要搭配当前内核扩展使用，所以并不需要放在 Kexts 下。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCSuperIO.kext</a> 这个和 SMCProcessor.kext 在一块</li>
<li><a href="https://dortania.github.io/builds/?product=WhateverGreen&viewall=true">WhateverGreen.kext</a> 显卡驱动，可以从构建存储库中下载最新版本。</li>
<li><a href="https://dortania.github.io/builds/?product=AppleALC&viewall=true">AppleeAlc.kext</a> 声卡驱动，还需要在配置文件中添加一个配置。在官方文档上可以看到。</li>
<li><a href="https://www.insanelymac.com/forum/files/file/1004-lucyrtl8125ethernet/">LucyRTL8125Ethernet.kext</a> 有线网卡驱动</li>
<li><a href="https://github.com/USBToolBox/kext/releases">USBToolBox.kext</a> 用于修复 USB 端口连接的</li>
<li>UTBMap.kext 这个扩展需要借助这个<a href="https://github.com/USBToolBox/tool/releases">工具</a>自己制作自己的。</li>
<li><a href="https://github.com/acidanthera/NVMeFix/releases">NVMeFix.kext</a> 用于修复非 Apple NVMe 上的电源管理和初始化</li>
<li><a href="https://github.com/acidanthera/RestrictEvents/releases">RestrictEvents.kext</a> 这个对我来说主要是为了修复在模仿使用 MacPro7,1 机型的时候，右上角会弹出“内存模块配置错误”的问题的。<!--但是我使用了一段时间后才发现，右上角有一个小的矩形区域无法点击的bug，不知道是不是它导致的。其实不要这个扩展也没什么问题，要么换成 iMacPro1.1 机型就不会有这个提示，要么不在乎提示，每次启动后出现的时候点击关闭就好了。--></li>
</ul>
</li>
<li><p>Resources：这里主要是美化 OpenCore 启动时的外观界面的，如果不配置就使用纯字母的形式显示，配置了会有图标，好看一点，就像白苹果里那样显示。感兴趣的可以去官网搜索自行配置。不影响安装。</p>
</li>
<li><p>Tools：工具类的文件，可以放在这里，不过不懂如何使用的也没什么必要放了，毕竟也不影响安装。</p>
</li>
</ul>
<p>这里我并没有添加无线网卡蓝牙相关的驱动，因为我没有 macOS 上能驱动的无线网卡，如果有这个需要打算购置的话可以查看 <a href="https://dortania.github.io/Wireless-Buyers-Guide/">无线网卡购买指南</a>。</p>
<h3 id="2-4-配置-config-plist-文件"><a href="#2-4-配置-config-plist-文件" class="headerlink" title="2.4 配置 config.plist 文件"></a>2.4 配置 config.plist 文件</h3><p>plist 文件对于 iOS 开发者来说并不陌生，对其他开发者来说可以理解成一种特殊的 XML 文件。上一步添加需要的文件麻烦，这一步则可能是最麻烦的了。需要按照 <a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html">官方文档</a> 仔细比对每个需要的键。先从下载的 OpenCore 文件夹中找到 Sample.plist 文件，然后复制到 U 上 EFI 分区的 OC 文件夹下并重命名为 config.plist。</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/12.png" class="" alt="image.png">

<p>虽然可以直接通过 Xcode 对 config.plist 进行编辑，不过由于大多数人对这个文件的修改都不熟悉，不知道哪些能不能删，如何修改，所以还是建议使用一些专门的工具进行编辑，就比如我们之前挂载 EFI 分区使用到的 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。这个 plist 文件主要的工作其实就是对当前文件夹下的其他文件，建立一个关联，当然还有它本身自带一个配置需要修改。</p>
<p>绝大部分的配置，官方文档都写的很清楚了，我不再重复，只有以下几点，官方文档没有写明的：</p>
<ol>
<li><p>Kernel -&gt; Emulate<br> 也就是仿冒 CPU。 对于 10 代酷睿之后的 CPU 都需要配置这个键。其实这个配置可以在 OpenCore 下载的文档里可以找到。Rocket Lake 就是 11 代酷睿的 CPU 代号</p>
 <img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/13.png" class="" alt="image.png">
<p> 在 OpenCore Configurator 中的设置如下：</p>
 <img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/14.png" class="" alt="image.png">
</li>
<li><p>如何使用 OpenCore Configurator。用它打开你 OC 文件夹下的 config.plist 可能会有一些默认的配置，使用右下角的 - 号全部删除。点击快照&#x2F;浏览会自动添加对应的文件夹下的文件。修改完成后记得保存，最后可以用 Xcode 或预览查看刚刚的修改是否真的保存了。</p>
</li>
</ol>
<p>如果你有足够的耐心，照着官方的文档，一步步完成了所有应该的配置。那么恭喜🎉你可以进入下一步，安装系统了</p>
<h2 id="3-安装系统"><a href="#3-安装系统" class="headerlink" title="3. 安装系统"></a>3. 安装系统</h2><h3 id="3-1-调整主板-BIOS"><a href="#3-1-调整主板-BIOS" class="headerlink" title="3.1 调整主板 BIOS"></a>3.1 调整主板 BIOS</h3><p>在正式开始安装之前，还需要对主板的 BIOS 进行一些设置。<a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html#cleaning-up">官网</a> 和 <a href="https://apple.sqlsec.com/3-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3-1/">国光</a> 的教程都很全面了，我这里只讲一下自己的主板 z590m gaming x 有的一些设置。这里我已经将 BIOS 更新到最新的 F8 版本了，在技嘉官网下载并更新最新版本的 <a href="https://www.gigabyte.com/Motherboard/Z590M-GAMING-X-rev-10/support#support-dl-bios">BIOS</a> ，这一步可能不是必须的。因为即使是最新的版本，依然有很多设置没有出现在 BIOS 中。以下是我这个主板的一些 BIOS 设置。</p>
<h4 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h4><ul>
<li>Fast Boot 这个有，在 Boot 选项下</li>
<li>Secure Boot 这个有，在 Boot 选项下</li>
<li>Serial&#x2F;COM Port 有，在 Settings -&gt; IO Ports -&gt; Super IO Configuration 下</li>
<li>Parallel Port 没找到</li>
<li>VT-d 有，Favorites 下就有，同样出现在 Settings -&gt; Miscellaneous 下</li>
<li>Compatibility Support Module (CSM) 有，在 Boot 下</li>
<li>Thunderbolt 没找到</li>
<li>Intel SGX 没找到</li>
<li>Intel Platform Trust 有，在 Setting -&gt; Miscellaneous 下</li>
<li>CFG Lock (MSR 0xE2 write protection) 有，在 Boot 下</li>
</ul>
<h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><ul>
<li>VT-x 没找到</li>
<li>Above 4G Decoding 有，在 Settings -&gt; IO Ports 下</li>
<li>Hyper-Threading 有，在 Tweaker -&gt; Advanced CPU Setings 下</li>
<li>Execute Disable Bit 没找到</li>
<li>EHCI&#x2F;XHCI Hand-off 有，在 Settings -&gt; IO Ports -&gt; USB Configuration 下</li>
<li>OS type: Windows 8.1&#x2F;10 UEFI Mode (some motherboards may require “Other OS” instead) 没有一样的，但是将 Boot 下的 Windows 10 Features 设置为 Other OS 了</li>
<li>DVMT Pre-Allocated(iGPU Memory): 64MB or higher 没找到，对于11900KF不带核显的 CPU 应该是没有这个设置的。</li>
<li>SATA Mode: AHCI 有，在 Settings -&gt; IO Ports -&gt; SATA And RST Configuration 下</li>
</ul>
<h3 id="3-2-开始安装"><a href="#3-2-开始安装" class="headerlink" title="3.2 开始安装"></a>3.2 开始安装</h3><p>终于来到了这激动人心的安装步骤。确保 U 盘插入主板后面的 USB3 插口上，我试过插在机箱面板的插口上会有些问题，开机按 F12 选择 U 盘启动。就会进入到 OpenCore 的选择页面，选择 Install macOS Ventura (external) ，进入后先选择磁盘工具格式化硬盘，选择 APFS 格式和 GUID 分区图方案。完成之后，退出磁盘工具，选择安装 macOS Ventura 接下来的操作就是按照提示一步步操作了，中间会重启多次，直到进入选择语言界面，那么恭喜你，你做到了！</p>
<h1 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h1><p>安装完后看看关于本机，和 Geekbench 的信息</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/15.png" class="" alt="image.png">

<p>先上一下 Geekbench 5 的跑分。</p>
<img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/16.png" class="" alt="image.png">

<p>可能很多人并不知道，这个跑分的水平在哪里。所以我找了几款 Mac 机型的跑分作为对比。</p>
<ol>
<li><p>同为 MacPro7,1 型号的白苹果，在今年 6 月 5 号刚停产。搭配的是 Intel Xeon 处理器。选用28核的这款作为对比。可以看到 11900KF 的单核性能远超这款配置。多核性能由于 11900KF 只有 8 个核心，的确比不上 28 核心的 Xeon，但也有一个不错的分数。但是考虑到这款配置的 MacPro 的售价 RMB 103,379 。这点多核心性能的差距简直不值一提。</p>
 <img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/17.png" class="" alt="image.png">

<p> 如果选用同样是 8 个核心的 Xeon 处理器那款 MacPro7,1 则无论是单核性能还是多核性能都会被 11900KF 吊打。恐怖的是 8 核心的这款 MacPro 7,1 售价也高达 RMB 51,999。对比我自己配置的这台 5000 块都不到的 11900KF 真的是太香了。</p>
</li>
<li><p>最新款的 MacPro14,8 搭载的是 Apple 自研的 M2 Ultra 芯片。M2 芯片分为 M2，M2 Pro，M2 Max，M2 Ultra，性能依次上升。11900 KF 的性能介于 M2 和 M2 Pro 之间。再考虑到 M2 芯片的最便宜的机型 MacBookAir 最低也要 1w 以上。自己配的 11900KF 还是还是很香的，只是没有上面那么香😄罢了。M2 芯片作为 2022 年的产品的确还是要比 2021 年上市的 11900KF 性能强劲，而且功耗更低。当然，如果一定要用 Intel 来对比 M 芯片，可能依然是 13900KS 更加强劲。但用 13900KS 性价比就没有 11900KF 那么高了。</p>
 <img src="/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/18.png" class="" alt="image.png"></li>
</ol>
<p>说完了跑分上面的测试，说说自己实际的体验吧。用 ghidra 分析同一份 MachO 文件的耗时，老电脑依旧是好几个小时以至于我都没有测完就放弃了，而新电脑也用了快 1 个小时。这可能是由于 ghidra 为了通用性跨多个平台都能使用，所以并没有完全利用每个平台的完整性能，导致都比较慢吧。</p>
<p>用 hopper 分析同一份 MachO 文件的耗时，hopper 在分析完之后会给出后台分析的耗时，新电脑只有 7 分钟左右，老电脑分析了接近 30 分钟，提升还是很明显的。免费的 hopper 每次只有 30 分钟的体验时间，以前每次分析完，就到时间了，多难受。。。</p>
<p>显卡方面的测试，由于我目前并没有剪辑，制图方面的需求，所以就没有测试了。。。</p>
<p>编译了一个以前非常耗时的 Xcode 项目对比，也快了许多。总的来说，性能提升非常的明显。自己组装台式电脑安装黑苹果真的是太香了，趁着现在黑苹果所剩不多的几年，有需要的人可以赶紧上车了。</p>
]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Hackintosh</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之三</title>
    <url>/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/</url>
    <content><![CDATA[<h1 id="搭建项目主框架"><a href="#搭建项目主框架" class="headerlink" title="搭建项目主框架"></a>搭建项目主框架</h1><h2 id="新建微信聊天，通讯录，发现，我的四个文件"><a href="#新建微信聊天，通讯录，发现，我的四个文件" class="headerlink" title="新建微信聊天，通讯录，发现，我的四个文件"></a>新建微信聊天，通讯录，发现，我的四个文件</h2><p>上一篇文章最后我们已经将 APP 的 TabBar 和四个对应的子视图搭建好了，但是每一个子视图里面肯定会有大量的代码，全部放到 rootPage 文件里面肯定是不合理的。所以我们为每个子视图创建单独的文件，并将代码分散到每个文件中。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/c5a720ed438344788169ab80fb409938~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>比如聊天页面，返回自己的 Scaffold：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/618e714770d24d4facaee7b437ac7fc8~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>现在我们点击切换一下 tabBar 的 item，发现会有一些高亮的颜色，以及一个水波纹效果，这些都是 MaterialApp 类的 theme 提供的。如果想去掉这些效果，要来到 main.dart 文件，设置以下两个属性：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/b1260254db7f4ab686c8c79d65a0382b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>仔细查看点击 item 的时候，文字被放大了。这个是 bottomNavigationBar 的属性 <code>selectedFontSize</code> 决定的，将它设置为 12.0 之后，就不会变大了，在 rootPage.dart 文件里面：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/9717b7c335fa4065ab4e4fc9e20bfd48~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="本地资源文件"><a href="#本地资源文件" class="headerlink" title="本地资源文件"></a>本地资源文件</h1><h2 id="配置-Android-的启动图和应用图标"><a href="#配置-Android-的启动图和应用图标" class="headerlink" title="配置 Android 的启动图和应用图标"></a>配置 Android 的启动图和应用图标</h2><p>Android 和 iOS 的资源文件，比如 APP 的图标，启动图，需要到相应的项目文件里面去配置。我们大家都是 iOS 开发者了，这里就只说一下 Android 的图标和启动图如何配置。有需要图片资源的同学可以前往 <a href="https://github.com/masterKing/wechatDemo">下载</a></p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/77f7870a53b74d518e85e699e8907c46~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在安卓模拟器上运行起来之后，会发现安卓的标题不是在中间</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/89e269268c514376849e3342fcdee59d~tplv-k3u1fbpfcp-watermark.png" class="" alt="Screenshot_1626706998.png">

<p>这里可以通过 AppBar 的一个属性，来调整让它变成中间显示</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/2d6097f5de8b4cbd841253298032542a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="配置公共的资源"><a href="#配置公共的资源" class="headerlink" title="配置公共的资源"></a>配置公共的资源</h2><p>如果是两端都需要的资源，比如我们 APP 的微信，通讯录，发现和我的图标。需要在当前 flutter 项目中配置了。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/5ff5a0d3eacd4063a2b0cca656e65d89~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>pubspec.yaml 文件是我们 flutter 项目的配置文件。文件内 assets 和下面的几行表示需要的图片路径，可以在 flutter 项目的根目录下创建一个 images 的目录，里面存放所有当前 flutter 需要用的图片。然后还需要手动导入一张一张图片…这点就比较恶心人了…更恶心人的是，这个 yaml 文件的格式，包括位置都不能错，比如刚刚放开注释的时候，如果你使用的是 command + &#x2F; 快捷键，那么你就得好好挪动下位置了，位置不对编译不通过。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/5a076f973f1641b7a93f4a03fbf8d67c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="实现发现页"><a href="#实现发现页" class="headerlink" title="实现发现页"></a>实现发现页</h1><div align=center>
<img src="8天让iOS开发者上手Flutter之三/6c5ef89f17244d2c8d2403d8bf74e9c5~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<h2 id="设置APP启动默认展示发现页面"><a href="#设置APP启动默认展示发现页面" class="headerlink" title="设置APP启动默认展示发现页面"></a>设置APP启动默认展示发现页面</h2><p>这个方便我们开发调试这个发现页面，我们开发原生 APP 的时候也经常会这么干。直接将 rootPage.dart 里的 _currentIndex 设置为 2 就 OK 了，这个不用多说</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/60a72f30b2d148278ab955c188675989~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="配置导航条"><a href="#配置导航条" class="headerlink" title="配置导航条"></a>配置导航条</h2><p>微信的导航条颜色是灰色的。然后在安卓上这个导航条标题默认在左侧，这里也需要设置一下在中间。然后标题的颜色也不是白色，改为黑色。然后导航条和下面的 body 有一条黑线，可以通过设置 <code>elevation</code> 的值来控制。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/7baba8c474044957b85468f0542ea7fd~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<div align=center>
<img src="8天让iOS开发者上手Flutter之三/84d5ab21e4944283bdcd5087c173c1b1~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<h2 id="自定义发现-cell"><a href="#自定义发现-cell" class="headerlink" title="自定义发现 cell"></a>自定义发现 cell</h2><p>新建一个 pages 文件，将所有页面文件都放到里面。然后在新建一个 discover_cell 准备实现自定义的 cell。按道理来说一个 cell 应该是需要更新UI的所以应该是有状态的，但是现在我们是练手过程，可以先用一个无状态的 cell。 </p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/e86442ff86fa425dacb5e072a958928a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>接下来就是实现这个自定义 cell（discover_cell）的代码了；首先观察微信的发现页的 cell，左侧有一个图标，和一个标题，这两个是必须要有的，不然无法构成一个完整的 cell，然后是右侧有些 cell 会有子图标和子标题，还有一个右箭头，这个是每个 cell 都存在的。根据以上这些信息，我们就可以定义出 discover_cell 应该要有的一些属性了。如下：<br></p>
<ul>
<li><code>title</code> 左侧的标题，必传参数<br></li>
<li><code>imageName</code> 左侧的图标，必传参数<br></li>
<li><code>subTitle</code> 右侧的标题，非必传参数，也叫可选参数<br></li>
<li><code>subImageName</code> 右侧的图标，可选参数<br></li>
</ul>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/343b247159da4bf79641790d5aaf811c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>如图所示，声明了这四个属性之后，给出了红色的报错，可以将光标移到报错的红色字母任意处，按住 option + 回车 就可以弹出右侧的选择菜单，第一个选项应该是新版本加的，俺也不是很清楚如何使用，网上资料很少，推荐去查询官方文档了。我这里就懒的去查了，因为我们要选择的是第二个选线 <code>Create constructor for final fields</code> 创建构造方法。细心的同学会发现 <code>subTitle</code>,<code>subImageName</code> 的类型是 <code>String?</code> 这个类型后面跟了个问号，就是代表可选参数的意思，这里跟 iOS 的 Swift 倒是十分相似。</p>
<p>选择创建构造方法之后，系统会自动生成一行代码，但是这一行代码很长而且它不换行，非常难看。这里有个小技巧，在生成的代码最后一个属性后面加上一个,号然后再按 option + command + L 重新格式化代码，就会自动换行了。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/6dea5bcdc29e496f8e4eb2bdbbe2b486~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>换行之后发现，两个必传参数报错，还是老办法，光标移动到报错的地方，按住 option + 回车 就会给出提示，意思我们要给必传参数加上 <code>required</code> 关键字。这样属性的定义就算完成了。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/8bf3d583b85e4553a2d146bd9d887562~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>属性定义完了之后就是实现 build 方法搭建界面了。布局界面的方式有很多，可以使用 Row 来布局，也可以使用 Stack 加 Positioned 布局，不管什么方式能实现界面效果都可以。我这使用 Row 布局。代码如下：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/7792f9602b8c415da1cc7a104894d2bc~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>最外层使用一个 Container 包装一个 Row，然后 Row 里面再包含两个 Container 包着的 Row 分别代表左右两边子视图。这样看上去应该还算蛮清晰明了的。左侧部分的图标和标题是必传参数，没啥好说的。</p>
<p>右侧由于子标题和子图标都不一定存在，所以需要做一些处理，Text 控件如果没有子标题可以显示空字符串‘’，这个比较好解决。而子图标不能说给一张空图片，所以需要根据 subImageName 是否为空来显示不同的控件，如果有就显示 Image，如果没有就显示一个 Container 占位。最右侧的箭头图标是每个 cell 都存在的就没啥好说的了。自定义 discover_cell 的代码就算完成了，下一步完善我们的发现页面</p>
<h2 id="完善发现页面"><a href="#完善发现页面" class="headerlink" title="完善发现页面"></a>完善发现页面</h2><p>cell 写好之后，完善发现页面就简单多了。这里使用最简单的方式来实现，就是直接拼接每个子 cell 的方式。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/bb9c501966b64ea89b16224243716420~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>flutter 里面的 ListView 并不像 iOS 中的 UITableView 那样分组和行。ListView 只有行，自行合并几个行组成一组，组与组之间使用一个 SizedBox 隔开，行与行之间使用 Row(因为分割线左侧是白色的，右侧是灰色的，所以需要组合两个 Container)隔开。</p>
<p>其中购物哪一行 cell 右侧的子标题和子图标没有设置字体大小和图标大小，所以显示可能会有点问题，回到 cell 里面设置一下就好了。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/e792b6ca4c2a476eae4ebed34f16b6d4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="实现点击cell切换到新页面"><a href="#实现点击cell切换到新页面" class="headerlink" title="实现点击cell切换到新页面"></a>实现点击cell切换到新页面</h1><h2 id="让cell能够响应点击事件GestureDetector"><a href="#让cell能够响应点击事件GestureDetector" class="headerlink" title="让cell能够响应点击事件GestureDetector"></a>让cell能够响应点击事件<code>GestureDetector</code></h2><p>flutter 提供了一个 <code>GestureDetector</code> 类用来检测手势，它有一个 child 属性，可以放我们的UI代码。它还能响应各种手势，在不同的属性里面处理，比如我们点击 cell 就是 onTap 属性。除了 onTap 之外，还有 onTapDown,onTapCancel。其中 onTapCancel 是触摸之后离开了，onTapDown 是按下就会被调用，onTap 按下去并松开之后调用。实现如下代码之后，自己试试就能明白其中差别了。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/b507b1093e6a4361a9e8f14e840b3b1f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="实现页面之间跳转"><a href="#实现页面之间跳转" class="headerlink" title="实现页面之间跳转"></a>实现页面之间跳转</h2><p>点击发现 cell 之后，需要跳转它对应的详情页面，就需要一个详情页。可以新建一个 discover_child_page.dart 文件，再去补充里面的页面代码。也可以从现有的一些空白文件中复制一份，比如 mine_page.dart 文件，它里面就只有基本的我的页面代码,只需少量修改代码就可以使用。不论使用哪种方式，新建 discover_child_page.dart 完成后，页面代码如下：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/5bcbe870debf4fc39d84a72d6c47f429~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这个详情页的一些属性，应该是需要从外面传入的，比如 title。于是定义一个 title属性。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/433df2447dad40ff9866d7847f57e1e0~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后在当前页面展示我们的 title，之前都是在 StatelessWidget 里面使用我们的属性，那在 StatefulWidget 里面我们怎么使用属性呢？属性前面加上 widget.</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/39f5610e04f049959d75933a5ed05ea2~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>到这里发现详情页就算差不多完成了。</p>
<p>回到 cell 里面的点击方法，实现点击跳转。这里和 iOS 有点类似的地方就是同样是使用一个导航控制器类。flutter 也是使用一个名字叫导航的类 <code>Navigator</code>。调用以下方法。</p>
<figure class="highlight plaintext"><figcaption><span>dart</span></figcaption><table><tr><td class="code"><pre><span class="line">Navigator.of(context).push(）</span><br></pre></td></tr></table></figure>

<p>push() 的参数需要一个 Route 类型，这里使用 <code>MaterialPageRoute</code> 类，<code>MaterialPageRoute</code> 的构造方法返回一个 Widget，这个返回的 Widget 就是我们需要跳转到的页面。代码如下：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/4986f78b3e6a42919b2ef7b3cd75e947~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>前面讲过的，在 flutter 中，如果函数体的代码只有一句的话，可以使用 &#x3D;&gt; 的形式，于是上面可以简写成这样：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/1ad80766d4c4410db13e6dbc1be75f97~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="实现有状态的-discover-cell"><a href="#实现有状态的-discover-cell" class="headerlink" title="实现有状态的 discover_cell"></a>实现有状态的 discover_cell</h1><h2 id="修改-discover-cell-为-StatefulWidget"><a href="#修改-discover-cell-为-StatefulWidget" class="headerlink" title="修改 discover_cell 为 StatefulWidget"></a>修改 discover_cell 为 StatefulWidget</h2><p>原生的微信 APP 在点击 cell 的时候，会有一个灰色的背景，在松开的时候会变回最初的颜色。现在来实现这个效果。所以我们的 discover_cell 需要从 StatelessWidget 改为 StatefulWidget。先将 build 方法缩起来，快捷键 command 加 - 号，0 右边那个减号。</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/9f0eaa6f32594407a3b329b56d8bd12b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后先将 bulid 方法覆盖，再将属性和构造方法覆盖。最后删除原有的 StatelessWidget 类。这时候 build 方法里面会爆一个错误，原因是<code>_DiscoverCellState</code> 类里面拿不到 <code>DiscoverCell</code> 的属性，所以我们在属性前面加上 <code>widget.</code> 就好了。</p>
<h2 id="实现点击变灰需求"><a href="#实现点击变灰需求" class="headerlink" title="实现点击变灰需求"></a>实现点击变灰需求</h2><p>我们前面说过了 onTap 方法，onTapDown 方法，onTapCancel 方法的调用时机。实现这个需求就在这三个方法里面更新状态就好了。代码如下：</p>
<img src="/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/989f099de0f342a99860d199f4c16330~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">



]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之七</title>
    <url>/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/</url>
    <content><![CDATA[<p>上一篇文章我们已经完成首页聊天页面的导航条和列表展示，今天的任务是完成搜索 cell 的展示和点击之后的搜索页面的功能。</p>
<h1 id="自定义-SearchCell"><a href="#自定义-SearchCell" class="headerlink" title="自定义 SearchCell"></a>自定义 SearchCell</h1><h2 id="新建-search-cell-dart-文件"><a href="#新建-search-cell-dart-文件" class="headerlink" title="新建 search_cell.dart 文件"></a>新建 search_cell.dart 文件</h2><img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/1dbd72608e914624a9d4585ad1097307~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="实现-SearchCell-代码"><a href="#实现-SearchCell-代码" class="headerlink" title="实现 SearchCell 代码"></a>实现 SearchCell 代码</h2><p>SearchCell 的话，因为仅仅只是展示，点击之后就进入搜索页了，应该来说是不需要状态的，所以用一个 StatelessWidget 就够了。然后布局的方式使用一个 Container 包含一个 Row，Row 里面包一个图片和文本就可以了。布局的方式其实多种多样，能实现就好了。完整代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/d0128b2c771c49c59ef63ecd63e85895~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>一个有意思的地方是，flutter 里面的 Image 居然可以设置颜色，而且颜色是设置给图片的。比如我的放大镜图片原本是黑色的，设置红色之后，居然真的变红色了！！！</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之七/7c322f9a1989444792c8be1a83af7e8e~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<h2 id="使用-SearchCell"><a href="#使用-SearchCell" class="headerlink" title="使用 SearchCell"></a>使用 SearchCell</h2><p>SearchCell 的展示就算写完了，然后在 ChatPage.dart 中使用，我们把 ListView 的 itemBuilder 方法抽取出来，然后因为我们多加了一个 SearchCell，所以 itemCount 需要加 1，然后取 _chatList 数据的时候也要处理一下下标。</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/17291ce793da406ba1a0877a2350c65e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="自定义-SearchPage"><a href="#自定义-SearchPage" class="headerlink" title="自定义 SearchPage"></a>自定义 SearchPage</h1><h2 id="新建-search-page-dart-文件"><a href="#新建-search-page-dart-文件" class="headerlink" title="新建 search_page.dart 文件"></a>新建 search_page.dart 文件</h2><img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/0699384aaddf495185d41f9dfbfb4d63~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="简单实现-SearchPage"><a href="#简单实现-SearchPage" class="headerlink" title="简单实现 SearchPage"></a>简单实现 SearchPage</h2><p>SearchPage 作为一个页面，使用 StatelessWidget 肯定是无法胜任的，所以使用一个 StatefulWidget。而由于 AppBar 的样式和我们需要显示的效果图还是有差别的，所以这里我们不使用 Scaffold 提供的 AppBar 了。我们自定义一个 SearchBar，配合一个 ListView 来搭建基本的布局。这里面基本没有新鲜的东西，就简单贴一下代码：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/2a65878c91ef4795a80cde4b9100e7ac~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>SearchBar 由于是在 SearchPage 中使用的，所以就直接定义在 SearchPage 中了，代码也是先简单定义如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/e6ae11c406504b5f8f1e8386d60fc9ad~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="点击跳转到-SearchPage"><a href="#点击跳转到-SearchPage" class="headerlink" title="点击跳转到 SearchPage"></a>点击跳转到 SearchPage</h2><img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/f9239dbba4a8422a88b545ade852133e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在搜索 cell 里面实现点击方法，然后跳转到 SearchPage，显示效果如图：</p>
<div align=center>
<img src = '8天让iOS开发者上手Flutter之七/e5054ecb6ba147d7a3adc6f76e71bc47~tplv-k3u1fbpfcp-watermark.png'>
</div>

<h1 id="实现-SearchBar"><a href="#实现-SearchBar" class="headerlink" title="实现 SearchBar"></a>实现 SearchBar</h1><h2 id="SearchBar-的布局"><a href="#SearchBar-的布局" class="headerlink" title="SearchBar 的布局"></a>SearchBar 的布局</h2><p>SearchBar 的布局，最外层分为上下两个部分，上面的部分是系统状态栏的高度。下面的部分就是显示搜索条的高度。而搜索条的布局，使用 Row 分隔为左右两个部分，左侧包含放大镜，文本输入框和删除图片。右侧就是一个返回上级页面的取消。这里主要提一下 flutter 中的文本框，跟 iOS 中 UITextField 真的很不一样，UITextField 中左侧的图标，右侧的删除，都是封装在内部的。而在 flutter 中，文本框 TextField 真的就只有文本框，没有其他的东西，都需要自己添加。完整代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/0dbc3f3f2239405ca84199dc0fda9801~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210818_60.png">

<h2 id="SearchBar-事件处理"><a href="#SearchBar-事件处理" class="headerlink" title="SearchBar 事件处理"></a>SearchBar 事件处理</h2><h3 id="取消的处理"><a href="#取消的处理" class="headerlink" title="取消的处理"></a>取消的处理</h3><p>点击取消需要 pop 到上一个界面，给取消加一个 <code>GestureDetector</code> 实现 <code>onTap</code> 就好了。代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/386cd9fc654946959405e1090597a1ee~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210818_61.png">

<h3 id="清除按钮功能实现"><a href="#清除按钮功能实现" class="headerlink" title="清除按钮功能实现"></a>清除按钮功能实现</h3><p>未输入文本的时候，不显示清除按钮。有输入文本的时候，显示清除按钮。点击清除按钮，清空文本内容并隐藏清除按钮。</p>
<p>使用一个bool值 <code>_showClear</code> 控制清除按钮的显示隐藏。代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/9a5423cd5b0146b19169fbb6bbf12236~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在文本变化的时候，修改 <code>_showClear</code> 值并刷新状态。文本的变化在TextField的 <code>onChanged</code> 属性就可以监听到。代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/053efa2bbde9460f976cfe5e7ba63d83~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>最后就是清除按钮的点击功能，由于需要清空 TextField 的文本内容，需要使用到 <code>TextEditingController</code>,给 TextField 的 <code>controller</code> 属性赋值，然后通过 <code>TextEditingController</code> 对象清除文本内容。文本清除之后并不会自动调用系统的 <code>onChanged</code> 方法，自己手动调用一下就好了。代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/b08d5ad674544fd3b52cb4cd86366783~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="SearchBar-回调文本框的内容"><a href="#SearchBar-回调文本框的内容" class="headerlink" title="SearchBar 回调文本框的内容"></a>SearchBar 回调文本框的内容</h3><p>文本框的内容变化的时候，需要回调给 SearchBar 外部，这样我们才能在 SearchPage 页面进行搜索内容。使用一个回调作为参数就可以实现了。代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/762fd4c2b23444caa7f44d23dc3641d9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p><code>onChanged</code> 是一个闭包属性，在初始化 SearchBar 的时候传入，在 TextField 的文本变化的时候调用闭包，并将文本作为参数回传给 SearchBar 外部。因为将 <code>onChanged</code> 作为了必传参数，所以编译器自然会在用到了 SearchBar 的地方报错。很容易找到报错的地方，加个参数就好了。</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/6481817bd4544a138bbeaf10b3c80c54~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>SearchBar 相关的代码就算差不多完成了，其实可以将 SearchBar 单独作为一个文件独立出来。接下来就是处理 SearchPage 了</p>
<h1 id="实现-SearchPage"><a href="#实现-SearchPage" class="headerlink" title="实现 SearchPage"></a>实现 SearchPage</h1><p>搜索页面的搜索功能，往细了说，可以搜索很多内容，我们这里只是简单的搜索名字，只要名字包含输入的内容，就将搜索结果展示出来。由于这里对中文名进行搜索的时候，能匹配到的数据比较少，所以这里已经将网络请求返回的名字由中文改为英文名字了。前面展示中文名字的截图就不做修改了。</p>
<h2 id="SearchPage-的搜索功能"><a href="#SearchPage-的搜索功能" class="headerlink" title="SearchPage 的搜索功能"></a>SearchPage 的搜索功能</h2><h3 id="添加-datas-数据源"><a href="#添加-datas-数据源" class="headerlink" title="添加 datas 数据源"></a>添加 <code>datas</code> 数据源</h3><p>要实现 SearchPage 的搜索功能，那么它首先必须要有数据源，很明显它的数据源是从首页来的。先定义一个 <code>datas</code>,作为必传参数，然后通过外部层层传递过来。</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/700b1121913846efb7e15edd66ee4613~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p><code>datas</code> 定义好了以后，报红色错误的地方，就是需要传参数的地方，很方便，都不用我们自己去翻哪里需要加参数了。发现 SearchCell 里面需要传入数据源，同样的方式，在 SearchCell 里面定义 <code>datas</code>,然后在报错的地方处理。</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/15a0335618d648deb35dfa08cff589b9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>就这样子顺藤摸瓜，直到来到 chat_page 将数据源传入就完成了</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/9dd3a5666ded4f8393fed63621b903d1~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="SearchPage-自己的数据源"><a href="#SearchPage-自己的数据源" class="headerlink" title="SearchPage 自己的数据源"></a>SearchPage 自己的数据源</h3><p>SearchPage 需要展示搜索之后的结果，所以自己定义一个数组用来存放搜索的结果。并且暂时先使用 Text 做一个最简单的展示。代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/8e81c3d13e6547c4bc7bb8a5d021bac5~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="实现搜索功能并展示数据"><a href="#实现搜索功能并展示数据" class="headerlink" title="实现搜索功能并展示数据"></a>实现搜索功能并展示数据</h3><p>搜索的功能实现很简单，就是判断数据源里面的名字是否包含输入的文本，如果包含就全部添加并展示。<br>代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/9bd07dfcbf5247609d3b28d3780fec6c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>APP 上如图，我输入 son，显示结果：</p>
<div align=center>
<img src='8天让iOS开发者上手Flutter之七/3332ccab3c12452fb12016e1508f6d5a~tplv-k3u1fbpfcp-watermark.png'>
</div>

<h2 id="SearchPage-的搜索结果列表展示"><a href="#SearchPage-的搜索结果列表展示" class="headerlink" title="SearchPage 的搜索结果列表展示"></a>SearchPage 的搜索结果列表展示</h2><p>SearchPage 的搜索结果列表展示的数据样式，应该和首页是类似的。所以可以直接使用首页的布局。代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/3118496d7dd94eae9cb516dd92e86ef0~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="SearchPage-高亮显示搜到的结果"><a href="#SearchPage-高亮显示搜到的结果" class="headerlink" title="SearchPage 高亮显示搜到的结果"></a>SearchPage 高亮显示搜到的结果</h2><p>这里的思路是，高亮显示搜到的结果，那么普通的文本肯定是不行了，必须是富文本。如何找到搜索的关键字在文本中的位置呢，这个不用我们考虑了。flutter 中对字符串有一个分隔方法 <code>split</code>,这个方法跟 iOS 中的字符串的 <code>componentsSeparatedByString:</code> 方法类似，根据传入的参数来分隔字符串。这里贴一下 iOS 的代码：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/c991926b90ac4a6490d95ad1bc0889e2~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>（还是Xcode看着顺眼啊）我们将字符串 <code>abcaa</code> 以字符 <code>a</code> 分组，再将分组的结果拼接回原来的字符串。为什么要这么操作？因为重新拼接新字符串的时候，我们就可以处理富文本字符串了。现在回到 flutter 中来，flutter 中拼接的富文本的方式太方便了，RichText 花样拼接 TextSpan 这个我们在前面也讲过了。</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/7bd6ae46acf344e48435c1dfa80dc50f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p><code>_searchKey</code> 就是我们输入的文本，在 SearchPage 中声明属性，在 SearchBar 的回调中赋值就好了。</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/be6eb80c9ad24db5897308c568863416~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/6723d425c75249d488bc3b8d31f9e345~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>现在测试一下，输入 son，APP 显示如图：</p>
<div align=center>
<img src='8天让iOS开发者上手Flutter之七/20dad78f11364579aae756585e776407~tplv-k3u1fbpfcp-watermark.png'>
</div>

<h2 id="滚动列表叫回键盘"><a href="#滚动列表叫回键盘" class="headerlink" title="滚动列表叫回键盘"></a>滚动列表叫回键盘</h2><p>ListView 的滚动，我们在前面已经说过一次，需要将 ListView 包在 <code>NotificationListener</code> 里面。然后叫回键盘的代码 <code>FocusScope.of(context).requestFocus(FocusNode());</code> 这个记住就好了，代码如下：</p>
<img src="/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/d33048a50ec0451983defba0221a6547~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们的 flutter 仿微信 Demo 功能就差不多完了，还剩最后一篇就是介绍 flutter 和原生混合开发的一些东西。这个也是实际项目中应该经常会遇到的情况。其实写到这里会发现很多东西和原生都是相通的或者类似的。除了新的语言 Dart 不是很熟悉之外，其他很多地方比如很多属性的名字，颜色，闭包，都能够看到原生的影子。flutter 创造者们也不会闭门造车，都会去借鉴原生里面的东西。</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之二</title>
    <url>/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="Flutter布局"><a href="#Flutter布局" class="headerlink" title="Flutter布局"></a>Flutter布局</h1><h2 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h2><p>Container 类里有一个 alignment 属性，翻译过来应该叫对齐方式，这个属性用来控制 Container 的子控件相对于它自身的一个位置。在我们 iOS 开发中，我们知道坐标系的原点是在左上角。</p>
<p>而在 flutter 中，坐标系的原点在父控件的正中心，可以使用这个 alignment 属性来控制子控件在父控件中的位置，它有两个参数分别是 double 类型的 x,y。取值是 -1 到 1，</p>
<ul>
<li>当 (0, 0) 的时候表示子控件在父控件的正中心，当 (1, 0) 的时候，表示子控件位于 x 方向上的最右侧，y 方向上居中；</li>
<li>当 (-1, -1) 的时候，表示子控件位于父控件的左上角位置。有点类似于 CALayer 的 anchorPoint 属性。</li>
</ul>
<p>如图代码如下：</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/658c0a6e27534e0eaa7531960f6f83a1~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<div align=center>
<img src="8天让iOS开发者上手Flutter之二/3af95f906929441e9e113e235402ca11~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<h2 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h2><p>Row 表示水平布局，它有一个 children 属性，用来存放它的子控件。代码如下：</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/09c67fe367fc4a86889cbc07b8f12d85~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<div align=center>
<img src="8天让iOS开发者上手Flutter之二/c8dac668c50045eeb4b89237aa430f0c~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<p>其中 Icon 类是 flutter 提供的一个快速创建一些常用图标的类。如果想给每个 Icon 都加一个背景色，直接设置 Icon 的 color 是不行的，这样修改的是图标的颜色而不是背景色，给 Icon 包一层 Container 容器，然后再设置 Container 颜色这样就可以实现了。</p>
<p>最开始我们尝试了 alignment 属性的作用，当它是 (0，0) 的时候，Text 的位置默认是在屏幕中央的。为什么这里换成我们的 Row 之后，Row 的子控件位置不在屏幕中央呢？</p>
<h3 id="mainAxisAlignment"><a href="#mainAxisAlignment" class="headerlink" title="mainAxisAlignment"></a>mainAxisAlignment</h3><p>Row 和 Column 都有一个 mainAxisAlignment 属性，叫作主轴对齐方式，默认是 MainAxisAlignment.start 意思沿着主轴方向开始，Row 布局下就是从左至右，Column 布局下就是从上至下。<br></p>
<ul>
<li><code>MainAxisAlignment.spaceAround</code>:将剩下的空间平均分配<br></li>
<li><code>MainAxisAlignment.spaceBetween</code>:将剩下的空间分配到子控件之间<br></li>
<li><code>MainAxisAlignment.spaceEvenly</code>:等间距分配子控件</li>
</ul>
<h3 id="crossAxisAlignment"><a href="#crossAxisAlignment" class="headerlink" title="crossAxisAlignment"></a>crossAxisAlignment</h3><p>交叉轴对齐方式。start，end，center 这几种方式试一下很好理解，stretch 会将子控件拉伸。而 baseline 用的比较少,单独使用它会报错，需要和 Text 文本结合，还需要配合 <code>textBaseline</code> 属性一起使用。如下图所示，如果不设置 <code>CrossAxisAlignment.baseline</code> 和 <code>TextBaseline.alphabetic</code> 就会根据控件高度水平对齐，而如果设置了就会根据控件内文本的基线对齐。<br></p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/52e87b0a49674f1e85560f4c3a54df0f~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210713_177.png">

<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/dddb21324b744ad1a71de8a98862f0f5~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210713_178.png">

<h2 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h2><p>这个和 Row 是对应的，Row 是水平布局，这个 Column 是垂直布局</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.green,</span><br><span class="line">      alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果如图：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之二/f43e891ecf234671ad18336db379a204~tplv-k3u1fbpfcp-watermark.png"/>
</div>


<h3 id="mainAxisAlignment-1"><a href="#mainAxisAlignment-1" class="headerlink" title="mainAxisAlignment"></a>mainAxisAlignment</h3><p>这个跟 Row 类似</p>
<h3 id="crossAxisAlignment-1"><a href="#crossAxisAlignment-1" class="headerlink" title="crossAxisAlignment"></a>crossAxisAlignment</h3><p>这个跟 Row 类似</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>这个是用在 Z 轴上的布局的，row 是 X 轴，column 是 Y 轴。children 数组第一个放在最底部，最后一个放在上面，离用户最近的地方。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.green,</span><br><span class="line">      alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">      child: Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>APP显示效果：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之二/29eabf4666e94592b92fe8f7599821df~tplv-k3u1fbpfcp-watermark.png"/>
</div> 

<h3 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h3><p>Stack 里有一个 alignment 属性，它用来控制所有子控件相对于最大那个子控件的位置</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StackDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      alignment: Alignment.bottomRight,</span><br><span class="line">      children: [</span><br><span class="line">        Container(</span><br><span class="line">          child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">          color: Colors.red,</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">          color: Colors.yellow,</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align=center>
<img src="8天让iOS开发者上手Flutter之二/3ec51da73a554b3c877297e6927d434a~tplv-k3u1fbpfcp-watermark.png"/>
</div> 

<h3 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h3><p>Stack 里配合 Positioned 类使用的话，跟我们 iOS 的约束有点类似了，可以设置上，左间距之类的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StackDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: [</span><br><span class="line">        Positioned(</span><br><span class="line">          child: Container(</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.add,</span><br><span class="line">              size: <span class="number">180</span>,</span><br><span class="line">            ),</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Positioned(</span><br><span class="line">          child: Container(</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.ac_unit,</span><br><span class="line">              size: <span class="number">120</span>,</span><br><span class="line">            ),</span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Positioned(</span><br><span class="line">          top: <span class="number">20</span>,</span><br><span class="line">          left: <span class="number">20</span>,</span><br><span class="line">          right: <span class="number">20</span>,</span><br><span class="line">          child: Container(</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.access_alarm,</span><br><span class="line">              size: <span class="number">60</span>,</span><br><span class="line">            ),</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align=center>
<img src="8天让iOS开发者上手Flutter之二/756c171599864736be922041582a7a50~tplv-k3u1fbpfcp-watermark.png"/>
</div> 

<p>可以看到最小的蓝色视图的上左右均设置了 20 的间距，是不是熟悉的约束味道。。。</p>
<h2 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h2><p>Expanded 是一个类似 Container 的常用的布局容器，它用来填充布局，使用了填充布局在主轴方向上是不会有间隔的,所以 Expanded 用在 Row 里面的时候，子控件的宽度设置就没有意义了，而在 Column 里面使用的使用，子控件的高度设置就没有意义了。这里以 Column 为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.green,</span><br><span class="line">      alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">              child: Container(</span><br><span class="line">                child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">                color: Colors.red,</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">              child: Container(</span><br><span class="line">                child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">                color: Colors.yellow,</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">              child: Container(</span><br><span class="line">                child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align=center>
<img src="8天让iOS开发者上手Flutter之二/c61d9a86201943d3a6e31d7f8afc67d4~tplv-k3u1fbpfcp-watermark.png"/>
</div> 

<h2 id="AspectRatio"><a href="#AspectRatio" class="headerlink" title="AspectRatio"></a>AspectRatio</h2><p>AspectRatio 是一个容器类，它有一个属性 aspectRatio 表示宽高比。如果指定了宽度，根据这个 aspectRatio 可以自动算出高度；如果指定了高度，根据 aspectRatio 可以自动算出宽度。如下面代码指定了父视图高度为 100，aspectRatio 宽高比为 2，子视图宽度就是 200，再把父视图撑起来也是 200。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">        color: Colors.green,</span><br><span class="line">        alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        child: Container(</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">          child: AspectRatio(</span><br><span class="line">            aspectRatio: <span class="number">2</span>,</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.add,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align=center>
<img src="8天让iOS开发者上手Flutter之二/b7c386921f1644af91bc5d24da5766c5~tplv-k3u1fbpfcp-watermark.png"/>
</div> 

<h1 id="Flutter状态管理"><a href="#Flutter状态管理" class="headerlink" title="Flutter状态管理"></a>Flutter状态管理</h1><p>之前介绍的这么多类都是无状态的，意思是显示之后没办法更新 UI 的，如果想要实时更新 UI 的话，就不能继承无状态的类了。我们先来看一个例子：明明 count 变化了，但是界面显示没有变化</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/95069ac3145a4002ac097296d7fe4a5d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>记得修改 APP 的 home 视图</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/5a40edcaae6b4c5f87d41a0f3800d357~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后点击屏幕右下角的加号按钮，可以发现明明控制台打印了 count 的值已经发生了变化，但是界面显示依然是 0</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/d729f11560cf44bf82dbbbd5562f7411~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>下面我们解决这个问题，将 StateManagerDemo 继承改为 StatefulWidget，实现 createState 方法返回一个自定义的 State 对象，自定义的 State 对象里面实现 build 方法。还需要注意在按钮的点击方法里调用一下 setState 方法。这样每次点击加号按钮就能实时更新 UI 了。改造完之后如下图所示：</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/778099f068b949c7b89886ff80dc21bc~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">


<h1 id="项目搭建之底部TabBar"><a href="#项目搭建之底部TabBar" class="headerlink" title="项目搭建之底部TabBar"></a>项目搭建之底部TabBar</h1><p>到目前为止，我们对 flutter 的一些基础知识就算是介绍的差不多了。接下来我们开始做一个简单的仿微信 APP。我们应该都有经验，理论的知识学得再多，不动手开始敲代码，不在项目中运用，是很难真正掌握一门知识的。</p>
<p>新建一个 flutter 工程，命名 wechat_demo：</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/800ac6c2c4414768bcdba85dd953f749~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>删掉多余的代码，可以全部重新自己写：</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/063a4f181c9246b08eb8232606db9132~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>创建底部的 TabBar 和 item,默认的 type 是白色的，显示效果很难看所以改为 fixed，还可以设置 fixedColor：</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/b48d2047edc94f0a834233853b73602d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<div align=center>
<img src="8天让iOS开发者上手Flutter之二/32edbe92fef5448abadd95e52c6078f4~tplv-k3u1fbpfcp-watermark.png"/>
</div> 

<p>这样底部的 TabBar 就显示出来了，会发现点击没有效果，对比 iOS 会发现这块地方还是 iOS 提供的 UITabBarController 封装的更舒服，每个平台都各有优劣吧。</p>
<p>BottomNavigationBar 有一个属性 currentIndex 即代表了当前选中的下标。我们可以通过设置它的值来控制哪个按钮被选中。既然需要改变 UI 了，说明我们需要将 StatelessWidget 改为 StatefulWidget 了。还有一个参数 onTap 是用来回调点击事件的。实现点击事件，切换 currentIndex，重新 setState 就可以实现，点击切换了。我们将 bottomNavigationBar 相关代码放到一个新的文件 rootPage 中。代码如下：</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/535f9cbc78574cbeb866215f6e590f18~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>记得修改 main.dart 文件中</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/0174709795614365a4438640b1b14b31~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这样就实现了 APP 的底部 TabBar 的展示，点击功能。点击每个 item 的时候，会发现 flutter 的 bottomNavigationBar 还自带了动画效果…</p>
<p>我们知道 Scaffold 还有一个 body 的属性，表示展示在屏幕上的内容。我们每个 item 对应的界面都需要一个 AppBar，那么也许意味着，body 属性还需要一个 Scaffold 来展示我们的每个 item 对应的内容。</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/ee3b980bed8642e6a1480ea509eab7eb~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>可以看到微信首页就已经大概出来了，但是点击的时候只会显示这个微信页面，怎么实现切换不同的页面呢，肯定需要一个数组，来存放对应的每个页面了。</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/f299d1dcc70f4a5d8205a9caf62afb72~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后 body 里，根据我们的 _currentIndex 返回对应的 body</p>
<img src="/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/98747470b16143d3b733754def9e7219~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这样点击每个 item 都会跳转到对应的界面了，APP 的主框架的搭建好了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天主要讲了 flutter 的三大布局类 Row，Column，Stack 以及他们的一些属性。然后是有状态的 Widget 和无状态的 Widget，最后搭建了一下我们要做的仿微信 APP 的底部 bottomNavigationBar 和切换页面功能</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之六</title>
    <url>/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/</url>
    <content><![CDATA[<p>发现了一个宝藏网址，这里讲解的 <a href="https://book.flutterchina.club/">flutter实战</a> 比我写的靠谱多了。</p>
<h1 id="准备网络数据"><a href="#准备网络数据" class="headerlink" title="准备网络数据"></a>准备网络数据</h1><p>这一步不是很重要，提供一些假数据而已，不是重点嫌麻烦的可以跳过。</p>
<p>先介绍一个网址：<a href="http://rap2.taobao.org/account/login">http://rap2.taobao.org/account/login</a> 这个网址用来搭建我们需要的网络数据，注册账号非常简单，这里就不多说了。</p>
<p>注册完成之后，新建一个仓库，简简单单取个名字就够了：</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/4a3c12fb3b244575ac6b794168d93675~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210808_10.png">

<p>之后点击进入仓库，可以看到下图：</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/dfd2860cb5c64f4b947d45551aba9d93~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210808_11.png">

<p>会默认生成以一个示例接口，可以看一看示例接口的生成规则。看不懂也没关系，我们直接直接上手自己新建一个接口，如图所示：</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/0af92d6af9b14eae865b69d5beb874c4~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210808_12.png">

<p>点击右上角的编辑按钮进入编辑模式，新建一个响应 chatlist，类型为 Array。然后生成 chatlist 的数据，imageUrl 表示每条聊天数据的用户头像。其中用户头像的初始值里面有一段 @natural(20,99)，这个是 Mock.js 代码。这里是相关介绍 <a href="http://mockjs.com/">http://mockjs.com/</a></p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/4b21769272134c4ea316f9289a9d945d~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210808_14.png">

<p>每条聊天数据，除了 imageUrl 还需要有用户名 name 和消息的内容 message。@cname 用来生成随机的中文名，@cparagraph 用来生成随机的中文段落来表示聊天内容。我们这里只是简单的构造一下这个聊天列表所需要的数据，真正的聊天列表的数据肯定是不会这么简单的。。。</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/c1a42755454d455d9d2be30c80fd6e62~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210808_15.png">

<p>编辑的差不多的时候，记得点击保存,保存之后点击红圈中的图标就可以获取到数据</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/3a1db20c16414845bc45ce901e244a66~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="聊天页面导航条"><a href="#聊天页面导航条" class="headerlink" title="聊天页面导航条"></a>聊天页面导航条</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>默认展示页面改为 <code>_currentIndex</code> 改为 0,新建 chat 目录，将相关文件放在这里。</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/0213b262930d4066b6f26e34993011cc~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210808_17.png">

<h2 id="添加加号按钮"><a href="#添加加号按钮" class="headerlink" title="添加加号按钮"></a>添加加号按钮</h2><p>加号按钮这个东西，我们之前已经添加过类似的了，appBar 的 actions 就是我们需要添加代码的地方。</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/336b5de10dc2451bbb989516bd66049c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>如果我们按照这个思路写下去的话，就需要自己再去实现一个弹出菜单的类。其实 flutter 提供了我们一些现成的类可以做到类似的效果。</p>
<h2 id="PopupMenuButton"><a href="#PopupMenuButton" class="headerlink" title="PopupMenuButton"></a><code>PopupMenuButton</code></h2><p><code>PopupMenuButton</code> 类用来弹出一个菜单，必传参数为 <code>itemBuilder</code>，用来实现它需要展示的内容。<code>PopupMenuItem</code> 就是用来展示内容的类。这里有一个细节说一下，<code>PopupMenuButton</code> 有一个 <code>onSelected</code> 属性，这个属性是个闭包，意思是选中某个 <code>PopupMenuItem</code> 的时候，会调用这个闭包。但是有一个前提就是每个 <code>PopupMenuItem</code> 的 <code>value</code> 必须不为 null 的时候，才会执行 <code>onSelected</code> 闭包，我在这里卡了半天，网上找了半天资料也没有明确讲到这里。其他就没什么好讲的了，都比较简单。</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/4b9d82deec2e46e881aa084e25d9bb7d~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210812_19.png">

<p>其中 <code>_buildMenuItem</code> 的实现如下，注意 <code>value</code> 要赋值就好了，不为空就行，不然 <code>PopupMenuButton</code> 的 <code>onSelected</code> 不执行：</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/9f6f5da2ff794264afbf256c95e307a6~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>还有一个小细节，如何设置 <code>PopupMenuButton</code> 的颜色，可以直接设置它的颜色</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/0548c31d2ba248e9b8bdeb375031c487~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>还可以设置APP的主题的 <code>cardColor</code>，不过这个优先级没有直接设置 <code>PopupMenuButton</code> 颜色高。</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/9c19742492944488ba13249b31db685b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="请求网络数据"><a href="#请求网络数据" class="headerlink" title="请求网络数据"></a>请求网络数据</h1><h2 id="https-pub-flutter-io-cn"><a href="#https-pub-flutter-io-cn" class="headerlink" title="https://pub.flutter-io.cn/"></a><a href="https://pub.flutter-io.cn/">https://pub.flutter-io.cn/</a></h2><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/04224929590b47528f1a1ea05dbe8ab9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这个网站可以搜索 flutter 使用的包 packages。我们使用 http 这个包来请求我们的网络数据。这个包是 flutter 官方提供的。实际项目开发的时候可能并不会使用 http 这个包，大部分是使用 dio 来请求网络数据。这里只介绍官方的 http 包如何使用。</p>
<h2 id="导入http包"><a href="#导入http包" class="headerlink" title="导入http包"></a>导入http包</h2><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/32044f0faafd4673bc0a0e5cc22ae858~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/1dfb3991238d4f77927c2728ef210d6e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>粘贴完成之后需要更新一下，就是获取一下包对应的代码。可以通过上方的 <code>Pub get</code>,也可以在终端中输入 <code>flutter packages get</code> </p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/dfeb775cd3ae4e96ba22440e706d33d3~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>命令执行完之后，就可以使用这个包了。</p>
<h2 id="导入-http-头文件并取别名"><a href="#导入-http-头文件并取别名" class="headerlink" title="导入 http 头文件并取别名"></a>导入 http 头文件并取别名</h2><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/9539435380ef4dd38aa8af4eaa119b38~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/df206f11e0b1474e8086c80ff222d5cf~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>请求的发送写在 <code>initState</code> 里面。<code>getData()</code> 后面跟了一个 async 表示的是异步执行。async 需要搭配 await 使用，await 后面跟着的是耗时的代码。所以上面的程序会先打印来了，然后再输出请求的状态码；</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/a9e9b0f789c4471492caccb982daa03d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>点击其他的页面，再次回到当前页面会发现 initState 方法重新走了一遍，这是因为我们还没有保存住状态，后面会讲到如何保持 Widget 的状态。</p>
<h2 id="处理返回的数据"><a href="#处理返回的数据" class="headerlink" title="处理返回的数据"></a>处理返回的数据</h2><p>首先介绍一下，在 flutter 中如何将请求返回的 JSON 数据转为 Map，在我们 iOS 开发中是转为字典，而 flutter 中没有字典这个类型，对应的类型是 Map。以及如果将 Map 转为 JSON。在 iOS 中我们知道会使用一个 <code>NSJSONSerialization</code> 的类用来处理JSON数据。同样的，在 flutter 中也会有一个专门的类 <code>JsonCodec</code> 来处理。</p>
<h3 id="JSON-和-Map-互相转"><a href="#JSON-和-Map-互相转" class="headerlink" title="JSON 和 Map 互相转"></a>JSON 和 Map 互相转</h3><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/cd897b4dbfd54af1941972b4360d3159~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>其中的 json 就是 <code>JsonCodec</code> 的实例。需要导入 <code>&#39;dart:convert&#39;</code> 头文件。flutter 中还可以通过 <code>is</code> 来判断是不是某个类型。</p>
<h3 id="新建聊天模型"><a href="#新建聊天模型" class="headerlink" title="新建聊天模型"></a>新建聊天模型</h3><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/3017a15c3cbe4d3ab67d82bafdb385f2~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png"> 

<p>除了红框内的方法之外，其他没什么新鲜事物。红框内的方法应该说是一个工厂方法，是设计模式的一种，用来初始化对象的。除了默认的初始化方法，还可以使用这个工厂方法来实例化一个 Chat 对象。模型建立好了之后就可以处理响应的数据了</p>
<h3 id="处理响应的数据"><a href="#处理响应的数据" class="headerlink" title="处理响应的数据"></a>处理响应的数据</h3><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/5bf33bb810d64e51873ad84fb15bf76d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里用到了 Future，关于 Future 的讲解可以看官方文档 <a href="https://dart.cn/tutorials/language/futures">https://dart.cn/tutorials/language/futures</a></p>
<h1 id="使用-FutureBuilder-显示界面"><a href="#使用-FutureBuilder-显示界面" class="headerlink" title="使用 FutureBuilder 显示界面"></a>使用 FutureBuilder 显示界面</h1><p>很多时候我们会依赖一些异步数据来动态更新 UI，比如在打开一个页面时我们需要先从互联网上获取数据，在获取数据的过程中我们显示一个加载框，等获取到数据时我们再渲染页面；当然，通过 StatefulWidget 我们完全可以实现上述这些功能。</p>
<p>但由于在实际开发中依赖异步数据更新UI的这种场景非常常见，因此 Flutter 专门提供了 <code>FutureBuilder</code> 来快速实现这种功能。<code>FutureBuilder</code> 会依赖一个 <code>future</code>，它会根据所依赖的 <code>future</code> 的状态来动态构建自身。这个 <code>future</code> 我们刚刚已经准备好了。关于 <code>FutureBuilder</code> 的介绍 <a href="https://book.flutterchina.club/chapter7/futurebuilder_and_streambuilder.html#_7-5-1-futurebuilder">这篇文章</a> 讲解的很详细。<br>最后完整代码如下：</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/320e21f3548744db88a59b289094e80b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="不使用-FutureBuilder-的方式"><a href="#不使用-FutureBuilder-的方式" class="headerlink" title="不使用 FutureBuilder 的方式"></a>不使用 FutureBuilder 的方式</h1><p>刚刚说了，我们可以使用 FutureBuilder 来快速实现展示异步网络数据，也可以自己实现，现在我们自己实现一下。使用一个私有变量 _chatList 记录请求下来的数据，再根据 _chatList 的值来展示不同的页面。代码如下：</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/57600afd73aa4a3c8178bc07be97a375~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/22da31c383294f85ae5af4ad182b2ab1~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>因为 getData 的返回值是 Future 的原因，getData() 后面可以跟 <code>then</code> 方法，还可以跟错误捕获 <code>catchError</code>,完成时的回调 <code>whenComplete</code>，超时设置 <code>timeOut</code> 等等，这种写法挺有意思，一路点下去就完了…</p>
<h2 id="实现超时取消刷新功能"><a href="#实现超时取消刷新功能" class="headerlink" title="实现超时取消刷新功能"></a>实现超时取消刷新功能</h2><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/b865f3d6e0434e74a1e1a3324da786f4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在每次请求的时候，重置 <code>_cancelConnect</code> 的值。</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/07c8ba9d07b446f9a6684241fc5f31bc~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="保持-Widget-的状态"><a href="#保持-Widget-的状态" class="headerlink" title="保持 Widget 的状态"></a>保持 Widget 的状态</h1><p>我们来回点击通讯录页面和聊天页面，会发现每次点击进入当前的页面，都会重新的载入，<code>initState()</code> 会被重新调用。将通讯录页面滑动到底部，再次点击进入会发现又默认回到了顶部。为什么会出现这样的问题。正是因为我们的Widget的状态没有保持，每次展示都重新创建了。</p>
<p>Dart 语言中有一个 Mixins 的概念：<a href="https://dart.cn/samples#mixins">官方的解释是这样</a>，可以给类 A Mixins 一个 B，那么 A 就拥有了 B 的属性和方法。有点像 OC 的类扩展的意思。保持 Widget 的状态就需要用到这个语言特性。一共有三个步骤：</p>
<ol>
<li>Mixins 类<code>AutomaticKeepAliveClientMixin</code></li>
<li>重写<code>wantKeepAlive</code>方法</li>
<li>调用父类Builder方法</li>
</ol>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/d3d29b34ea3746b9a9cc7ec0ca19a9d9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>同样把通讯录页面也实现上面的步骤。然后再次来回点击发现还是没有保持住状态？？？这里有一个最大的问题就是我们的根 Widget 都没有保持住状态，那还谈什么保持子 Widget 的状态呢。。。</p>
<h2 id="使用-PageView"><a href="#使用-PageView" class="headerlink" title="使用 PageView"></a>使用 PageView</h2><p>来到 rootPage.dart 文件，我们会看到 body 里面直接取了数组的某个元素作为根 Widget 展示。这样是无法保持住状态的，使用 PageView 才可以保持住状态。</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/275398750bb34835b5fa1a593e30bbc4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>使用 PageView，代码如下：</p>
<img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/adc5cc5e8c1046909d27097107c9f590~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>点击跳转到其他页面就可以直接通过 _pageController 来完成。使用了 PageView 之后会发现，不同的页面之间可以直接通过手势左右滑到就能切换了。这样的效果我们一般是不需要的，可以设置直接关闭。如果需要的话，在滑动的方法里面重新设置底部导航条的正确位置也是没有问题的。</p>
<h3 id="使用滑动切换，解决-bug"><a href="#使用滑动切换，解决-bug" class="headerlink" title="使用滑动切换，解决 bug"></a>使用滑动切换，解决 bug</h3><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/44cb9bc186724397b471136abbcc44ea~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="禁用滑动切换"><a href="#禁用滑动切换" class="headerlink" title="禁用滑动切换"></a>禁用滑动切换</h3><img src="/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/e9d533514d734781bd6a13e6c43e738a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">


]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之五</title>
    <url>/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/</url>
    <content><![CDATA[<p>上篇文章，我们已经完成了通讯录的列表。这篇文章介绍完成通讯录右侧的索引条的功能。</p>
<h1 id="显示索引条"><a href="#显示索引条" class="headerlink" title="显示索引条"></a>显示索引条</h1><p>之前我们已经做过了我的页面的布局，我的页面上有一个列表和一个拍照按钮，和我们今天要实现的索引条布局十分类似。我的页面的布局如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/81053ec975144322af3bc1ef5f9e08e4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>通讯录界面的布局，和我的页面的布局都是使用一个 Stack 包含列表和其他子视图来实现。索引条是紧贴屏幕右侧，然后里面的子视图是由上至下的。所以自然的会想到使用一个 Positioned 包含 Column 来实现。Positioned 和 Stack 的组合我们之前讲过，这两个组合起来使用，就和我们 iOS 的约束布局类似，可以设置上左宽高等等。Column 就更不用多说，我们已经使用过很多次了。所以代码如下图所示：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/3b62754a2a31422a9416c79e94759829~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<div align=center>
<img src="8天让iOS开发者上手Flutter之五/be45a58d597a4a35b0d5ec97d96c445f~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<p>然后优化一下索引条的位置，高度我们设置为屏幕高度的一半，那么上下的间距就不能设置为 0 了，设置距离上间距为屏幕的 1&#x2F;8 看起来比较合适。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/d72de44cc3ed45c4b43280c52b1a59ee~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<div align=center>
<img src="8天让iOS开发者上手Flutter之五/7351193b625b4e5195471735a66581fa~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<h1 id="抽取-IndexBar"><a href="#抽取-IndexBar" class="headerlink" title="抽取 IndexBar"></a>抽取 IndexBar</h1><p>写到这里我们会发现，这个索引条还有很多的功能需要我们来实现，还是有点复杂的，如果代码都写在 friends_page.dart 里会有点冗余，我们完全可以将这个索引条作为一个独立的 Widget 来实现。新建 index_bar.dart 文件，代码如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/fe9068395cd1451fa340e6dace011a17~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">


<h1 id="实现-IndexBar-的点击切换状态"><a href="#实现-IndexBar-的点击切换状态" class="headerlink" title="实现 IndexBar 的点击切换状态"></a>实现 IndexBar 的点击切换状态</h1><p>当没有触摸到 IndexBar 的时候，默认是不展示背景色的，文字也是黑色的。当我们开始点击 IndexBar 的时候，显示出背景色，然后文字也变成了白色。</p>
<p>实现这个功能，主要是要对 <code>GestureDetector</code> 的两个方法有所了解。<code>onVerticalDragDown</code> 方法会在手指触摸 IndexBar 的时候就会被调用，<code>onVerticalDragEnd</code> 会在手指松开屏幕的时候调用。利用这两个方法就可以实现需求。代码如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/133c4a566110476b8405e347c313840d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>因为要对文字的颜色进行修改，所以初始化 Text 的时候，就需要使用变量 _textColor;</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/beaa4c3ca6ee489892a049625fe25a99~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="获取当前选中的下标"><a href="#获取当前选中的下标" class="headerlink" title="获取当前选中的下标"></a>获取当前选中的下标</h1><p>同样是对 <code>GestureDetector</code> 的一个手势方法的使用，<code>onVerticalDragUpdate</code> 这个方法的调用时机，在手指移动的时候会不停的调用这个方法。这个方法有一个 <code>DragUpdateDetails</code> 参数，它包含了手指所在的坐标信息。不过是相对于整个屏幕的坐标，可以将它转化为相对于 IndexBar 的坐标，然后通过计算可以得到我们当前选中的是哪个下标。代码如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/c1faac2e10e9496396883d1cba5a80b8~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>方法中的 ~&#x2F; 是 flutter 特有的运算符，意思是除后取整。而 clamp() 是对边界情况的处理，意思调用该函数的结果在它的两个参数之间。</p>
<h1 id="回调选中的下标"><a href="#回调选中的下标" class="headerlink" title="回调选中的下标"></a>回调选中的下标</h1><p>这里的回调，和 OC 里面的 block，Swift 里面的闭包都是一个意思。flutter 里面带有下划线的变量是私有的，外部无法访问的。所以对外暴露的参数，不能写在 <code>_IndexBarState</code> 类里面，需要写在 IndexBar 类里面。声明一个闭包(或者叫 block)属性,作为必传参数在初始化的时候传入。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/55fdb39036574be89074b99011841ad8~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这样，在 <code>friends_page.dart</code> 文件中初始化 <code>IndexBar</code> 的时候，就需要传入一个闭包。然后 <code>IndexBar</code> 内部在 <code>onVerticalDragUpdate</code> 的时候，调用这个闭包，就可以将当前选中的下标回调给外部了。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/922919210c40483a945f4d0944f05ce0~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/634b70d14d9c4b81b022321f39ed69cb~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这个时候，会发现一个小问题，就是点击 IndexBar 的时候，回调没有执行，只有在点击并手指挪动的时候才会执行。所以需要在 <code>onVerticalDragDown</code> 方法里面也调用一次闭包。这时候如果直接将 <code>onVerticalDragUpdate</code> 方法里面的代码复制到 <code>onVerticalDragDown</code> 方法里面确实没有问题，但是会明显的看到重复的代码太多了。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/ae4eaba1a6884716969cfe2105ad5033~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>所以可以抽取一个方法，将重复的代码放到一块。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/f935783fe0b24caab0e4d75cde2f5f05~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后调用的时候就简单多了。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/e1f72d6a90154eb38166c935be8e34dd~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="优化回调执行的频率"><a href="#优化回调执行的频率" class="headerlink" title="优化回调执行的频率"></a>优化回调执行的频率</h1><p>已经成功的实现了回调，但是从打印的结果来看，会发现同样一个下标会被回调许多次。这样我们滚动好友列表的时候会造成不必要的性能消耗。明明只需要滚动一次，结果却滚动了无数次到同一个位置。所以这里我们需要优化一下，一个很自然的想法就是记录一个 <code>_currentIndexLetter</code>，每次执行回调的时候，判断回调的首字母是否和 <code>_currentIndexLetter</code> 是否不同，如果是一样的就没有必要回调了，只有不同的时候，才执行回调。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/eb0ec5918762440885e3bc19d5023c29~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>代码如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/a6d2588d71ee4c8680b4bc2116ea8e61~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/493df27362e642b49c63fcad4be40d12~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这样回调的频率就正常了。</p>
<h1 id="滚动好友列表-ListView"><a href="#滚动好友列表-ListView" class="headerlink" title="滚动好友列表 ListView"></a>滚动好友列表 ListView</h1><p>可滚动的 widget 都有一个 controller 属性，用于控制滚动条的行为。controller 属性是一个 <code>ScrollController</code> 对象。可以使用它来实现指定滚动到某个位置，实现回到顶部等功能。</p>
<p>滚动好友列表需要一个新的对象 <code>ScrollController</code> 实例，将它设置给 ListView 的 <code>controller</code> 属性，然后就可以通过使用 <code>ScrollController</code> 实例来操作 ListView 的滚动。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/d6867385dc2d4dda98559f16f69f40a2~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/87bb89f0fc6d41ac9bfdc63a78aaebce~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里暂时先将滚动的偏移设置为固定值 250，试试看效果。可以看到当我们点击 IndexBar 的时候，ListView 就会滚动到偏移为 250 的地方。接下来就是处理滚动的实际偏移值了。</p>
<p>滚动的实际偏移，是根据我们的数据源来计算的。因为我们的 cell 的高度是确定的，不显示组头的 cell 高度是 54，有组头的 cell 高度是 54 + 30 &#x3D; 84。使用首字母作为 key，计算出对应的偏移为 offset，然后使用 Map(类似 iOS 中字典)记录下来。由于第一个是不是字母，而是搜索符号，而它对应的偏移也是固定的 0。所以可以在初始化 Map 的时候就指定好。而其他的高度我们在 initState 方法中计算。代码如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/a1486026da394231ae187a6eb56f462f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>有了这个 Map 之后，我们在 IndexBar 的回调方法中，就可以根据 IndexBar 回调给我们的首字母得到对应的偏移值了。代码如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/1a12df0544684482ad25772040aa4c27~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>到这里，我们的 IndexBar 基本上就实现了滚动 ListView 的功能。但是滚动几次之后就会发现一个小问题。。。滚动到底部的几个组头的时候，会出现 ListView 先将组头滚动到指定位置，然后又滚回底部的情况。原因很好理解，后面的组头内容不够显示一整个屏幕了。所以我们这里需要做下处理。这里主要是对 ListView 的滚动的监听，如果是在 iOS 中我们会想去获取滚动视图的 contentSize 然后减去 UITableView 的高度，就是 UITableView 的最大的滚动范围。而在 Flutter 中，这些都不需要我们计算了。</p>
<p>如果需要获取到 ListView 的一些滚动相关的信息，可以将它包裹在 <code>NotificationListener</code> 里面，它有一个 <code>onNotification</code> 属性，是一个闭包，可以回调给我们一些滚动的相关信息。包含在闭包参数 <code>ScrollNotification note</code> 里面。准确来讲滚动相关的信息包含在 <code>ScrollNotification</code> 的属性 <code>metrics</code> 里面。它包含当前滚动偏移值，能滚动的最大范围(这就是我们 iOS 中 contentSize 的高减去 UITableView 的高)等等信息。完整代码如下：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/150c3f3be83546c1b47a17038928298e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>将 <code>_maxScrollExtent</code> 定义为一个属性就好了。需要注意的是并不能给初始值为 0，否则没有滚动 ListView 之前，使用 IndexBar 就无法滚动 ListView 了。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/f77a46cc161b4f6297011476a258d27a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>至此，IndexBar 滚动 ListView 的功能就实现了。</p>
<h1 id="显示指示器"><a href="#显示指示器" class="headerlink" title="显示指示器"></a>显示指示器</h1><p>终于来到了最后一步，显示我们 IndexBar 的指示器。首先考虑的就是布局。最初的 IndexBar 只有右侧的下标一列。现在我们左侧需要一块容器用来显示我们的指示器，所以 IndexBar 的根视图应该考虑改为 Row。指示器背景的不规则图形可以使用一张图片展示，图片已经准备好了。中间的文字，使用 Text 就够了。先看下大概布局代码：</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/a2c4ca445a8a4024a1b85f47e888bd1d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<div align=center>
<img src="8天让iOS开发者上手Flutter之五/83d6f7a7ffeb4010bd9f134a42b4c358~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<p>如果觉得位置不是很合适，可以修改一下各自的宽度。然后是对指示器的显示与隐藏做控制，指示器的显示与隐藏的控制，应该说跟背景色的显示隐藏是类似的。都是在手势的那两个方法里面实现控制。使用一个 bool 变量来控制指示器的显示与隐藏，在手势的触摸方法和离开方法里面操作这个 bool 变量，然后 setState() 就可以实现了指示器的显示与隐藏了。</p>
<p>然后是关于指示器的显示文本的。这个文本就是我们的 <code>_currentIndexLetter</code>，直接使用就好了。最后是关于如何控制整个 IndexBar 的上下位移的。通过对 Alignment 的使用，发现可以控制 IndexBar 的上下位移。通过不断的修改 Alignment 的 y 值会找到一个合适的 y 值指向第一个放大镜，那么 -y 就指向最后一个字母 Z。我这里试了几次发现 y&#x3D;-1.13 的时候，指示器刚刚好指向第一个放大镜的位置。那么现在的问题就是将 1.13 * 2 &#x3D; 2.26 分成<code>_index_words.length - 1</code>份，然后根据选择的下标，取得对应的Alignment 的 y 值。当我们选择第一个的时候下标为 0，y 值应该为 -1.13,当我们选择最后一个的时候下标为 <code>_index_words.length - 1</code>,y 值应该为 1.13。根据这些信息就可以找到计算 y 值的公式。最终的代码如下：<br></p>
<p>新增两个变量<code>_showIndicator</code>和<code>_indicatorAlignmentY</code>。</p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/353987e4193a4460984edca74d16588b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>使用这两个变量还有<code>_currentIndexLetter</code></p>
<img src="/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/6fd8c7c981f64b62b76c35b4592ac324~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>到这里，我们就终于实现了通讯录的 IndexBar 的封装。下一节会介绍一些网络请求了…</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之五/ca2cca992d764871abe3a7e8163c2d85~tplv-k3u1fbpfcp-watermark.png"/>
</div>


]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之八</title>
    <url>/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/</url>
    <content><![CDATA[<h1 id="介绍四种-Flutter-Project"><a href="#介绍四种-Flutter-Project" class="headerlink" title="介绍四种 Flutter Project"></a>介绍四种 Flutter Project</h1><p>先介绍一下这四个的差别和使用的场景。</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/4c14a47588414f198ca94d7fb4799997~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="Flutter-App"><a href="#Flutter-App" class="headerlink" title="Flutter App"></a>Flutter App</h2><p>如果是想要使用 flutter 开发一个新的项目，那么就选择 Flutter App。就像我们之前的 <code>wechat_demo</code></p>
<h2 id="Flutter-Module"><a href="#Flutter-Module" class="headerlink" title="Flutter Module"></a>Flutter Module</h2><p>但是很多时候我们目前手上的原生 APP 可能会很庞大，不是随便就可以重新使用 flutter 重新再写一遍的。但是又想在现有的 APP 中体验一下 flutter，那么就选择 Flutter Module</p>
<h2 id="Flutter-Package"><a href="#Flutter-Package" class="headerlink" title="Flutter Package"></a>Flutter Package</h2><p>Flutter 支持使用其他开发者向 Flutter 和 Dart 生态系统贡献的共享 package(类似于 iOS 中的第三方库吧，AFNetworking，YYKit等等…)，这意味着你可以快速构建应用而不是一切从零开始。</p>
<p>Package 最低要求是包含一个 <code>pubspec.yaml</code> 文件。此外，一个 package 可以包含依赖关系 (在 <code>pubspec.yaml</code> 文件里声明)、 Dart 库、应用、资源、测试、图片和例子等。 pub.dev 上列出了很多 package，由 Google 工程师和 Flutter 和 Dart 社区的开发者开发和发布，你可以用在自己的应用里。</p>
<h2 id="Flutter-Plugin"><a href="#Flutter-Plugin" class="headerlink" title="Flutter Plugin"></a>Flutter Plugin</h2><p>插件 (plugin) 是 package 的一种，全称是 plugin package，我们简称为 plugin，中文叫插件。插件 (plugin package) 是一种特别的 package，特别指那些帮助你获得原生平台特性的 package。插件可以为 Android (使用 Kotlin 或 Java 语言)、 iOS (使用 Swift 或 Objective-C 语言)、Web、macOS、Windows、Linux 平台，或其任意组合的平台编写。比如：某个插件可以为 Flutter 应用提供使用原生平台的摄像头的功能。</p>
<h1 id="使用-Flutter-Module-进行混合开发"><a href="#使用-Flutter-Module-进行混合开发" class="headerlink" title="使用 Flutter Module 进行混合开发"></a>使用 Flutter Module 进行混合开发</h1><p>我们前七天开发的项目就是 Flutter App，今天主要介绍如何使用 Flutter Module 进行混合开发。混合开发官方推荐只使用单个 Flutter 页面，多个 Flutter 页面也能支持，但有可能会出现稳定性、性能问题以及 API 仍然可能变动的问题。请大家谨慎使用。<a href="https://flutter.cn/docs/development/add-to-app/multiple-flutters">官方介绍链接</a></p>
<h1 id="iOS-原生项目中导入-Flutter"><a href="#iOS-原生项目中导入-Flutter" class="headerlink" title="iOS 原生项目中导入 Flutter"></a>iOS 原生项目中导入 Flutter</h1><h2 id="准备一个原生-iOS-项目"><a href="#准备一个原生-iOS-项目" class="headerlink" title="准备一个原生 iOS 项目"></a>准备一个原生 iOS 项目</h2><p>进行混合开发就一定需要一个原生项目，根据你的需求，可以使用目前手上的 APP，也可以临时创建一个 Demo 来先练练手。我们这里就临时新建一个 iOS 原生 Demo。</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/05dd3ccc43394ae4bbcd492293eee1b1~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这个原生项目很简单，就这么两行代码。</p>
<h2 id="新建-Flutter-Module-项目"><a href="#新建-Flutter-Module-项目" class="headerlink" title="新建 Flutter Module 项目"></a>新建 Flutter Module 项目</h2><p>新建一个 Flutter Module 项目，项目名就叫 module。</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/76de47c4dafc48f3bc1dfe7b8e9af0c0~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>最好将两个项目放在同级目录下，因为原生项目需要知道 Flutter Module 项目的位置。</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/c3ccd6384a4a4c9ea5a35c9acf783ec3~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="使用-cocoapods-建立关联"><a href="#使用-cocoapods-建立关联" class="headerlink" title="使用 cocoapods 建立关联"></a>使用 cocoapods 建立关联</h2><p>在原生项目 Demo 里建立 Podfile 文件,然后编辑 Podfile。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter_application_path = <span class="string">&#x27;Podfile相对flutter module的路径&#x27;</span></span><br><span class="line">load File.join(flutter_application_path, <span class="string">&#x27;.ios&#x27;</span>, <span class="string">&#x27;Flutter&#x27;</span>, <span class="string">&#x27;podhelper.rb&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在每个需要集成 flutter module 的 target 添加如下代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">&#x27;你的APP&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  install_all_flutter_pods(flutter_application_path)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>编辑完之后的 Podfile 如下。</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/6f23d64afaad48af93ad329beaed0195~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后执行 <code>pod install</code> 命令</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/091aa3f14c0a48849a1069034a995ae5~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>如上图所示就表示集成好了。就接下来就是如何在原生项目中展示 flutter 的内容了。</p>
<h2 id="展示单个-Flutter-页面"><a href="#展示单个-Flutter-页面" class="headerlink" title="展示单个 Flutter 页面"></a>展示单个 Flutter 页面</h2><p>展示单个 Flutter 页面的方式有两种，一种是使用 FlutterEngine 的方式，一种是不使用 FlutterEngine 的方式，其实不使用 FlutterEngine 的说法是不严谨的，只是我们没有使用代码创建 FlutterEngine 而已，Flutter 框架内部自己创建了 FlutterEngine，但是为了方便记忆，我们可以这么理解。但是这种不使用 FlutterEngine 的方式<a href="https://flutter.cn/docs/development/add-to-app/ios/add-flutter-screen#alternatively---create-a-flutterviewcontroller-with-an-implicit-flutterengine">官方并不推荐</a>。</p>
<p>因为按需创建 <code>FlutterEngine</code> 的话，在 <code>FlutterViewController</code> 被 present 出来之后，第一帧图像渲染完之前，将会引入明显的延迟。但是当 Flutter 页面很少被展示时，当对决定何时启动 Dart VM 没有好的启发时，当 Flutter 无需在页面（view controller）之间保持状态时，此方式可能会有用。</p>
<h3 id="不使用-FlutterEngine-展示单个-Flutter-页面-官方并不推荐"><a href="#不使用-FlutterEngine-展示单个-Flutter-页面-官方并不推荐" class="headerlink" title="不使用 FlutterEngine 展示单个 Flutter 页面(官方并不推荐)"></a>不使用 FlutterEngine 展示单个 Flutter 页面(官方并不推荐)</h3><p>来到 <code>ViewController.m</code> 文件中导入 <code>Flutter</code> 的头文件</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/a07fce1803d941e9bce3a14c91c0a02c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>直接创建 <code>FlutterViewController</code> 对象，并使用 present 和 push 两种方式展示</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/9cc03a3c599f4a9b9364d3be40f47f68~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>APP显示如下图所示：<br></p>
<p>present方式显示如图：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之八/4fc895fa4a0d40329a77e4f982bc97df~tplv-k3u1fbpfcp-watermark.png">
</div>

<p>push方式显示如图：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之八/3ed33eafd5744d229a3fa6522dc9e47c~tplv-k3u1fbpfcp-watermark.png">
</div>

<h3 id="使用-FlutterEngine-展示单个-Flutter-页面"><a href="#使用-FlutterEngine-展示单个-Flutter-页面" class="headerlink" title="使用 FlutterEngine 展示单个 Flutter 页面"></a>使用 FlutterEngine 展示单个 Flutter 页面</h3><h4 id="创建-FlutterEngine"><a href="#创建-FlutterEngine" class="headerlink" title="创建 FlutterEngine"></a>创建 FlutterEngine</h4><p>创建 <code>FlutterEngine</code> 的合适位置取决于您的应用。作为示例，我们将在应用启动的 <code>AppDelegate</code> 中创建一个 <code>FlutterEngine</code>，并作为属性暴露给外界。</p>
<p>在 <code>AppDelegate.h</code> 中</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/ded0c838a6f94e83a17f8a0f7e437d3c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在<code>AppDelegate.m</code>中</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/d409152918c444dab8b008e6e1772723~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h4 id="展示-FlutterViewController"><a href="#展示-FlutterViewController" class="headerlink" title="展示 FlutterViewController"></a>展示 FlutterViewController</h4><img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/8629028d1cf04881bb4e9902a5cd8a30~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>现在，你的 iOS 应用中集成了一个 Flutter 页面。</p>
<h2 id="展示多个-Flutter-页面"><a href="#展示多个-Flutter-页面" class="headerlink" title="展示多个 Flutter 页面"></a>展示多个 Flutter 页面</h2><p>使用上面的方式，最终展示的 Flutter 页面都是同一个页面。而在实际混合开发中，想要展示多个不同的 Flutter 页面的需求应该是普遍的。那么 Flutter 能做到吗？答案是可以的，官方的说法是自 Flutter 2.0.0 开始，可以同时添加多个 Flutter 实例。由于稳定性，性能问题以及 API 任然可能变动，请谨慎使用。<a href="https://flutter.cn/docs/development/add-to-app/multiple-flutters">链接</a></p>
<h3 id="使用-FlutterEngineGroup"><a href="#使用-FlutterEngineGroup" class="headerlink" title="使用 FlutterEngineGroup"></a>使用 FlutterEngineGroup</h3><p>展示多个 Flutter 页面需要使用到 <code>FlutterEngineGroup</code> 来创建 <code>FlutterEngine</code>,而不是上面直接使用 <code>FlutterEngine</code> 的方式。</p>
<p>在<code>AppDelegate.h</code>中</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/a543a5a2a1854fa291bf8e2120c6fe90~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在<code>AppDelegate.m</code>中</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/27d732aecdc9406884024b447df68faa~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="新建一个-flutter-页面"><a href="#新建一个-flutter-页面" class="headerlink" title="新建一个 flutter 页面"></a>新建一个 flutter 页面</h3><p>来到 Android Studio 中的 Flutter module 项目，新建一个 page_two.dart 文件，并做些简单的展示</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/26b655d067424c298a28d5cff4d3ea1e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p><code>PageTwo</code> 页面写好之后，还需要到 main.dart 文件中声明一个新的 dart 入口。这样才能在原生中找到这个 <code>PageTwo</code> 页面,代码如图：</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/beae4201c18346d1a3c10e698d1dbd44~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png"><br>

<p><code>page_two</code> 就是 <code>PageTwo</code> 的入口函数，在原生中待会就会用到。</p>
<h3 id="展示两个-Flutter-页面"><a href="#展示两个-Flutter-页面" class="headerlink" title="展示两个 Flutter 页面"></a>展示两个 Flutter 页面</h3><p>回到原生项目的 ViewController.m 文件中，实现如下代码：</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/f0fba33c2802457588b86c41086ae6d5~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在第0行，我们创建 <code>engine</code> 的时候，并没有传入 Entrypoint 参数，所以就会展示默认的入口函数 <code>main</code> 对应的页面。在第 1 行中，我们创建 <code>engine</code> 的时候，指定了入口函数为 <code>page_two</code>，那么就会展示 page_two() 所对应的页面。</p>
<p>present 展示的页面如图：</p>
<div align=center>
<img src='8天让iOS开发者上手Flutter之八/f04e4be2fa0f415e8931f017ad091e71~tplv-k3u1fbpfcp-watermark.png'>
</div>

<p>push展示的页面如图：</p>
<div align=center>
<img src='8天让iOS开发者上手Flutter之八/a20cf2162ca24b3d816c8938d5d3d8c2~tplv-k3u1fbpfcp-watermark.png'>
</div>

<h1 id="Flutter-与-iOS-端通信"><a href="#Flutter-与-iOS-端通信" class="headerlink" title="Flutter 与 iOS 端通信"></a>Flutter 与 iOS 端通信</h1><p>Flutter 和 iOS 端的通信主要是使用各种通道。有<code>MethodChannel</code>，<code>BasicMessageChannel</code>,<code>EventChannel</code>等等，这里主要介绍前面两种通道。通道通过名称来建立联系，所以通道的名称需要确保是唯一的。如果有同名的通道，通信会受到干扰</p>
<h2 id="MethodChannel-方法通道"><a href="#MethodChannel-方法通道" class="headerlink" title="MethodChannel 方法通道"></a>MethodChannel 方法通道</h2><p>方法通道主要用了传递方法名称和参数。在前面我们新建 PageTwo 的时候，就已经创建了一个 <code>MethodChannel</code> 了，名字为 <code>page_two_channel</code>。然后在文本‘返回上一页’的点击手势里面调用了一个方法 <code>invokeMethod()</code>。这个方法可以传递多个参数，第一个参数就是方法名称，后面是方法参数。我们这里没有参数，就只传入一个方法名 <code>pop</code>。那么 Flutter 端的工作就完成了，再回到我们的 iOS 原生端，ViewController.m 里面。实现如下代码：</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/45acb3a2d3af47278d290b0a24534ac5~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在 iOS 中给 <code>MethodChannel</code> 加了一个 <code>Flutter</code> 前缀。然后初始化 <code>FlutterMethodChannel</code> 的时候，传入的名字一定要和 flutter 端是一致的，不然是无法建立通讯的。然后调用 <code>setMethodCallHandler:</code> 方法传入一个 block 参数。block 参数会在 channel.invokeMethod() 的时候被调用。block 参数 <code>call</code> 就是对 invokeMethod 参数的一个封装。<code>call</code> 的 <code>method</code> 就是方法名，还有一个 <code>arguments</code> 就是方法参数。这样就可以根据方法名进行判断后作出处理了。现在是从 flutter 向 iOS 原生通信，实现了在 flutter 中点击方法实现了 pop 回到上个页面的。相反的，也可以从 iOS 端向 flutter 端通信。在 iOS 端，使用 <code>channel</code> 调用 <code>invokeMethod()</code> 就可以向 flutter 发送消息了，在 flutter 端同样设置 <code>channel</code> 的 <code>setMethodCallHandler</code> 就可以接收了。</p>
<p>flutter 端 <code>setMethodCallHandler</code> 代码如下：</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/6eae59f6154f455d82eca2588c6be0fc~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里说一句，这些通道不能在无状态的 Widget 里使用，改为有状态的就可以了。</p>
<h2 id="BasicMessageChannel-基础消息通道"><a href="#BasicMessageChannel-基础消息通道" class="headerlink" title="BasicMessageChannel 基础消息通道"></a>BasicMessageChannel 基础消息通道</h2><p>除了上面提到的 <code>MethodChannel</code>，你还可以使用<a href="https://docs.flutter.io/flutter/services/BasicMessageChannel-class.html"><code>BasicMessageChannel</code></a>，它支持使用自定义消息编解码器进行基本的异步消息传递。 此外，您可以使用专门的 <a href="https://docs.flutter.io/flutter/services/BinaryCodec-class.html"><code>BinaryCodec</code></a>，<a href="https://docs.flutter.io/flutter/services/StringCodec-class.html"><code>StringCodec</code></a>和 <a href="https://docs.flutter.io/flutter/services/JSONMessageCodec-class.html"><code>JSONMessageCodec</code></a>类，或创建自己的编解码器。</p>
<p><code>BasicMessageChannel</code> 这个通道的使用方法跟上面的 <code>MethodChannel</code> 是一样的，不同点是在 flutter 中创建 <code>BasicMessageChannel</code> 这个通道需要传入一个编解码器，使用一个标准的编解码器 <code>StandardMessageCodec</code> 可以将基本的数据类型进行编解码。<code>BasicMessageChannel</code> 通道可以实现基础数据类型的通讯。iOS 和 flutter 的基础数据类型对应编解码关系：</p>
<img src="/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/992500b07cb845a8afe0039b21cc9384~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来还想写一个混合开发的实际案例的，但是鉴于本人目前的重点并不是 flutter，而且网上也有较多的介绍这种混合开发的实际案例，所以这里篇文章就写到这里了。这 8 篇文章的内容应该说只是一个 iOSer 入门 flutter 的教程，只是些皮毛东西，离掌握 flutter，Dart 还差的很远。而 flutter 的出现也并不是说会完全取代 Android 和 iOS 开发者，flutter 只能用来搭建一套各平台统一的 UI，而各个平台相关的功能，和硬件相关的需求，都依然需要各个平台的开发者去实现。</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之四</title>
    <url>/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/</url>
    <content><![CDATA[<p>上一篇文章我们已经完成了发现页面的搭建，下一步我们实现微信的我的页面</p>
<h1 id="我的页面"><a href="#我的页面" class="headerlink" title="我的页面"></a>我的页面</h1><p>在着手开发我的页面之前，先新建一个 discover 目录，将发现页面相关的文件统一挪动到这个目录下。这里会发现 Android Studio 一个比较特别的地方，新建一个目录后，挪动了的文件不需要重新导入头文件。AndroidStudio 会在需要的地方自动补全路径。这点感觉还是蛮智能的。</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/528d39f8d678470ca40e1823f8b0af82~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="设置APP启动默认展示我的页面"><a href="#设置APP启动默认展示我的页面" class="headerlink" title="设置APP启动默认展示我的页面"></a>设置APP启动默认展示我的页面</h2><p>这个设置在上一篇文章开发发现页面的时候也说过了，就是修改 rootPage.dart 文件里 _currentIndex 的值。</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/49c0b0536b3a48c09cb0f9a3ec6ad539~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="布局右上角的拍照按钮"><a href="#布局右上角的拍照按钮" class="headerlink" title="布局右上角的拍照按钮"></a>布局右上角的拍照按钮</h2><p>观察这个右上角的拍照按钮，会发现上下拖动列表的时候，这个拍照按钮的位置是不会发生变化的。意思是拍照按钮和列表是同级的关系，不是父子控件的关系。所以这里的布局我们可以使用 Stack 来实现，ListView 放在底下，这个拍照按钮放在上面。布局的方式多种多样，只要是能实现需求效果的都是可行的。这个 flutter 的 UI 布局有时候写着写着就会发现括号对不上，使用 command + option + L 也不管用，依然对不齐，这对于某些强迫症的人看起来是真的挺难受的，下图里都还是我一行一行调整了之后的。</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/97c360d9da944ae58e159ca1c540cfe3~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="实现-ListView-的普通-cell-部分"><a href="#实现-ListView-的普通-cell-部分" class="headerlink" title="实现 ListView 的普通 cell 部分"></a>实现 ListView 的普通 cell 部分</h2><p>我的页面的 ListView 的头部那个 cell 明显和它其他的 cell 不同，其他的 cell 跟我们上一篇文章里开发的 discover_cell 基本上是类似的，所以可以直接拿过来使用。做过 iOS 开发的都知道，tableView 等滚动视图作为控制器的根视图的时候，顶部都会有一个间距，在 flutter 里面也有这样的情况，如果需要干掉，就需要将我们的 ListView 包装在一个 <code>MediaQuery.removePadding()</code> 里面，然后设置它的属性 <code>removeTop: true</code>。这样就可以去掉顶部的间距了。完整代码如下：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/62a1932e2d984c959c5cded8cbc3052a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>此时APP显示如图：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之四/7de9c40bd8f44ecf8478bc0f6c96c1f2~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<h2 id="实现-ListView-的头部-cell"><a href="#实现-ListView-的头部-cell" class="headerlink" title="实现 ListView 的头部 cell"></a>实现 ListView 的头部 cell</h2><p>可以看到我们的 _MinePageState 的 build方 法已经够长了，所以关于头部 cell 的代码我们可以封装为一个方法写在其他的地方。</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/f8f135dee51247708051b102a0cdf2d9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>关于头部 cell 这里除了布局稍微复杂了一些之外，就只有给图片加圆角是没有讲过的。要设置圆角图片的话，就不能使用 Image 类了。需要使用到 <code>BoxDecoration</code> 类，它可以设置圆角半径 <code>borderRadius</code> 和图片 <code>image</code>。完整代码如下：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/609e9067e74f4ca78908c3d3986a7589~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">
<p>APP 显示效果如图： </p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之四/b05e536a5a344eb2af3049b88472054c~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<p>我的页面就这样完成了。发现页面和我的页面这两个页面主要是对布局的灵活运用，都还是比较简单的。</p>
<h1 id="通讯录页面"><a href="#通讯录页面" class="headerlink" title="通讯录页面"></a>通讯录页面</h1><p>接下来实现通讯录界面，这节课先只实现到下图这样，边上的索引下节课再实现。</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之四/9e1c9e054a92483d9a0da553a3c5745e~tplv-k3u1fbpfcp-watermark.png"/>
</div>

<h2 id="设置-APP-启动默认展示通讯录页面"><a href="#设置-APP-启动默认展示通讯录页面" class="headerlink" title="设置 APP 启动默认展示通讯录页面"></a>设置 APP 启动默认展示通讯录页面</h2><p>这一步已经讲过 2 次了，就不再贴图了…</p>
<h2 id="设置通讯录页面导航栏"><a href="#设置通讯录页面导航栏" class="headerlink" title="设置通讯录页面导航栏"></a>设置通讯录页面导航栏</h2><p>导航栏的颜色，我们修改了好几次了。这个颜色可以放在一个 const.dart 的公用文件里。以后统一使用这个颜色，也方便以后统一修改。</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/5b11ecbb41ec479ca4289993173347b8~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后是通讯录页面的导航条，除了标题之外，右侧还有一个添加好友的按钮，可以使用 AppBar 的 title 实现一个复杂的导航条，但其实没那个必要。AppBar 提供了一个 actions 属性，这个属性就是展示在导航条右侧的，直接使用这个 actions 就可以了。代码如下：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/b36b444a710a4e30b0a2bdc4eac87790~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="实现通讯录列表-cell"><a href="#实现通讯录列表-cell" class="headerlink" title="实现通讯录列表 cell"></a>实现通讯录列表 cell</h2><p>通讯录列表 cell 可以使用一种 cell 来完成，也可以使用两种不同的 cell 来完成，如果使用一种 cell 的话，代码里面需要判断的逻辑就会有点多。所以我这里推荐使用两种 cell 来完成。第一种就是头部的 4 个 cell，这几个属于一类，我们使用类 <code>_FriendLocalCell</code> 来表示，而其余的都是属于好友 cell 属于一类，用类 <code>_FriendNetworkCell</code> 表示。关于这两种 cell 我们暂时先不新建文件存放，直接在 friends_page.dart 文件中写。</p>
<h3 id="实现-FriendLocalCell"><a href="#实现-FriendLocalCell" class="headerlink" title="实现 _FriendLocalCell"></a>实现 <code>_FriendLocalCell</code></h3><p>这一类 cell 主要是用来展示当前列表头部的几个 cell 的，这几个 cell 的图片都是从本地加载的。从效果图上可以看出，这个 cell 只需要 title，和 imageName 这两个必传参数就够了。然后是关于布局。最外层使用一个 Row 进行左右布局，左侧使用一个能显示圆角的图片。右侧再用一个 Column 进行上下布局，将文本和底部的分隔线上下排列。这里主要有一个地方没有讲到过，就是在 flutter 中获取屏幕的宽高，我们会抽成一个方法，放在 const.dart 文件中。如下图所示：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/a5731eb671cc4d43b4561f53bcf137ba~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p><code>_FriendLocalCell</code> 完整代码如下：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/5664732c2af244769cd8c120d9cb6390~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="实现-FriendNetworkCell"><a href="#实现-FriendNetworkCell" class="headerlink" title="实现 _FriendNetworkCell"></a>实现 <code>_FriendNetworkCell</code></h3><p>关于 <code>_FriendNetworkCell</code>，可能乍一看之下，会觉得应该和上面的 cell 差不太多。但是实际上还是有那么些区别的。首先 flutter 的 ListView 的是没有组的概念的，所以关于组标题就需要我们自己来动手实现了，这里的做法就是，除了上面的 <code>_FriendLocalCell</code> 所有的子控件之外，每一个 cell 都带上一个组标题，然后根据组标题是否有值，来显示或不显示组标题。那么在布局方面，就需要对上面的 cell，再包装一个 Column，将组标题和头像名称部分包起来。所以当前 cell 所需要的属性，除了好友的名字 <code>name</code> 和头像 <code>imageUrl</code> 为必须之外，还需要一个 <code>groupTitle</code> 为可选参数。</p>
<p>完整的代码如下：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/8f3622e493514fed80132a2783a8e40e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="准备数据模型"><a href="#准备数据模型" class="headerlink" title="准备数据模型"></a>准备数据模型</h2><p>同样的，数据我们也分为两种，一种我们就叫作通讯录，使用 <code>AddressBook</code> 来表示。另一种叫好友用 <code>Friends</code> 表示。我们将好友列表用到的数据模型都放在新的文件 friends_data.dart 文件中。</p>
<h3 id="准备-AddressBook-模型数组"><a href="#准备-AddressBook-模型数组" class="headerlink" title="准备 AddressBook 模型数组"></a>准备 <code>AddressBook</code> 模型数组</h3><p>这个模型数组，可以直接根据我们在效果图上看到的东西，生成对应的模型，和数组就好了。完整代码如下：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/6769dce1c0a241238c9b687c316e685b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="准备-Friends-模型数组"><a href="#准备-Friends-模型数组" class="headerlink" title="准备 Friends 模型数组"></a>准备 <code>Friends</code> 模型数组</h3><p>这里的数据源已经准备好了，我们只需要根据数据源创建出对应的模型。这个数组是好友数组,有需要的可以自行前往<a href="https://github.com/masterKing/wechatDemo">下载</a>。</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/4f37de210e874b6b87611bb8b24940c6~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="实现部分通讯录页面"><a href="#实现部分通讯录页面" class="headerlink" title="实现部分通讯录页面"></a>实现部分通讯录页面</h2><p>现在我们的视图和数据都已经准备好了。接下来就是直接使用了，我们之前在发现页面使用 ListView 的方式，没有使用 builder，是直接使用的方式，就跟我们在 iOS 中的 cellForRow 方法中每次创建一个新的 cell 的方式一样，cell 没有重复利用。而今天我们使用 builder 的这种方式，就是 cell 被放入缓存池中被重复利用的方式。使用 <code>ListView.builder()</code> 的方式，需要传入两个参数，一个是 itemCount 元素的个数。一个是 itemBuilder，类似于 cellForRowAtIndexPath 方法，需要我们创建 cell 并返回。完整的代码如下：</p>
<img src="/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/3849d87dabcb414fbabcb46e04ffc067~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里再说一下对 datas 进行排序的地方。这个方法 <code>initState()</code> 有一个 @override 修饰，意思就会重写父类的方法，而且这个方法应该是调用的比 build 要早的。这样才能保证展示数据的时候，数据是已经经过排序过的。而这个排序的方法，其实跟 iOS 中的 <code>sortedArrayUsingComparator:</code> 排序也非常的像，传入一个代码块的方式。所以有开发经验的同学，会发现真的有些东西，各个平台都是通用的，学起来也会更快更容易上手。最后 APP 的显示如下图：</p>
<div align=center>
<img src="8天让iOS开发者上手Flutter之四/b9f94392e09f449f8bb8f73879d2a793~tplv-k3u1fbpfcp-watermark.png"/>
</div>


]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Category</title>
    <url>/2025/06/08/Category/</url>
    <content><![CDATA[<h1 id="分类诞生的历史"><a href="#分类诞生的历史" class="headerlink" title="分类诞生的历史"></a>分类诞生的历史</h1><p>Objective-C 的分类（Category）语法并非随语言初始版本一同出现，而是随着语言发展逐步引入的重要特性。以下是关键时间线和技术背景分析：</p>
<p>Objective-C 由 Brad Cox 和 Tom Love 在 1980 年代初基于 C 语言开发，旨在添加 Smalltalk 风格的面向对象特性。初始版本（1981年）​​ 仅包含核心的面向对象机制（如类、继承、消息传递），​​未包含分类语法​​。此时语言的核心是“软件组件”（Software-IC）概念，聚焦于通过类封装数据和操作。</p>
<p>​​Objective-C 的类别（Category）语法是在 1990 年代初加入到 Objective-C 语言中的，具体时间是随着 NeXTSTEP 操作系统的发布而引入的。NeXTSTEP 是苹果公司前首席执行官史蒂夫·乔布斯创办的 NeXT 公司开发的操作系统，它使用了 Objective-C 作为主要编程语言，并引入了类别这一特性。﻿<br>​​<br>​​<strong>设计动机</strong>​​：解决无法修改原始类（如系统框架类）时扩展功能的需求。例如，为 NSString 添加绘图方法而无需继承或修改原始实现。这是最核心的应用场景。早期 Objective-C 依赖继承和组合实现扩展，分类则提供了更轻量、灵活的替代方案，直接为类添加方法。</p>
<h1 id="核心语法：声明与实现"><a href="#核心语法：声明与实现" class="headerlink" title="核心语法：声明与实现"></a>核心语法：声明与实现</h1><p>分类，分类，顾名思义就知道，它是对类的拆分，所以需要一个明确的类，然后是分类的名称。</p>
<ul>
<li>分类的声明：  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassName</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line"><span class="comment">// 分类需要的属性。。。</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li>
<li>分类的实现：  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassName</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line"><span class="comment">// 方法的实现</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>按照实际使用频率排序：</p>
<h2 id="🛠️-一、扩展系统或第三方框架类"><a href="#🛠️-一、扩展系统或第三方框架类" class="headerlink" title="🛠️ 一、扩展系统或第三方框架类"></a>🛠️ 一、扩展系统或第三方框架类</h2><p>场景：为 NSString、NSArray 等系统类或者第三方框架提供的类添加项目所需的特定方法。<br>示例：为 NSString 添加邮箱格式验证方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSString+Validation.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">Validation</span>)</span></span><br><span class="line">- (<span class="type">BOOL</span>)isValidEmail;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSString+Validation.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Validation</span>)</span></span><br><span class="line">- (<span class="type">BOOL</span>)isValidEmail &#123;</span><br><span class="line">    <span class="comment">// 正则验证逻辑</span></span><br><span class="line">    <span class="keyword">return</span> [emailTest evaluateWithObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>优势：</p>
<ul>
<li>不修改 NSString 源码，避免破坏系统类的封装性；</li>
<li>方法对所有 NSString 实例及子类（如 NSMutableString）生效。</li>
</ul>
<h2 id="⚙️-二、面向切面编程（AOP）支持"><a href="#⚙️-二、面向切面编程（AOP）支持" class="headerlink" title="⚙️ 二、面向切面编程（AOP）支持"></a>⚙️ 二、面向切面编程（AOP）支持</h2><p>场景​​：无侵入添加横切关注点（如日志、埋点）。<br>示例​​：通过分类实现方法交换（Method Swizzling）：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> (<span class="title">log</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> (<span class="title">log</span>)</span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Method original = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidAppear:));</span><br><span class="line">        Method swizzled = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(swizzled_viewDidAppear:));</span><br><span class="line">        method_exchangeImplementations(original, swizzled);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)swizzled_viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">// 调用原始方法实现</span></span><br><span class="line">    [<span class="keyword">self</span> swizzled_viewDidAppear:animated];</span><br><span class="line">    <span class="comment">// 实现需求</span></span><br><span class="line">    [Analytics logEvent:<span class="string">@&quot;ScreenAppeared&quot;</span> forView:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>​​优势​​：</p>
<ul>
<li>统一埋点逻辑，避免污染业务代码；</li>
<li>适用于调试、性能监控等全局行为。</li>
</ul>
<h2 id="🧩-三、代码模块化与可读性提升"><a href="#🧩-三、代码模块化与可读性提升" class="headerlink" title="🧩 三、代码模块化与可读性提升"></a>🧩 三、代码模块化与可读性提升</h2><p>场景​​：将大型类的功能拆分到多个分类中，按逻辑分组管理。<br>示例​​：自定义 UIView 时分离布局、动画、样式代码；或者 NSApplication.h，UIApplication.h 头文件的实现方式</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIView+Layout.h  (布局相关)</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">Layout</span>)</span></span><br><span class="line">- (<span class="type">void</span>)autoCenterInSuperview;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UIView+Animation.h  (动画相关)</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">Animation</span>)</span></span><br><span class="line">- (<span class="type">void</span>)fadeInWithDuration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<h1 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h1><p>分类中的方法都会合并到类对象的方法列表中。具体来说，分类中的实例方法会被合并到类对象的方法列表中，分类中的类方法会被合并到元类对象的方法列表。</p>
<p>那么这个合并的动作发生在什么时刻？是程序启动的时候？还是编译源码的时候？</p>
<p>根据分类的能力来说，分类可以给系统的类和第三方的类添加方法，那么可以推理出一定不是在编译时进行合并的，因为在编译时根本无法获取到系统的类和第三方的类对象啊，只能在运行时加载系统的类和第三方类的时候将分类中的方法添加到类中。其实实际上也确实这样的，我们可以从 Objective-C 的运行时库源码和编译后的产物中得到验证。</p>
<h2 id="1-编译时的处理"><a href="#1-编译时的处理" class="headerlink" title="1. 编译时的处理"></a>1. 编译时的处理</h2><p>分类的底层结构，即编译器是如何处理我们编写的分类的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">custom</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSDate</span> (<span class="title">custom</span>)</span></span><br><span class="line">- (<span class="type">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们在源码中创建了多少个分类，在编译时就会产生多少个分类的结构体变量。如：你给 NSObject 创建了 2 个分类，那么在编译时就生成了 2 个分类结构体变量。分类的名字就是变量名的最后部分。通过查看编译后的分类结构也能验证，并不是在编译时就合并到类中了。编译时仅仅是将分类的信息保存了下来。</p>
<h2 id="2-运行时的合并"><a href="#2-运行时的合并" class="headerlink" title="2. 运行时的合并"></a>2. 运行时的合并</h2><p>那运行时到底是如何合并分类信息到类中的呢？那就是 objc4 的源码分析了</p>
<p><code>_objc_init -&gt; map_images -&gt; map_images_nolock() -&gt; _read_images()</code></p>
<p>在 <code>_read_images()</code> 函数里面。核心方法 <code>remethodizeClass()</code> 里面有一个 <code>attachCategories()</code> 方法。最后是 class 的 rw 的 attachLists 方法的实现。</p>
<p>首先将方法数组扩容，然后将原始的方法列表移动到数组的末尾，再将所有分类的方法列表复制到前面。这样就导致了分类的方法列表会在原始的方法列表前面，造成了类似覆盖的效果。就是说分类中如果存在和原始类中同名的方法，那么就会导致原始类中的方法不会被调用，而是调用分类中的方法。而如多个分类中存在同名的方法，则会按照编译的顺序优先调用，最后编译的分类中的方法会放在数组前面导致的。</p>
<p>分类涉及的相关知识还是挺深的。。。个人认为，想要掌握 Category 的底层原理，必须先掌握，Objective-C 对象模型，运行时库初始化，等等底层知识。</p>
<h1 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h1><p>理解了分类的底层原理之后，自然而然的就会考虑到不恰当使用分类可能会导致的问题：</p>
<h2 id="不能添加实例变量"><a href="#不能添加实例变量" class="headerlink" title="不能添加实例变量"></a>不能添加实例变量</h2><p>这一点需要结合分类的设计初衷来讲，虽然从技术上来说，分类可以做到给类添加实例变量，但是会带来巨大的不稳定性和性能开销以及破坏类的封装性，从多方面考虑让分类支持添加实例变量都不是一个合适的选择。所以实际上也并没有让分类支持添加实例变量的能力，而是提供了关联对象技术达到类似实例变量的效果。</p>
<h2 id="命名冲突风险"><a href="#命名冲突风险" class="headerlink" title="命名冲突风险"></a>命名冲突风险</h2><p>这是一个非常有可能会遇到的问题，多个分类中如果存在同名的方法，那么运行时到底会执行哪一个方法这是有答案的。取决于最后编译的是哪个分类，从前面的底层原理中得知，最后面的编译的分类会被添加到类的方法列表的前面。但是实际运用分类过程中是极不推荐在分类中使用同名方法的，应该尽量避免，解决办法就是给每个分类的方法添加一个前缀，这样大大降低了同名的可能。</p>
<h2 id="不可覆盖原生方法"><a href="#不可覆盖原生方法" class="headerlink" title="不可覆盖原生方法"></a>不可覆盖原生方法</h2><p>覆盖系统方法可能导致框架行为异常。这也是非常有可能出现的问题，而且危险性较高，建议分类仅用来添加新功能，而不是修改原有的逻辑。</p>
<blockquote>
<p>分类的核心价值在于 ​​“无侵入式扩展”​​，任何可能破坏类封装性或导致运行时冲突的方案（如方法覆盖），都应优先考虑替代设计。</p>
</blockquote>
<h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><ul>
<li>Category 的使用场景是什么</li>
<li>Category 的实现原理</li>
<li>Category 和 Extension 的区别是什么</li>
<li>Category 有 load 方法吗？load 方法在什么时候被调用？load 方法能继承吗？<ul>
<li>分类有没有 load 方法？这个问题十分奇怪？分类哪里来的 load 方法？你在分类里写了 load 方法就肯定有，没写就肯定没有啊。。。</li>
<li>这回是 load_images 方法的源码分析了。先调用类的 load 方法，再调用分类的 load 方法。</li>
<li>objc 运行时在初始化的时候，会直接调用类的 load 方法，而不是通过消息发送的形式调用 load 方法。</li>
<li>我觉得，你得先搞懂 Objective-C 语言提供 load 方法的目的是什么？</li>
<li>load，initialize 方法在 NSObject.h 文件中声明，并没有实现。那么 Objective-C 语言在 NSObject.h 文件中声明 load 和 initialize 又不实现的目的是什么呢？</li>
</ul>
</li>
<li>load、initialize 方法的区别是什么？它们在 category 中的时候被调用的顺序是什么？出现继承时它们之间的被调用过程是怎样的？</li>
<li>category 能否添加成员变量？如果可以，如何添加，如果不可以，解释为什么不可以？</li>
</ul>
]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>Cycript</title>
    <url>/2023/08/23/Cycript/</url>
    <content><![CDATA[<h1 id="什么是-Cycript"><a href="#什么是-Cycript" class="headerlink" title="什么是 Cycript"></a>什么是 Cycript</h1><p>Cycript 是一种用于 iOS 操作系统的脚本语言，同时也是该语言的解释器（一般来说不需要编译的脚本语言都会提供它对应的解释器，比如 Python、JavaScript、Ruby、PHP 等），Cycript 是 JavaScript，Objective-C++ 等语言的混合物这意味着它能理解 JavaScript，Objective-C++ 甚至是 Objective-C 语法，但是需要注意的是 Cycript 主要支持 JavaScript 的语法，对前端开发人员比较友好，而由于 Swift 吸收了 JavaScript 等其他各种语言的优点，所以 Cycript 中也能看到 Swift 的影子，Cycript 对 Objective-C 语法并不是完全支持，比如 Objective-C 创建一个 UIView 的代码是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIView *view = [[UIView alloc] init];</span><br></pre></td></tr></table></figure>

<p>而在 Cycript 中，&#x3D; 号后面的部分可以识别，而前面的部分不支持，需要使用 JavaScript 的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var view = [[UIView alloc] init]</span><br></pre></td></tr></table></figure>

<p>作者最初设计的目的好像就是希望通过 JavaScript 学习使用 Cocoa&#x2F;UIKit 。</p>
<p>Cycript 同时还是一个可交互的控制台工具。主要用于在运行时与 iOS 应用程序远程交互、调试和分析。它允许开发人员以一种动态的方式与 iOS 应用程序进行通信，甚至可以修改其行为。这一点对比 lldb 来说更加灵活，lldb 调试时总是需要中断当前调试的进程，当然 lldb 有它的优势是可以下断点调试，可以手动砸壳 APP，是苹果的亲儿子等等优势。</p>
<p>Cycript 在越狱设备上广泛使用，越狱 iOS 安装 cycript 工具之后可以在越狱 iOS 上直接调试大部分 APP。在非越狱的设备上也是可以使用的，虽然一般在非越狱开发都会使用苹果 Xcode 提供的 lldb 调试，cycript 提供了一个 cycript.framework 库可以用来集成到 APP 中实现非越狱环境下的远程（通过 IP 地址和端口号）调试，这一点就非常酷炫了，想想在非越狱环境下你在远程调试分析一个 APP。有些人认为 Cycript 只能用于界面分析。。。其实 Cycript 远比大多数人想象的要强大…</p>
<p>cycript 的源码位于 <a href="https://git.saurik.com/cycript.git">https://git.saurik.com/cycript.git</a> 感兴趣的同学们可以下载下来看看。</p>
<p>Cycript 的主要特点包括：</p>
<ol>
<li><p><strong>动态注入和交互：</strong> Cycript 可以将脚本注入到运行中的应用程序进程中，从而允许开发人员在应用程序的上下文中执行代码。这使得开发人员可以检查应用程序的内部状态、调用其方法并进行交互。</p>
</li>
<li><p><strong>访问对象和类：</strong> Cycript 允许开发人员直接访问运行中的对象和类的属性、方法和成员变量。这对于调试和分析应用程序非常有用，尤其是当源代码不可用或者难以访问时。</p>
</li>
<li><p><strong>修改应用程序行为：</strong> 使用 Cycript，开发人员可以在运行时修改应用程序的行为，例如重定义方法、改变变量值等。这使得开发人员可以实时测试和验证不同的应用程序行为。</p>
</li>
<li><p><strong>探索界面元素：</strong> Cycript 还可以用于查找和探索应用程序的界面元素（例如视图和控件），以便更好地了解应用程序的界面层次结构和布局。</p>
</li>
</ol>
<h1 id="非越狱环境使用-cycript"><a href="#非越狱环境使用-cycript" class="headerlink" title="非越狱环境使用 cycript"></a>非越狱环境使用 cycript</h1><p>在非越狱环境下使用有两个前提条件</p>
<ul>
<li>Cycript.framework 将这个框架集成到你的 iOS 项目中。</li>
<li>cycript 终端命令行工具。在 MacOS 的终端运行这个工具，加上 IP 地址和端口就能和 iOS 项目建立联系，实现调试探索 APP 了。</li>
</ul>
<h2 id="iOS-项目集成-Cycript-framework"><a href="#iOS-项目集成-Cycript-framework" class="headerlink" title="iOS 项目集成 Cycript.framework"></a>iOS 项目集成 Cycript.framework</h2><p>从官网 <a href="http://www.cycript.org/">http://www.cycript.org/</a> 下载最新版本的 cycript 可能无法直接使用，会报一些库找不到的错误，没关系我们一步步解决。本人使用的是 MacOS ventura 13.5 的系统，进入下载文件夹后解压刚刚下载好的 cycript_0.9.594.zip 压缩包后如下图所示：</p>
<img src="/2023/08/23/Cycript/5d087a97d00a42d992bc0ee0082bf942~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>其中 Cycript.ios 里面就有我们需要的 Cycript.framework 文件。黑色的 cycript 就是我们需要的终端命令行工具。先将 Cycript.framework 集成到我们的 iOS 项目中，我这里新建了一个 CycriptDemo 的空工程。</p>
<img src="/2023/08/23/Cycript/d32b77ce2d2d43d797261dc7c2cfd036~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>Cycript.framework 集成成功之后，我们在 APP 启动的时候添加一点代码，如下图：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Cycript/Cycript.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    CYListenServer(<span class="number">3335</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这里填写的端口号，只要是可用的端口号就都可以。可用的端口范围取决于您的操作系统和网络设置。通常情况下，TCP&#x2F;IP 协议定义的端口号范围是从 0 到 65535。然而，其中一些端口已经被标准协议用于特定的服务（例如，端口 80 用于 HTTP，端口 443 用于 HTTPS 等），因此不是所有的端口都可以随意使用。</p>
<p>通常情况下，非特权用户（普通用户）可以使用的端口号范围是从 1024 到 49151，而特权用户（如管理员或超级用户）可以使用从 0 到 1023 的端口号。</p>
<p>现在，运行 CycriptDemo 将 APP 安装到未越狱的 iPhone 上。不出意外应该会遇到以下报错</p>
<img src="/2023/08/23/Cycript/f3c93ab5caf7421eaf931148a2e1f7b2~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>让人感到有点莫名其妙，不过开发过程中有报错并不可怕，按照报错的提示去解决就好了，可怕的是没有任何提示而又没有按照预期的运行这才是最可怕的，根本无从下手解决。在做安全防护的时候也是如此，不要给出任何明显的提示或者报错，这样会让攻击者更容易就找到破解的办法。</p>
<p>回到之前解压的 cycript_0.9.594 目录中，在 Cycript.lib 目录下存在 libcycript.db 文件，将它拖进项目中就可以解决。</p>
<img src="/2023/08/23/Cycript/4a5430071b9d4819a57fc505b1728485~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>到这里 iOS 端的准备工作就差不多做好了。。。</p>
<h2 id="解决-cycript-命令行工具依赖库问题"><a href="#解决-cycript-命令行工具依赖库问题" class="headerlink" title="解决 cycript 命令行工具依赖库问题"></a>解决 cycript 命令行工具依赖库问题</h2><p>下一步我们需要解决 cycript 终端命令行工具的依赖库找不到的问题，让 cycript 成功运行起来。首先打开终端进入到刚刚解压的 cycript_0.9.594 文件夹，输入 <code>./cycript</code> 执行在我的环境下给出如下报错：</p>
<img src="/2023/08/23/Cycript/754d10ee59f64fd490c8d83144604021~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>意思就是找不到 Python.framework 库，这是由于 MacOS 在版本 macOS 11.0（Big Sur）中正式移除了预装的 Python 2.7。cycript 在 2016 年之后就停止更新了，在无法更新 cycript 的依赖库的情况下（或许可以通过反汇编修改二进制，但目前看没有这个必要），我们只能想办法在上述指定位置安装 Python 库，也不一定要使用指定 Python2.7 版本，因为在软件开发领域新版本的程序一般都会向下兼容老版本的程序，就是说如果一个软件的依赖库找不到了，可以使用较新的版本的库直接替换，如果用更老的版本就可能出现问题，这个做开发的应该都知道但没想到。</p>
<p>所以我准备将我电脑上已经安装好的 Python3.11 版本的 Python.framework 复制到到上述路径并修改一下版本号就行了。如果你的电脑上本来就没有安装 Python 库，那就使用 <code>brew install python</code> 安装好了。安装好之后同样找到 Python.framework 复制到上述路径。</p>
<p>使用 <code>brew list python</code> 发现我的电脑已安装的 Python 版本</p>
<img src="/2023/08/23/Cycript/17e012e78782425d8ff0fe2291f1946e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="Xnip2023-08-18_21-53-47.png">

<p>由于 MacOS 的 SIP 限制，&#x2F;System&#x2F;… 路径是只读的，在 MacOS 13.5 上即使禁用了 SIP 也依旧无法修改。也许有办法只是目前我还没有找到可以修改的方法。<br>好在给出的错误提示，指出了多个路径都找不到同一个库，于是猜测到这么多路径中只要有一个路径存在指定库就可以，其中最后一个路径 &#x2F;Library 目录是可以修改的，于是尝试将 Python3.11 版本的 Python.framework 复制到 &#x2F;Library&#x2F;Framework&#x2F; 目录下，并将 Versions 目录下的 3.11 重命名为 2.7 之后就解决了上面这个报错。最终结果就是按照上面报错的最后一个路径 <code>/Library/Frameworks/Python.framework/Versions/2.7/Python</code> 配置好一个 Python 可执行文件。</p>
<p>继续输入 <code>./cycript</code> 看是否能运行成功。没有那么顺利，在我的环境下，又报了以下错误：</p>
<img src="/2023/08/23/Cycript/680174bfc5e94845a56322e7cb17577d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>解决方式跟刚刚类似，找到电脑上已安装的 libruby.dylib 库，将它复制到了 <code>/usr/local/lib/</code> 目录下，这个 <code>/usr/local/</code> 目录一般就是用来存放用户级别的库的。如果你的电脑上没有安装 ruby 库，那就先安装好，再复制到 <code>/usr/local/lib/</code> 目录下，并重命名为 <code>libruby.2.0.0.dylib</code>。</p>
<p>继续输入 <code>./cycript</code> 发现进入了交互环境了，表示依赖库都配置好了，如果你还有其他报错，继续按照刚刚的方法解决就行了。</p>
<img src="/2023/08/23/Cycript/3f6beead8c5648efb1ce1d5d1e539a3c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h2 id="开始远程调试"><a href="#开始远程调试" class="headerlink" title="开始远程调试"></a>开始远程调试</h2><p>接下来找到 iPhone 所在网络的 IP 地址，确认 iPhone 和 Mac 需要在同一局域网内。打开刚刚安装的 CycriptDemo ，然后在 Mac 终端输入 <code>./cycript -r IP:端口号</code> 如果不出意外（除非你新建的项目 bundleIdentifier 是之前使用过的，并且之前该 APP 已经成功安装运行并允许使用无线局域网），那么大概率是无法连接成功的，会报以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** _syscall(connect(socket_, info-&gt;ai_addr, info-&gt;ai_addrlen)):../Console.cpp(306):CYSocketRemote [errno=60]</span><br></pre></td></tr></table></figure>

<p>这是 socket 连接返回的错误码，错误码 “errno&#x3D;60” 对应的是 “ETIMEDOUT”，这是基于一般的网络编程经验和标准的错误码定义而来。这是因为我们新创建工程并没有获取到使用无线局域网络的用户授权，也就是很多 APP 第一次启动访问网络时会弹出的授权提示，如下图所示。所以在我们新创建的 CycriptDemo 工程中还需要添加一些访问网络的代码，让系统自动弹出这个授权弹窗并选择无线局域网与蜂窝网络、或者仅限无线局域网都可以。如果你不小心点击了不允许，可以在 iOS 的设置 APP 中找到你当前的 APP -&gt; 无线数据，重新选择。</p>
<p align=center><img src="Cycript/b82b620ff8304730881adfcb4796f159~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0106.PNG" width="30%" /></p>

<p>添加如下访问网络连接的代码再次启动时就会弹出上面的授权弹窗。如果你是集成到已经获取了授权的项目中，可以不用添加这行代码。获取到用户授权之后可以删除掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;https://httpbin.org/get&quot;</span>]]] resume];</span><br><span class="line">    CYListenServer(<span class="number">3335</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功获取使用无线局域网授权之后，我们再次尝试连接，应该可以看到以下结果：</p>
<img src="/2023/08/23/Cycript/f0f3c160f2c44b3a80889a1592ec35a5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>有时候还有可能会遇到以下错误</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*** _syscall(connect(socket_, info-&gt;ai_addr, info-&gt;ai_addrlen)):../Console.cpp(306):CYSocketRemote [errno=61]</span><br></pre></td></tr></table></figure>

<p>这个一般是 APP 还没有启动成功，服务还没开始运行，或者在后台被杀掉导致的。确保 APP 在前台并且启动完成之后再连接就好了。</p>
<p>连接成功进入交互环境后可以输入 <code>UIApp</code> 获取应用实例对象，这是 Cycript 对 iOS 中的 <code>[UIApplication sharedApplication]</code> 的包装，也可以直接输入 <code>[UIApplication sharedApplication]</code> 获取，就像在 lldb 调试那样。退出交互环境使用键盘快捷键 control + D ,或者输入 <code>?exit</code> 。</p>
<img src="/2023/08/23/Cycript/d6407aa127834c71937f55b80ccef1ba~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h1 id="越狱环境下使用-cycript"><a href="#越狱环境下使用-cycript" class="headerlink" title="越狱环境下使用 cycript"></a>越狱环境下使用 cycript</h1><p>在越狱环境下使用 cycript 就没有那么麻烦了，只需要在 Cydia 或者 Sileo 中搜索并安装 Cycript 。安装好之后通过 ssh 远程连接到越狱 iPhone 之后，直接可以输入 <code>cycript -p pid或进程名称</code> 就可以开始调试了。可以使用 <code>ps -A | grep app</code> 获取到 pid 或者 进程名称。如果提示没有 <code>ps</code> 这个命令，需要安装 adv-cmds 工具，不过一般在安装 Cycript 的时候应该已经一并安装了。</p>
<p>关于如何通过 ssh 远程连接到越狱 iPhone 可以看我之前的文章 <a href="https://juejin.cn/post/7262982452768145465">从 Mac 远程登录到 iPhone</a>。</p>
<p>在越狱设备上输入 <code>ps -A | grep app</code> 获取 pid 或 进程名称的结果如下：</p>
<img src="/2023/08/23/Cycript/177b4189f70b4a058ed8ac4b0743ebe6~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>前面的数字就是 pid ，路径最后就是进程名称。我们以红框中的 SpringBoard APP 为例，附加到这个 APP 中。这个 APP 就是我们 iOS 用户最熟悉的陌生人了，天天看的最多，用的最多的手机桌面。输入以下代码会看到手机桌面显示出了弹窗</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iPhone:~ root# cycript -p SpringBoard</span><br><span class="line">cy# var alertvc = [UIAlertController alertControllerWithTitle:@<span class="string">&quot;title&quot;</span> message:@<span class="string">&quot;message&quot;</span> preferredStyle:1]</span><br><span class="line"><span class="comment">#&quot;&lt;UIAlertController: 0x101b66a00&gt;&quot;</span></span><br><span class="line">cy# [alertvc addAction:[UIAlertAction actionWithTitle:@<span class="string">&quot;confirm&quot;</span> style:0 handler:nil]]</span><br><span class="line">cy# [alertvc addAction:[UIAlertAction actionWithTitle:@<span class="string">&quot;cancel&quot;</span> style:1 handler:nil]]</span><br><span class="line">cy# [UIApp.keyWindow.rootViewController presentViewController:alertvc animated:YES completion:nil]</span><br><span class="line">cy# </span><br></pre></td></tr></table></figure>

<p>iPhone 桌面显示如图：</p>
<p align=center><img src="Cycript/08b3e4241c4b40f08027510a234cfc8d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0004.PNG" width="50%" /></p>

<h1 id="cycript-基础用法"><a href="#cycript-基础用法" class="headerlink" title="cycript 基础用法"></a>cycript 基础用法</h1><p>好了，到这里不论你是在非越狱环境还是在越狱环境应该都可以进入 Cycript 与 APP 的交互环境了。现在先了解一下 Cycript 提供的一些基础用法，就用刚刚在非越狱环境使用 Cycript 中创建的 CycriptDemo 进行演示。打开手机上的 CycriptDemo APP，然后打开终端 cd 进入 cycript_0.9.594 目录下并进行连接（有需要可以配置成环境变量方便全局使用），如下图：</p>
<img src="/2023/08/23/Cycript/7d2dedd81252481882bf270369a201d7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h2 id="创建最简单的-UIView-并添加到-keyWindow-上"><a href="#创建最简单的-UIView-并添加到-keyWindow-上" class="headerlink" title="创建最简单的 UIView 并添加到 keyWindow 上"></a>创建最简单的 UIView 并添加到 keyWindow 上</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# var rect = new (struct CGRect)</span><br><span class="line">&amp;&#123;origin:&#123;x:new Number&#123;&#125;,y:new Number&#123;&#125;&#125;,size:&#123;width:new Number&#123;&#125;,height:new Number&#123;&#125;&#125;&#125;</span><br><span class="line">cy# rect-&gt;origin.x = 50</span><br><span class="line">50</span><br><span class="line">cy# rect-&gt;origin.y = 100</span><br><span class="line">100</span><br><span class="line">cy# rect-&gt;size.width = 100</span><br><span class="line">100</span><br><span class="line">cy# rect-&gt;size.height = 60</span><br><span class="line">60</span><br><span class="line">cy# var greenView = [[UIView alloc] initWithFrame:*rect]</span><br><span class="line"><span class="comment">#&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span></span><br><span class="line">cy# greenView.backgroundColor = [UIColor greenColor]</span><br><span class="line"><span class="comment">#&quot;UIExtendedSRGBColorSpace 0 1 0 1&quot;</span></span><br><span class="line">cy# [UIApp.keyWindow addSubview:greenView]</span><br></pre></td></tr></table></figure>
<p>APP 的显示如图：</p>
<p align=center><img src="Cycript/dada50269c8546cfb5dfe1c6f5d6d672~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0110.PNG" width="30%" /></p>

<p>可以看到，Cycript 中的 CGRect 用起来并不是特别方便，而且默认也没有提供对 CGRectMake() 函数的支持，这一点我也不是太明白。不过我们可以定义自己的函数，实现同样的功能。代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# <span class="keyword">function</span> CGPointMake(x, y) &#123; <span class="built_in">return</span> &#123;0 : x, 1 : y&#125; &#125;</span><br><span class="line">cy# <span class="keyword">function</span> CGSizeMake(w, h) &#123; <span class="built_in">return</span> &#123;0 : w, 1 : h&#125; &#125;</span><br><span class="line">cy# <span class="keyword">function</span> CGRectMake(x, y, w, h) &#123; <span class="built_in">return</span> &#123;0 : CGPointMake(x, y), 1 : CGSizeMake(w, h) &#125; &#125;</span><br><span class="line">cy# var rect2 = CGRectMake(160, 100, 100, 60)</span><br><span class="line">&#123;0:&#123;0:160,1:100&#125;,1:&#123;0:100,1:60&#125;&#125;</span><br><span class="line">cy# var redView = [[UIView alloc] initWithFrame:rect2]</span><br><span class="line"><span class="comment">#&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span></span><br><span class="line">cy# redView.backgroundColor = [UIColor redColor]</span><br><span class="line"><span class="comment">#&quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;</span></span><br><span class="line">cy# [UIApp.keyWindow addSubview:redView]</span><br></pre></td></tr></table></figure>

<p>我们定义了 CGPointMake(),CGSizeMake(),CGRectMake() 三个函数实现了类似的功能。并使用 CGRectMake() 创建了一个新的红色视图 <code>redView</code> 并添加到了 <code>keyWindow</code> 上。</p>
<p>APP 显示如下：</p>
<p align=center><img src="Cycript/1dba7f979c874e118ab93d948e241b1f~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0111.PNG" width="30%" /></p>

<h2 id="内存地址"><a href="#内存地址" class="headerlink" title="#内存地址"></a>#内存地址</h2><p>使用 #内存地址 获取内存地址所在的对象。比如我们刚刚创建的 redView ，这是我们创建的变量所以可以直接使用 redView 变量获取对象，但是在平时调试过程中我们很少会创建变量，而是通过打印输出很多对象的内存地址，通过 # 符号获取这个对象。使用 #内存地址 修改我们刚刚创建的 redView 的大小的代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0x107610070.backgroundColor = [UIColor orangeColor]</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们的 redView 的背景色被修改为橙色了。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="*对象"></a>*对象</h2><p>使用 * 号加对象，会打印出对象的所有成员变量名和对应的值。以我们刚刚修改的 redView 为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# *#0x107610070</span><br><span class="line">&#123;isa:UIView,_responderFlags:@error,_constraintsExceptingSubviewAutoresizingConstraints:null,_cachedTraitCollection:#<span class="string">&quot;&lt;UITraitCollection: 0x2814e8620; UserInterfaceIdiom = Phone, DisplayScale = 3, DisplayGamut = P3, HorizontalSizeClass = Compact, VerticalSizeClass = Regular, UserInterfaceStyle = Light, UserInterfaceLayoutDirection = LTR, ForceTouchCapability = Available, PreferredContentSizeCategory = XS, AccessibilityContrast = Normal, UserInterfaceLevel = Base&gt;&quot;</span>,_animationInfo:null,_layer:#<span class="string">&quot;&lt;CALayer: 0x282de62e0&gt;&quot;</span>,_layerRetained:null,_gestureRecognizers:null,_window:#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,_subviewCache:@[],_viewDelegate:null,_cachedScreenScale:new Number&#123;&#125;,_layoutEngineWidth:new Number&#123;&#125;,_viewFlags:@error,_unsatisfiableConstraintsLoggingSuspensionCount:0,_pseudo_id:8,_retainCount:new Number&#123;&#125;,_draggingSourceDelegate:null,_tintAdjustmentDimmingCount:0,_layoutSubviewsCount:0,_imminentLayoutSubviewsCount:0,_countOfFocusedAncestorTrackingViewsInSubtree:0,_layoutMarginsGuide:null,_minXVariable:null,_minYVariable:null,_boundsWidthVariable:null,_boundsHeightVariable:null,_layoutEngine:null,_stashedLayoutVariableObservations:null,_internalConstraints:null,_safeAreaLayoutGuide:null,_keyboardLayoutGuide:null,_readableContentGuide:null,__preferedContentsFormat:new Number&#123;&#125;,__lastNotifiedTraitCollection:#<span class="string">&quot;&lt;UITraitCollection: 0x2814e41c0; UserInterfaceIdiom = Phone, DisplayScale = 3, DisplayGamut = P3, HorizontalSizeClass = Compact, VerticalSizeClass = Regular, UserInterfaceStyle = Light, UserInterfaceLayoutDirection = LTR, ForceTouchCapability = Available, PreferredContentSizeCategory = XS, AccessibilityContrast = Normal, UserInterfaceLevel = Base&gt;&quot;</span>,__alignmentRectOriginCache:null,_rawLayoutMargins:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;,_inferredLayoutMargins:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;,_safeAreaInsets:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归打印层级结构"><a href="#递归打印层级结构" class="headerlink" title="递归打印层级结构"></a>递归打印层级结构</h2><h3 id="递归打印视图层级结构"><a href="#递归打印视图层级结构" class="headerlink" title="递归打印视图层级结构"></a>递归打印视图层级结构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.recursiveDescription()</span><br><span class="line">@<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;\n   | &lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;\n   |    | &lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;\n   |    |    | &lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;\n   | &lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;\n   | &lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>会发现打印的字符串中有很多 \n 符号并没有真正的换行。可以使用 <code>toString()</code> 函数让 \n 真正的换行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.recursiveDescription().toString()</span><br><span class="line">`&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;</span><br><span class="line">   | &lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;</span><br><span class="line">   |    | &lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;</span><br><span class="line">   |    |    | &lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;`</span><br></pre></td></tr></table></figure>

<p>这样看起来就清晰多了。</p>
<h3 id="递归打印根控制器的层级结构"><a href="#递归打印根控制器的层级结构" class="headerlink" title="递归打印根控制器的层级结构"></a>递归打印根控制器的层级结构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.rootViewController._printHierarchy().toString()</span><br><span class="line"><span class="string">&quot;&lt;ViewController 0x1045049f0&gt;, state: appeared, view: &lt;UIView 0x107607070&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于我们的 CycriptDemo APP 中只有一个根视图控制器，所以只能看到这样的打印。</p>
<h3 id="递归打印自动布局信息"><a href="#递归打印自动布局信息" class="headerlink" title="递归打印自动布局信息"></a>递归打印自动布局信息</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow._autolayoutTrace().toString()</span><br><span class="line">`</span><br><span class="line">UIWindow:0x1045057e0</span><br><span class="line">|   UITransitionView:0x1076068d0</span><br><span class="line">|   |   UIDropShadowView:0x102e07170</span><br><span class="line">|   |   |   UIView:0x107607070</span><br><span class="line">|   UIView:0x10450a690</span><br><span class="line">|   UIView:0x107610070</span><br><span class="line"></span><br><span class="line">Legend:</span><br><span class="line">\t* - is laid out with auto layout</span><br><span class="line">\t+ - is laid out manually, but is represented <span class="keyword">in</span> the layout engine because translatesAutoresizingMaskIntoConstraints = YES</span><br><span class="line">\t\u2022 - layout engine host`</span><br></pre></td></tr></table></figure>
<p>这里出现了一些不该显示的 \t 字符，猜测可能是解析字符串的时候出了点问题，在打印对象的 <code>_ivarDescription</code> 和 <code>_methodDescription</code> 的时候也会出现。可惜 Cycript 的作者已经停止更新了。。。</p>
<h2 id="choose-查询类或其子类的实例对象"><a href="#choose-查询类或其子类的实例对象" class="headerlink" title="choose 查询类或其子类的实例对象"></a>choose 查询类或其子类的实例对象</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# choose(UIView)</span><br><span class="line">[#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045065a0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d230&gt;; layer = &lt;CALayer: 0x282dd9ea0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045070e0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d1a0&gt;; layer = &lt;CALayer: 0x282dda100&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="tab-键自动补全代码"><a href="#tab-键自动补全代码" class="headerlink" title="tab 键自动补全代码"></a>tab 键自动补全代码</h2><p>在输入代码的时候，可以尝试使用 tab 键进行自动补全或者代码提示。在输入的代码足够分析出正确的完整代码的时候按一次 tab 键会自动补全，在输入的代码不足以分析出正确的代码的时候按两下 tab 键会给出所有可能得提示，在输入的代码完全不够解析的时候终端会有声音提醒，再多输入几个字符试试就好了。我们以对象的私有方法或成员变量（以下划线_开头）为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# choose(UIView)</span><br><span class="line">[#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045065a0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d230&gt;; layer = &lt;CALayer: 0x282dd9ea0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045070e0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d1a0&gt;; layer = &lt;CALayer: 0x282dda100&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;&quot;</span>]</span><br><span class="line">cy# <span class="comment">#0x107610070._</span></span><br><span class="line">Display all 501 possibilities? (y or n)</span><br><span class="line">cy# <span class="comment">#0x107610070._lay</span></span><br><span class="line">_layer()                                           _layoutEngine                                      _layoutEngineRelativeAlignmentRectOriginIsValid()  _layoutRect()</span><br><span class="line">_layoutDebuggingIdentifier                         _layoutEngineCreateIfNecessary()                   _layoutHeightDependsOnWidth                        _layoutVariablesWithAmbiguousValue()</span><br><span class="line">_layoutDebuggingTitle()                            _layoutEngineHostConstraints()                     _layoutMarginsGuideIfExists()</span><br><span class="line">_layoutDescriptionIfDifferentFromDefault()         _layoutEngineIfAvailable()                         _layoutMarginsGuideIgnoresSystemMinimumMargins</span><br><span class="line">cy# <span class="comment">#0x107610070._lay</span></span><br></pre></td></tr></table></figure>

<p>首先使用 choose 查询 UIView 或其子类的实例对象。选取其中的一个 #0x107610070 ，输入 ._ 之后会出现提示显示所有 501 个可能的结果？输入 y 表示显示，n 不显示。501 个结果太多了，我选择不显示，继续输入 lay 之后按两下 tab 键由于数量不是很多于是直接将所有可能得结果都显示出来了。这个功能我只能说🐂🍺</p>
<h1 id="cycript-高级用法"><a href="#cycript-高级用法" class="headerlink" title="cycript 高级用法"></a>cycript 高级用法</h1><p>我们刚刚创建了几个变量和函数，这些变量和函数都的确处于进程的内存当中，但是当 APP 进程被杀掉重新启动的时候，我们创建的变量和函数就都会消失。如果我们需要在每次进入交互环境的时候，重新辛辛苦苦编写重复的函数代码那可就太折磨人了。</p>
<p>Cycript 作者早就想到了这样的情况，所以它支持从文件加载自己的脚本。首先编写好 Cycript 的 .cy 文件，我们 tool.cy 为例。.cy 文件使用的是 JavaScript 语法，所以没有相关背景知识的开发人员编写起来可能会感到很困难。没错，作者本人就是如此，为了实现了一个函数并让它按照预期运行就经受了一番痛苦的折磨。。。这里参考了 MJ 大神的一些<a href="https://github.com/CoderMJLee/mjcript">源码</a>，并对其中个人感觉不是很实用的进行了删减，对一些做了修改。同时对 @import 方式进行了优化，在 @import 的时候，会给出 .cy 文件中的一些关键信息，这样就不用去记忆一些变量和函数名。同时也省去了需要使用文件名.才能调用函数的麻烦（这里是参考了 AloneMonkey 大神的写法）。</p>
<h2 id="编写-cy-文件"><a href="#编写-cy-文件" class="headerlink" title="编写 .cy 文件"></a>编写 .cy 文件</h2><p>tool.cy 文件源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">tool</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t = tool.<span class="property">constants</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJPointMake</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : x, <span class="number">1</span> : y&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJSizeMake</span> = <span class="keyword">function</span>(<span class="params">w, h</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : w, <span class="number">1</span> : h&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJRectMake</span> = <span class="keyword">function</span>(<span class="params">x, y, w, h</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : <span class="title class_">MJPointMake</span>(x, y), <span class="number">1</span> : <span class="title class_">MJSizeMake</span>(w, h)&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 bundleIdentifier</span></span><br><span class="line">	t.<span class="property">bundleId</span> = [[<span class="title class_">NSBundle</span> mainBundle] bundleIdentifier];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回安装包路径</span></span><br><span class="line">	t.<span class="property">bundlePath</span> = [[<span class="title class_">NSBundle</span> mainBundle] bundlePath];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJFrontVc = <span class="keyword">function</span>(<span class="params">vc</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vc.<span class="property">presentedViewController</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">presentedViewController</span>);</span><br><span class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([vc <span class="attr">isKindOfClass</span>:[<span class="title class_">UITabBarController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">selectedViewController</span>);</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([vc <span class="attr">isKindOfClass</span>:[<span class="title class_">UINavigationController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">visibleViewController</span>);</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	<span class="keyword">var</span> count = vc.<span class="property">childViewControllers</span>.<span class="property">count</span>;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">var</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    			<span class="keyword">var</span> childVc = vc.<span class="property">childViewControllers</span>[i];</span><br><span class="line">    			<span class="keyword">if</span> (childVc &amp;&amp; childVc.<span class="property">view</span>.<span class="property">window</span>) &#123;</span><br><span class="line">    				vc = <span class="title function_">_MJFrontVc</span>(childVc);</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">	        <span class="keyword">return</span> vc;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回最靠近用户的控制器</span></span><br><span class="line">	t.<span class="property">frontVc</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(<span class="title class_">UIApp</span>.<span class="property">keyWindow</span>.<span class="property">rootViewController</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJIsString</span> = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">typeof</span> str == <span class="string">&#x27;string&#x27;</span> || str <span class="keyword">instanceof</span> <span class="title class_">String</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJClass = <span class="keyword">function</span>(<span class="params">className</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!className) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(missingParamStr);</span><br><span class="line">		<span class="keyword">if</span> (<span class="title class_">MJIsString</span>(className)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title class_">NSClassFromString</span>(className);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> (!className) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(invalidParamStr);</span><br><span class="line">		<span class="comment">// 对象或者类</span></span><br><span class="line">		<span class="keyword">return</span> className.<span class="title function_">class</span>();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 className 的所有子类，reg 正则过滤</span></span><br><span class="line">	t.<span class="property">subclassesWith</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		className = <span class="title function_">_MJClass</span>(className);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> [c <span class="keyword">for</span> <span class="title function_">each</span> (c <span class="keyword">in</span> <span class="title class_">ObjectiveC</span>.<span class="property">classes</span>) </span><br><span class="line">		<span class="keyword">if</span> (c != className </span><br><span class="line">			&amp;&amp; <span class="title function_">class_getSuperclass</span>(c) </span><br><span class="line">			&amp;&amp; [c <span class="attr">isSubclassOfClass</span>:className] </span><br><span class="line">			&amp;&amp; (!reg || reg.<span class="title function_">test</span>(c)))</span><br><span class="line">			];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取按钮的 TouchUpInsideEvent 的 target 和 actions</span></span><br><span class="line">	t.<span class="property">touchUpInsideTargetAndActionWith</span> = <span class="keyword">function</span>(<span class="params">btn</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (![btn <span class="attr">isKindOfClass</span>:[<span class="title class_">UIControl</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;invalid parameter type,must be kind of UIControl class&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">var</span> allTargets = [[btn allTargets] allObjects];</span><br><span class="line">    	<span class="keyword">var</span> dict = [<span class="title class_">NSMutableDictionary</span> dictionary];</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allTargets.<span class="property">count</span>; i++) &#123;</span><br><span class="line">    		<span class="keyword">var</span> actions = [btn <span class="attr">actionsForTarget</span>:allTargets[i] <span class="attr">forControlEvent</span>:<span class="title class_">UIControlEventTouchUpInside</span>];</span><br><span class="line">    		[dict <span class="attr">setValue</span>:actions <span class="attr">forKey</span>:[allTargets[i] description]];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dict;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJGetMethods = <span class="keyword">function</span>(<span class="params">className, reg, clazz</span>) &#123;</span><br><span class="line">		className = <span class="title function_">_MJClass</span>(className);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> count = <span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Type</span>(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">		<span class="keyword">var</span> classObj = clazz ? className.<span class="property">constructor</span> : className;</span><br><span class="line">		<span class="keyword">var</span> methodList = <span class="title function_">class_copyMethodList</span>(classObj, count);</span><br><span class="line">		<span class="keyword">var</span> methodsArray = [];</span><br><span class="line">		<span class="keyword">var</span> methodNamesArray = [];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; *count; i++) &#123;</span><br><span class="line">			<span class="keyword">var</span> method = methodList[i];</span><br><span class="line">			<span class="keyword">var</span> selector = <span class="title function_">method_getName</span>(method);</span><br><span class="line">			<span class="keyword">var</span> name = <span class="title function_">sel_getName</span>(selector);</span><br><span class="line">			<span class="keyword">if</span> (reg &amp;&amp; !reg.<span class="title function_">test</span>(name)) <span class="keyword">continue</span>;</span><br><span class="line">			methodsArray.<span class="title function_">push</span>(&#123;</span><br><span class="line">				selector : selector, </span><br><span class="line">				type : <span class="title function_">method_getTypeEncoding</span>(method)</span><br><span class="line">			&#125;);</span><br><span class="line">			methodNamesArray.<span class="title function_">push</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">free</span>(methodList);</span><br><span class="line">		<span class="keyword">return</span> [methodsArray, methodNamesArray];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> _MJMethods = <span class="keyword">function</span>(<span class="params">className, reg, clazz</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJGetMethods</span>(className, reg, clazz)[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印对象方法</span></span><br><span class="line">	t.<span class="property">instanceMethods</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJMethods</span>(className, reg);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印类方法</span></span><br><span class="line">	t.<span class="property">classMethods</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJMethods</span>(className, reg, <span class="literal">true</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印响应者</span></span><br><span class="line">	t.<span class="property">rp</span> = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> result = <span class="string">&quot;&quot;</span> + target.<span class="title function_">toString</span>();</span><br><span class="line">		<span class="keyword">while</span> (target.<span class="property">nextResponder</span>) &#123;</span><br><span class="line">			result += <span class="string">&quot;\n&quot;</span> + target.<span class="property">nextResponder</span>.<span class="title function_">toString</span>();</span><br><span class="line">			target = target.<span class="property">nextResponder</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> tool.<span class="property">constants</span>) &#123;</span><br><span class="line">		<span class="title class_">Cycript</span>.<span class="property">all</span>[k] = tool.<span class="property">constants</span>[k];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">exports</span>);</span><br></pre></td></tr></table></figure>

<h2 id="越狱环境下使用-cy-文件"><a href="#越狱环境下使用-cy-文件" class="headerlink" title="越狱环境下使用 .cy 文件"></a>越狱环境下使用 .cy 文件</h2><p>在越狱环境下，可以将编写好的 tool.cy 文件放到 <code>/usr/lib/cycript0.9/com/masterking</code> 目录下。这里的 masterking 是文件夹名，你可以自己创建一个文件夹换成你想要的名字。Cycript 成功附加到 APP 进程之后，使用以下命令就可以导入该文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# @import com.masterking.tool</span><br><span class="line">&#123;constants:&#123;bundleId:@<span class="string">&quot;com.masterking.CycriptDemo&quot;</span>,bundlePath:@<span class="string">&quot;/var/containers/Bundle/Application/85010A56-FF88-4EDE-A9CA-BA5C76638197/CycriptDemo.app&quot;</span>,frontVc:<span class="function"><span class="title">function</span></span> ()&#123;<span class="built_in">return</span> s(UIApp.keyWindow.rootViewController)&#125;,subclassesWith:<span class="keyword">function</span> (r,i)&#123;r=d(r);<span class="built_in">return</span> <span class="keyword">function</span>(n,t)&#123;var e;n=[];&#123;e=ObjectiveC.classes;<span class="keyword">for</span>(t <span class="keyword">in</span> e)&#123;t=e[t];<span class="keyword">if</span>(t!=r&amp;&amp;class_getSuperclass(t)&amp;&amp;objc_msgSend(t,<span class="string">&quot;isSubclassOfClass:&quot;</span>,r)&amp;&amp;(!i||i.test(t)))n.push(t)&#125;&#125;<span class="built_in">return</span> n&#125;()&#125;,touchUpInsideTargetAndActionWith:<span class="keyword">function</span> (r)&#123;var e,t,n,i;<span class="keyword">if</span>(!objc_msgSend(r,<span class="string">&quot;isKindOfClass:&quot;</span>,objc_msgSend(UIControl,<span class="string">&quot;class&quot;</span>)))&#123;throw new Error(<span class="string">&quot;invalid parameter type,must be kind of UIControl class&quot;</span>)&#125;i=objc_msgSend(objc_msgSend(r,<span class="string">&quot;allTargets&quot;</span>),<span class="string">&quot;allObjects&quot;</span>);n=objc_msgSend(NSMutableDictionary,<span class="string">&quot;dictionary&quot;</span>);<span class="keyword">for</span>(e=0;e&lt;i.count;e++)&#123;t=objc_msgSend(r,<span class="string">&quot;actionsForTarget:forControlEvent:&quot;</span>,i[e],UIControlEventTouchUpInside);objc_msgSend(n,<span class="string">&quot;setValue:forKey:&quot;</span>,t,objc_msgSend(i[e],<span class="string">&quot;description&quot;</span>))&#125;<span class="built_in">return</span> n&#125;,instanceMethods:<span class="keyword">function</span> (t,e)&#123;<span class="built_in">return</span> i(t,e)&#125;,classMethods:<span class="keyword">function</span> (t,e)&#123;<span class="built_in">return</span> i(t,e,!0)&#125;,rp:<span class="keyword">function</span> (t)&#123;var e;e=<span class="string">&quot;&quot;</span>+t.toString();<span class="keyword">while</span>(t.nextResponder)&#123;e+=<span class="string">&quot;\n&quot;</span>+t.nextResponder.toString();t=t.nextResponder&#125;<span class="built_in">return</span> e&#125;&#125;&#125;</span><br><span class="line">cy# frontVc()</span><br><span class="line"><span class="comment">#&quot;&lt;ViewController: 0x10f119400&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到输出了 tool.cy 中的源码，这样不必要记忆函数名和变量名，写好了导入就可以直接使用，也不需要使用 tool.frontVc() 调用函数，直接 frontVc() 就可以调用，同时还可以使用 tab 键补全函数代码。</p>
<h2 id="非越狱环境下使用-cy-文件"><a href="#非越狱环境下使用-cy-文件" class="headerlink" title="非越狱环境下使用 .cy 文件"></a>非越狱环境下使用 .cy 文件</h2><h3 id="逆向开发的情况使用-cy-文件"><a href="#逆向开发的情况使用-cy-文件" class="headerlink" title="逆向开发的情况使用 .cy 文件"></a>逆向开发的情况使用 .cy 文件</h3><p>在非越狱环境下进行逆向开发，首先推荐的肯定是 AloneMonkey 的 <a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a> 工具提供了 Xcode 工程模板，可以像正向开发那样方便的使用 Xcode 在未越狱环境进行逆向开发。由于也是很多年没有更新了，没有适配最近的几个 Xcode 版本导致可能无法成功安装。看到 Fork 里有人适配了 Xcode 13 ，使用 Xcode 13 的可以试试。由于我本人使用的是 Xcode 14.3.1 所以就没有尝试，由于之前的 Xcode 可以成功安装，于是我下载了旧版本的 Xcode 好像是 12.4。安装到了 Mac 13.5 上，会显示无法打开。不需要打开使用，直接运行 MonkeyDev 安装脚本根据提示安装，然后还是修改了 md-install 脚本之后，再升级到最新的 Xcode 版本经过一番折腾，终于算是用上了。</p>
<img src="/2023/08/23/Cycript/4246583878e94515b9949784d0d5d9ce~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>MonkeyApp 工程默认就集成了 cycript 库到项目中，经过我的观察好像不是使用的 Cycript.framework 的方式，但是也能通过 cycript 连接成功。使用自己的 .cy 文件的方式有两种，一种是使用 MDConfig.plist 配置文件，在其中添加自己的 .cy 文件配置。这个配置文件也很简单，需要一个 url 就行了，配置一个本地环境的 url 也可以。或者直接将 cy 代码复制到 content 中(这种我没试过，感兴趣的可以自己试试) 这两种方式不需要自己再手动 @import 导入 tool.cy 文件，非常省事。</p>
<img src="/2023/08/23/Cycript/cf16fa5d3acb4cc982cd6b536b97f03d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>另一种就是手动将 tool.cy 文件拖进项目中。</p>
<img src="/2023/08/23/Cycript/f411a3d535084fdba616bdfd5f167961~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>然后再进入 cycript 交互环境的时候，手动 @import 导入一下，如下图：</p>
<img src="/2023/08/23/Cycript/cb8b5096ea8a4e0e83ab321131a31f88~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h3 id="正向开发的情况使用-cy-文件"><a href="#正向开发的情况使用-cy-文件" class="headerlink" title="正向开发的情况使用 .cy 文件"></a>正向开发的情况使用 .cy 文件</h3><p>在非越狱环境正向开发的情况下，原以为可以将 tool.cy 文件打包进 APP 的安装包中之后就可以 @import 导入了。万万没有想到并没有这么简单，不确定是哪里出了问题，如果有知道的大神可以在评论区交流一下。会报以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# @import tool</span><br><span class="line">throw new TypeError&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>最关键的信息在{}里面没有显示。。。也没办法了</p>
<h1 id="cycript-实战"><a href="#cycript-实战" class="headerlink" title="cycript 实战"></a>cycript 实战</h1><p>能看到这里的人一定都是热爱学习的人，这里给大家准备了一个惊喜，使用 cycript 绕过某付费直播 APP 观看限制。为了防止有人说我打广告嫌疑和规避法律责任，这里不会明确是哪个 APP 并在此声明<strong>本文案例供技术交流，禁止用于商业及非法用途，如产生法律纠纷与本人无关。</strong>。</p>
<p>APP 图标大概长这样：</p>
<p align=center><img src="Cycript/47c8b94fb8c94609967e486c351a4001~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="Xnip2023-08-23_18-15-42.png"  /></p>

<p>下载好 APP 之后，进入 APP 的包里面，发现干净的很，分析一下原来是 Flutter 项目生成的 iOS APP。Flutter 项目也没关系，不管是什么技术，只要你需要兼容 iOS 平台，就绕不开 iOS 的技术栈 Cocoa touch 框架。</p>
<p align=center><img src="Cycript/6b877efc8b264d7ea6dcf4855c6f3580~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="70%" /></p>

<p>启动 APP，进入某个直播间发现有一个 30 秒的倒计时之后便出现了如下界面。</p>
<p align=center><img src="Cycript/d9b7a7ec1161497a9c1d643ce9cff150~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="30%" /></p>

<p>打开终端，使用 cycript 远程附加到 APP 上。递归打印出当前 APP 的界面层级结构：</p>
<img src="/2023/08/23/Cycript/414b7f2551dc49c48e3f4a37438d17f9~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>根据经验，推测绿框中的视图应该就是弹出来的视图，让它隐藏之后你就会看到你想要看的东西了😛。。。当然目前这种做法只不过是在内存中修改了视图的 hidden 属性，如果想要做到永久的修改 APP 的逻辑，还需要学习更多的内容，我会在接下来的时间里陆续更新内容，敬请期待。也欢迎感兴趣的开发者共同学习，一起交流。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>Calendar 和 Reminders 编程指南</title>
    <url>/2021/09/24/Calendar-%E5%92%8C-Reminders-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>最近的项目需要用到 EventKit 来实现，于是在官网找到了这篇文章，虽然属于老文档了，但是对于需要接入 EventKit 的人来说还是有必要了解一下的。最新的文档也只是在这个基础上做了些更新，对于英语好的读者，完全可以直接看 <a href="https://developer.apple.com/library/archive/documentation/DataManagement/Conceptual/EventKitProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004759-SW1">官网介绍</a>就好了，我这里是对官方文档的一遍翻译，再加上自己实践的一点点内容。</p>
<h1 id="介绍-Calendars-和-Reminders"><a href="#介绍-Calendars-和-Reminders" class="headerlink" title="介绍 Calendars 和 Reminders"></a>介绍 Calendars 和 Reminders</h1><p>EventKit 框架帮助您访问用户的日历和提醒信息。虽然两个不同的应用程序显示用户的日历和提醒数据，但操作数据的框架是相同的。类似地，存储该数据的数据库(称为 Calendar 数据库)同时保存日历和提醒信息。</p>
<p>EventKit architecture</p>
<img src="/2021/09/24/Calendar-%E5%92%8C-Reminders-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/fef9077ce10b4ef9a8aeac41192992d2~tplv-k3u1fbpfcp-zoom-1.png" class="">

<blockquote>
<p>重要： iOS10.0 及之后的 APP 必须在它们的 Info.plist 文件中配置需要访问这些数据的使用说明，否则 APP 将会崩溃。来访问 Calendars 和 Reminders 数据，Info.plist 必须分别包含 NSRemindersUsageDescription 和 NSCalendarsUsageDescription 这两个键。</p>
</blockquote>
<p>EventKit 不仅允许你的应用程序检索用户现有的日历和提醒数据，它也可以让你的应用程序为任何日历创建新的事件和提醒。此外，EventKit还允许用户编辑和删除他们的事件和提醒(统称为“日历项”)。更高级的任务，如添加闹铃或指定重复事件，也可以通过 EventKit 实现。如果你的应用程序外部发生了日历数据库的变化，EventKit 能够通过通知检测到变化，这样你的应用程序就可以适当地运行。使用 EventKit 对日历项所做的更改会自动同步到相关的日历(CalDAV, Exchange，等等)。</p>
<p>本文档描述了 EventKit 的概念和常见的编程任务。如果你想在应用程序中显示或编辑日历事件和&#x2F;或提醒数据，你应该阅读本文档。EventKit  提供对用户日历数据库的有限访问。它不包括实现一个功能齐全的日历或提醒应用程序所需的所有内容，比如添加与会者或账户。</p>
<h2 id="At-a-Glance"><a href="#At-a-Glance" class="headerlink" title="At a Glance"></a>At a Glance</h2><p>本文档包含以下章节，描述了如何在应用程序中集成用户的日历和提醒数据:</p>
<ul>
<li>读和写日历事件：说明如何检索、创建和修改日历事件。</li>
<li>读和写提醒：说明如何检索、创建和修改提醒。</li>
<li>配置闹铃：说明如何将闹铃附加到日程表项目。</li>
<li>创建重复事件：解释如何将事件设置为重复事件。</li>
<li>观察日历数据库的外部更改：说明如何注册与 Calendar 数据库的外部更改有关的通知</li>
<li>为事件提供接口：说明如何显示事件视图控制器以允许用户创建和编辑事件</li>
</ul>
<h1 id="读和写日历事件"><a href="#读和写日历事件" class="headerlink" title="读和写日历事件"></a>读和写日历事件</h1><p>您可以使用 <code>EKEventStore</code> 类从用户的 Calendar 数据库中获取、创建、编辑和删除事件。您可以获取与您提供的谓词匹配的自定义事件集，也可以通过其惟一标识符获取单个事件。获取事件后，可以通过<code>EKEvent</code>类的属性访问其关联的日历信息。同样，您可以通过设置<code>EKEvent</code>类的属性来修改它的日历信息。</p>
<blockquote>
<p>重要：iOS10.0 之后的 APP，如果需要访问日历数据，需要在你的 APP 的 Info.plist 文件中包含 NSCalendarsUsageDescription 的键，说明写不写都不重要，不过为了更好的用户体验建议写上</p>
</blockquote>
<h2 id="连接到-Event-Store"><a href="#连接到-Event-Store" class="headerlink" title="连接到 Event Store"></a>连接到 Event Store</h2><p>使用指定的初始化器初始化一个 <code>EKEventStore</code> 对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">EKEventStore *store = [[EKEventStore alloc] initWithAccessToEntityTypes:EKEntityMaskEvent];</span><br></pre></td></tr></table></figure>

<p>实践发现上面的初始化方式已经废弃了，而且仅在 MacOS10.8-10.9 可用。现在使用直接 alloc，init 初始化就行了。初始化 <code>EKEventStore</code> 后，在试图获取或创建实体类型的数据之前，必须调用 <code>requestAccessToEntityType:completion:</code>。</p>
<p>一个 <code>EKEventStore</code> 对象需要相当多的时间来初始化和释放，因此，不应该为每个与事件相关的任务初始化和释放单独的 <code>EKEventStore</code> 对象。相反，在应用程序加载时初始化单个 <code>EKEventStore</code> 对象，并重复使用它，以确保您的连接是长期的。</p>
<p><code>EKEventStore</code> 对象不能在其他 EventKit 对象之前被释放。否则，可能会出现未知的行为。</p>
<h2 id="检索事件"><a href="#检索事件" class="headerlink" title="检索事件"></a>检索事件</h2><p>检索事件有两种方法</p>
<ul>
<li>通过谓词或搜索查询进行的获取将返回零个或多个与给定查询匹配的事件。</li>
<li>通过唯一标识符获取将返回与给定标识符对应的单个事件。</li>
</ul>
<blockquote>
<p>请注意：从 Calendar 数据库检索事件并不一定会按时间顺序返回事件。要按日期对一个 EKEvent 对象数组排序，在数组中调用 <code>sortedArrayUsingSelector:</code>，为 <code>compareStartDateWithEvent:</code> 方法提供选择器。</p>
</blockquote>
<h3 id="使用谓词"><a href="#使用谓词" class="headerlink" title="使用谓词"></a>使用谓词</h3><p>获取日期范围内的事件是很常见的。<code>EKEventStore</code> 方法 <code>eventsMatchingPredicate:</code> 获取在你提供的谓词中指定的日期范围内的所有事件。以下代码演示了如何获取当前日期前一天到之后一年之间发生的所有事件。</p>
<blockquote>
<p>请注意：尽管 <code>eventsMatchingPredicate:</code> 方法接受 <code>NSPredicate</code> 类型的参数，但你必须提供一个由 <code>EKEventStore</code> 方法 <code>predicateForEventsWithStartDate:endDate:calendar:</code> 创建的谓词。</p>
</blockquote>
<p>使用谓词获取事件代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSCalendar</span> *calendar = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDateComponents</span> *oneDayAgoComponents = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">    oneDayAgoComponents.day = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">NSDate</span> *oneDayAgo = [calendar dateByAddingComponents:oneDayAgoComponents</span><br><span class="line">                                                  toDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                                                 options:<span class="number">0</span>];</span><br><span class="line">                                             </span><br><span class="line">    <span class="built_in">NSDateComponents</span> *oneYearFromNorComponents = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">    oneYearFromNorComponents.year = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSDate</span> *oneYearFromNow = [calendar dateByAddingComponents:oneYearFromNorComponents</span><br><span class="line">                                                       toDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                                                      options:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    EKEventStore *store = [(AppDelegate *)<span class="built_in">UIApplication</span>.sharedApplication.delegate eventStore];</span><br><span class="line">    <span class="built_in">NSPredicate</span> *predicate = [store predicateForEventsWithStartDate:oneDayAgo</span><br><span class="line">                                                            endDate:oneYearFromNow</span><br><span class="line">                                                          calendars:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *events = [store eventsMatchingPredicate:predicate];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%zd,%@&quot;</span>,events.count,events);</span><br></pre></td></tr></table></figure>

<p>通过传递一个 EKCalendar 对象数组作为 <code>predicateForEventsWithStartDate:endDate:calendar:</code> 方法的日历参数，可以指定要搜索的日历子集。您可以从 <code>EKEventStore</code> 对象的 <code>calendarsForEntityType:</code> 方法中获取用户的日历。传递 <code>kNilOptions</code> 告诉方法从用户的所有日历中获取。</p>
<p>因为 <code>eventsMatchingPredicate:</code> 方法是同步的，所以你可能不想在应用的主线程上运行它。对于异步行为，使用 <code>dispatch_async</code> 函数或 <code>NSOperation</code> 对象在另一个线程上运行该方法。</p>
<h3 id="使用惟一标识符"><a href="#使用惟一标识符" class="headerlink" title="使用惟一标识符"></a>使用惟一标识符</h3><p>如果您之前通过谓词获取到了事件的唯一标识符，那么您可以使用 <code>EKEventStore</code> 对象的方法 <code>eventWithIdentifier:</code> 来获取事件。如果是循环事件，此方法将返回该事件的第一次出现。您可以使用 <code>eventIdentifier</code> 属性获得事件的唯一标识符。</p>
<h2 id="创建和编辑事件"><a href="#创建和编辑事件" class="headerlink" title="创建和编辑事件"></a>创建和编辑事件</h2><blockquote>
<p>注意:如果你是在 iOS 上开发，你可以选择让用户使用 EventKit UI 框架提供的事件视图控制器修改事件数据。有关如何使用这些事件视图控制器的信息，请参见为事件提供接口。</p>
</blockquote>
<p>使用 EKEvent 类的 eventWithEventStore: 方法创建一个新事件。</p>
<p>您可以编辑事件的细节通过设置事件的相应属性，不管是新创建的事件，还是之前从日历数据库中获取到的事件。你可以编辑的一些细节包括以下几个方法：</p>
<ul>
<li><code>title</code> 属性，编辑事件的标题</li>
<li><code>startDate</code> 和 <code>endDate</code> 属性，编辑事件的开始日期和结束日期</li>
<li><code>calendar</code> 属性，编辑与事件相关联的日历</li>
<li><code>alarms</code> 属性，编辑与事件相关联的警报（有关详细信息，请看后面的配置警报）</li>
<li><code>recurrenceRules</code> 属性，编辑事件的循环规则（如果它是一个重复事件，有关更多细节，请看后面的创建重复事件）</li>
</ul>
<h2 id="保存和删除事件"><a href="#保存和删除事件" class="headerlink" title="保存和删除事件"></a>保存和删除事件</h2><blockquote>
<p>重要提示:如果你的应用修改了用户的日历数据库，那么它必须在修改之前得到用户的确认。如果没有用户的特定指令，应用程序永远不应该修改日历数据库。</p>
</blockquote>
<p>在保存事件之前，对事件所做的更改不是永久的。通过 <code>EKEventStore</code> 的方法 <code>saveEvent:span:commit:error:</code> 保存你对事件的更改。如果你想从日历数据库中删除一条事件，使用 <code>EKEventStore</code> 的方法 <code>removeEvent:span:commit:error:</code>。无论您是保存还是删除事件，实现相应的方法都会自动将您的更改与事件所属的日历(CalDAV、Exchange等)同步。</p>
<p>如果您正在保存一个重复发生的事件，则您所做的更改可以应用于将来发生的所有事件，通过为 <code>saveEvent:span:commit:error:</code> 方法的 <code>span</code> 参数指定 <code>EKSpanFutureEvents</code>。同样地，你可以通过为 <code>removeEvent:span:commit:error:</code> 方法的 <code>span</code> 参数指定 <code>EKSpanFutureEvents</code> 来删除所有将来发生的事件</p>
<blockquote>
<p>注意:如果向 commit 参数传递 NO，请确保稍后调用 commit: 方法永久保存更改。意思是如果上面这些方法的 commit 参数你传了 NO，那么就需要在后面的代码手动调用 commit 方法来保存更改</p>
</blockquote>
<h2 id="对事件执行批量操作"><a href="#对事件执行批量操作" class="headerlink" title="对事件执行批量操作"></a>对事件执行批量操作</h2><p>你可以使用 <code>EKEventStore</code> 方法 <code>enumerateEventsMatchingPredicate</code> 对所有谓词匹配的事件执行操作:你必须通过 <code>EKEventStore</code> 的方法 <code>predicateForEventsWithStartDate:endDate:calendars:</code> 来创建上述方法中用到的谓词。你提供的操作是一个类型为 EKEventSearchCallback的Block。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^EKEventSearchCallback)(EKEvent *event, <span class="type">BOOL</span> *stop);</span><br></pre></td></tr></table></figure>

<p>block 被传递两个参数:<br></p>
<p>event<br><br>&emsp;&emsp;当前正在操作的事件。<br><br>stop<br><br>&emsp;&emsp;一个布尔值，确定</p>
<p><code>enumerateEventsMatchingPredicate:usingBlock:</code> 是否应该停止处理事件。如果是，则任何与谓词匹配但尚未处理的事件将保持未处理状态。</p>
<blockquote>
<p>重要提示:请记住，使用此方法可能会对用户的 Calendar 数据库造成重大更改。当您请求用户确认时，请确保用户完全了解将要执行的操作。</p>
</blockquote>
<p>因为 <code>enumerateEventsMatchingPredicate:usingBlock:</code> 方法是同步的，所以你可能不想在你的应用程序的主线程上运行它。对于异步行为，使用 <code>dispatch_async</code> 函数或 <code>NSOperation</code> 对象在另一个线程上运行该方法。</p>
<h1 id="读和写提醒"><a href="#读和写提醒" class="headerlink" title="读和写提醒"></a>读和写提醒</h1><p>提醒是与特定时间或地点相关联的任务。提醒是与特定时间或地点相关联的任务。它们类似于日历事件，但是可以标记为完成，并且不一定跨越一个确切的时间段。</p>
<p>因为 <code>EKReminder</code> 继承自 <code>EKCalendarItem</code>，所以你可以像处理事件一样对提醒执行相同的方法，比如使用 <code>addAlarm:</code> 添加一个告警，或者使用 <code>addRecurrenceRule:</code> 设置一个递归规则。</p>
<blockquote>
<p>重要提示:如果你的 iOS 应用链接在 iOS 10.0 或之后，你需要访问提醒数据，请确保在你的 Info.plist 文件中包含 NSRemindersUsageDescription 关键字</p>
</blockquote>
<h2 id="检索提示"><a href="#检索提示" class="headerlink" title="检索提示"></a>检索提示</h2><p>与事件一样，您必须首先建立到 <code>EKEventStore</code> 的连接，以访问现有提醒。如果尚未连接到 Event Store，请参见连接到 Event Store。</p>
<p>初始化连接并访问提醒，传递 <code>EKEntityMaskReminder</code> 而不是<code>EKEntityMaskEvent</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">EKEventStore *store = [[EKEventStore alloc] initWithAccessToEntityTypes:EKEntityMaskReminder];</span><br></pre></td></tr></table></figure>

<p>同样的，上面这段代码也是废弃了，直接创建<code>alloc init</code>创建 EKEventStore 对象就好了。</p>
<p>就像搜索事件一样，有两种方法可以检索提醒。</p>
<h3 id="使用谓词-1"><a href="#使用谓词-1" class="headerlink" title="使用谓词"></a>使用谓词</h3><p>你可以调用 <code>fetchRemindersMatchingPredicate:completion:</code> 来访问多个与谓词匹配的提醒。传递由下列方法返回的谓词:</p>
<ul>
<li><code>predicateForIncompleteRemindersWithDueDateStarting:ending:calendars:</code> 在可选的时间段内找到未完成的提醒</li>
<li><code>predicateForCompletedRemindersWithCompletionDateStarting:ending:calendars:</code> 在可选的时间段内找到完成的提醒</li>
<li><code>predicateForRemindersInCalendars:</code> 查找所有的提醒</li>
</ul>
<p>通过将 block 传递给 completion 参数，可以在匹配的提醒之间进行迭代，如下面代码所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *predicate = [store predicateForRemindersInCalendars:<span class="literal">nil</span>];</span><br><span class="line">    [store fetchRemindersMatchingPredicate:predicate completion:^(<span class="built_in">NSArray</span> *reminders) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EKReminder *reminder <span class="keyword">in</span> reminders) &#123;</span><br><span class="line">            <span class="comment">// do something for each reminder</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:与通过谓词获取事件不同(参见使用谓词)，您可以通过谓词异步获取提醒，而无需分派给另一个线程。如果你想通过谓词终止取回请求，调用 <code>cancelFetchRequest:</code>，参数是 <code>fetchRemindersMatchingPredicate:completion:</code> 返回的标识符。</p>
</blockquote>
<h3 id="使用惟一标识符-1"><a href="#使用惟一标识符-1" class="headerlink" title="使用惟一标识符"></a>使用惟一标识符</h3><p>如果您知道某个特定提醒的唯一标识符，那么您可以调用 <code>calendarItemWithIdentifier:</code> 对象方法。 <code>calendarItemWithIdentifier:</code> 可以获取任何日历项(提醒和事件)，而 <code>eventWithIdentifier:</code> 只获取事件。</p>
<h2 id="创建和编辑提醒"><a href="#创建和编辑提醒" class="headerlink" title="创建和编辑提醒"></a>创建和编辑提醒</h2><p>你可以使用 <code>EKReminder</code> 的 <code>reminderWithEventStore:</code> 类方法来创建提醒。标题和日历属性是必需的。提醒的日历属性是将其分组的列表。</p>
<p>像事件一样，提醒可以触发基于时间或位置的闹铃，提醒用户某项任务。有关如何将闹铃附加到日历项目的详细信息，请参阅配置闹铃。</p>
<p>要将开始日期或到期日期与提醒关联，请使用 <code>startDateComponents</code> 和 <code>dueDateComponents</code> 属性。要完成提醒，请将 completed 属性设置为 YES，它会自动将 completionDate 设置为当前日期。</p>
<h2 id="保存和删除提醒"><a href="#保存和删除提醒" class="headerlink" title="保存和删除提醒"></a>保存和删除提醒</h2><blockquote>
<p>重要提示:如果你的应用修改了用户的日历数据库，那么它必须在修改之前得到用户的确认。如果没有用户的特定指令，应用程序永远不应该修改日历数据库。</p>
</blockquote>
<p>提醒以类似于事件的方式保存。要将提醒保存到 Calendar 数据库，调用 <code>saveReminder:commit:error:</code> 方法。要删除一个事件，调用 <code>removeReminder:commit:error:</code> 方法。</p>
<p>记住，在保存提醒之前，必须显式设置标题和日历属性。</p>
<blockquote>
<p>注意:与保存或删除事件时一样，请确保如果将 NO 传递给 commit 参数，稍后调用 commit: 方法来保存更改。</p>
</blockquote>
<h1 id="配置闹铃"><a href="#配置闹铃" class="headerlink" title="配置闹铃"></a>配置闹铃</h1><p>提醒用户即将发生的事件的一个简单方法是为他们的日历项目设置闹铃。无论当前运行的应用程序是什么，闹铃都会以通知的形式出现在前台，提醒用户有预定的事件。如果将闹铃设置为日历事件，则通知来自日历应用程序。如果一个闹铃被设置为提醒，通知来自提醒应用程序。闹铃可以是基于时间的，在指定的时间触发。或者是基于位置的，当穿越地理围栏时触发。</p>
<p>闹铃可以应用于日历事件和提醒。</p>
<blockquote>
<p>注意:闹铃不打算作为 UILocalNotification。闹铃需要你创建一个事件或提醒，在用户的日历或提醒应用程序中可见。 UILocalNotification 更适合于不涉及 Calendar 数据库的一般用途。</p>
</blockquote>
<h2 id="挂载和移除闹铃"><a href="#挂载和移除闹铃" class="headerlink" title="挂载和移除闹铃"></a>挂载和移除闹铃</h2><p>可以使用 <code>addAlarm:</code> 方法将告警添加到事件中。可以使用绝对日期或相对于事件开始日期的偏移量创建闹铃。使用相对偏移量创建的警报必须发生在事件的开始日期之前或开始日期。</p>
<p>在 OS X 中，你可以在发出警报的同时触发一个动作;例如,设置:</p>
<ul>
<li>发送电子邮件的 emailAddress 属性</li>
<li>用于播放声音的 soundName 属性</li>
<li>打开 url 的 url 属性</li>
</ul>
<p>您可以使用 removeAlarm: 方法从事件中删除闹铃。</p>
<h2 id="设置地理围栏"><a href="#设置地理围栏" class="headerlink" title="设置地理围栏"></a>设置地理围栏</h2><blockquote>
<p>注意:地理围栏在 OS X 和 iOS 上都得到支持，但它们在移动设备上更有效。</p>
</blockquote>
<p>“地理围栏”是一个围绕着某个地理位置的虚拟边界，当它被越过时，就会触发某个事件的警报。地理围栏是一种有用的方法，可以提醒用户在进入或离开某个区域时需要执行的任务。例如，当用户离开他们的工作场所时，警报器就会响起，提醒他们在杂货店停下来。作为开发人员，您可以控制中心的纬度和经度，以及地理围栏的半径。</p>
<p>通过创建闹铃并设置其结构位置和接近度，为事件配置一个地理围栏。调用 <code>locationWithTitle:</code> 方法来创建一个结构化位置。要设置经度和纬度坐标，请将 <code>CLLocation</code> 传递给返回的结构化位置的 <code>geoLocation</code> 属性。radius 属性的值为 0 将使用系统的默认 radius。要选择自己的半径，请指定一个以米为单位的值。</p>
<p>虽然启用了地理围栏功能的闹铃可以应用于事件，但它们更适合用于提醒。</p>
<h1 id="创建重复事件"><a href="#创建重复事件" class="headerlink" title="创建重复事件"></a>创建重复事件</h1><p>重复事件在指定的时间间隔内重复。要使一个事件成为一个重复发生的事件，请为它分配一个重复发生规则，该规则描述事件发生的时间。递归规则由 <code>EKRecurrenceRule</code> 类的实例表示。</p>
<p>递归适用于日历事件和提醒。与重复事件不同，只有重复集的第一个未完成提醒是可获得的。EventKit 和提醒应用都是如此。当提醒完成时，递归集中的下一个提醒就可用了。</p>
<h2 id="使用基本的规则"><a href="#使用基本的规则" class="headerlink" title="使用基本的规则"></a>使用基本的规则</h2><p>可以使用 <code>initRecurrenceWithFrequency:interval:end:</code> 方法创建简单的日、周、月或年模式的递归规则。你给这个方法提供了三个值:</p>
<ul>
<li>递归频率。这是 <code>EKRecurrenceFrequency</code> 类型的值，表示复发规则是每天、每周、每月还是每年。</li>
<li>递归间隔。这是一个大于0的整数，用于指定模式重复的频率。例如，如果递归规则是每周递归规则，并且它的间隔是1，那么模式每周重复一次。如果递归规则是月递归规则，且其间隔为3，则模式每三个月重复一次。</li>
<li>递归结束。这个可选参数是 <code>EKRecurrenceEnd</code> 类的一个实例，它指示递归规则何时结束。递归结束可以基于一个特定的结束日期或出现的数量。如果你不想为递归规则指定结束，则传递 nil。</li>
</ul>
<h2 id="使用复杂的规则"><a href="#使用复杂的规则" class="headerlink" title="使用复杂的规则"></a>使用复杂的规则</h2><p>你可以使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">initRecurrenceWithFrequency:</span><br><span class="line">                   interval:</span><br><span class="line">              daysOfTheWeek:</span><br><span class="line">             daysOfTheMonth:</span><br><span class="line">            monthsOfTheYear:</span><br><span class="line">             weeksOfTheYear:</span><br><span class="line">              daysOfTheYear:</span><br><span class="line">               setPositions:</span><br><span class="line">                        end:</span><br></pre></td></tr></table></figure>

<p>方法来创建一个复杂的递归规则。对于基本的递归规则，您可以为重复发生的事件提供频率、间隔和可选的结束。此外，还可以提供描述自定义规则的可选值组合，如下表中所示</p>
<p>复杂递归规则分解</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>接受的值</th>
<th>可以组合什么</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>天:事件发生的星期几</td>
<td>一个<code>EKRecurrenceDayOfWeek</code>对象数组</td>
<td>除每日递归规则外,所有递归规则</td>
<td>包含<code>EKTuesday</code>和<code>EKFriday</code>对象的数组将创建一个每周二和周五发生的递归。</td>
</tr>
<tr>
<td>月日:事件发生的月份中的天数</td>
<td>一个非零NSNumber对象数组，范围为-31 ~ 31。负值表示从月末开始倒数计数。</td>
<td>仅限每月重复规则。</td>
<td>包含值1和-1的数组将创建一个在每个月的第一天和最后一天发生的递归。</td>
</tr>
<tr>
<td>个月:一年中发生事件的月份。</td>
<td>NSNumber对象数组，取值范围为1 ~ 12，对应于公历月份。</td>
<td>仅限每年重复规则。</td>
<td>如果初始事件发生在1月10日，则可以提供一个包含值1和2的数组，以创建每年1月10日和2月10日发生的递归。</td>
</tr>
<tr>
<td>周年:一年中发生事件的几周。</td>
<td>一个非零NSNumber对象数组，范围为-53 ~ 53。负值表示从年末开始向后计数。</td>
<td>仅限每年重复规则。</td>
<td>如果初始事件发生在星期三，则可以提供一个包含值1和-1的数组，以创建在每年第一周和最后一周的星期三发生的递归。如果指定的星期不包含当前年度中的星期三(可以是一年的第一个或最后一个星期)，则不会发生事件。</td>
</tr>
<tr>
<td>日年：一年中发生事件的日子。</td>
<td>一个非零NSNumber对象数组，范围为-366 ~ 366。负值表示从年末开始向后计数。</td>
<td>仅限每年重复规则。</td>
<td>您可以提供一个包含值1和-1的数组，以创建在每年的第一天和最后一天发生的递归。</td>
</tr>
<tr>
<td>设置位置：递归规则中包含的次数。此筛选器应用于根据您提供的其他参数确定的事件集。</td>
<td>一个非零NSNumber对象数组，范围为-366 ~ 366。负值表示从出现列表的末尾向后计数。</td>
<td>除每日递归规则外,所有递归规则</td>
<td>如果为一个年递归规则提供一个包含值1和-1的数组，该规则将周一到周五指定为其值，表示每周的天数，则递归仅在每年的第一个和最后一个工作日发生。</td>
</tr>
</tbody></table>
<p>您可以为上表中的任意多个参数提供值。不应用于特定递归规则的参数将被忽略。如果您为上述多个参数提供了一个值，则递归仅在应用于所有提供的值的日子发生。</p>
<p>一旦创建了递归规则，就可以使用 <code>EKCalendarItem</code> 的 <code>addRecurrenceRule:</code> 对象方法将其应用到日历事件或提醒。</p>
<h1 id="观察日历数据库的外部更改"><a href="#观察日历数据库的外部更改" class="headerlink" title="观察日历数据库的外部更改"></a>观察日历数据库的外部更改</h1><p>在你的应用程序运行时，其他进程或应用程序有可能修改日历数据库。如果你的应用程序获取日历事件或提醒，你应该注册以获得日历数据库的更改通知。通过这样做，可以确保向用户显示的日历和提醒信息是当前的。</p>
<h2 id="注册通知"><a href="#注册通知" class="headerlink" title="注册通知"></a>注册通知</h2><p>当 <code>EKEventStore</code> 对象检测到日历数据库发生变化时，它会发送一个 <code>EKEventStoreChangedNotification</code> 通知。如果你的应用程序处理事件或提醒数据，请注册此通知。</p>
<p>下面的代码注册了 EKEventStoreChangedNotification 通知，如下所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(storeChanged:)</span><br><span class="line">                                             name:EKEventStoreChangedNotification</span><br><span class="line">                                           object:eventStore];</span><br></pre></td></tr></table></figure>

<h2 id="响应通知"><a href="#响应通知" class="headerlink" title="响应通知"></a>响应通知</h2><p>当你收到一个 <code>EKEventStoreChangedNotification</code> 通知时，你获取的对象——比如 <code>EKEvent</code>、<code>EKReminder</code> 或 <code>EKCalendar</code> —— 可能已经发生了变化。这些更改的效果取决于是否添加、修改或删除了事件。</p>
<ul>
<li>如果添加了一个事件，它不会影响你之前获取的任何事件或提醒，但是添加的事件可能会在你显示给用户的事件的日期范围内。</li>
<li>如果一个事件被修改或删除，则表示该事件的 <code>EKEvent</code> 和 <code>EKRemindr</code> 对象的属性可能会过期。</li>
</ul>
<p>由于在 Calendar 数据库中发生更改时，您的本地数据通常是无效的或不完整的，所以当您收到 <code>EKEventStoreChangedNotification</code> 通知时，应该重新获取事件的当前日期范围。如果你正在修改一个事件，除非绝对有必要，否则你不想重新取回它,您可以调用事件的刷新 <code>refresh</code> 方法。如果方法返回 YES，则可以继续使用该事件;否则，需要重新获取。</p>
<blockquote>
<p>注意:当日历数据库发生变化时，在带有 EventKit UI 的事件视图控制器中被修改的事件会自动更新。要更深入地了解 EventKit UI，请阅读下一章，为事件提供接口。</p>
</blockquote>
<h1 id="为事件提供接口"><a href="#为事件提供接口" class="headerlink" title="为事件提供接口"></a>为事件提供接口</h1><blockquote>
<p>重要提示:本章引用的 EventKit UI 框架仅适用于 iOS。如果你是为 OS X 开发，你要负责构建自己的事件视图控制器;更多信息，请阅读 NSViewController 类参考。</p>
</blockquote>
<p>EventKit UI 框架提供了两种类型的视图控制器来操作事件:</p>
<ul>
<li>EKEventViewController: 如果你有一个想要显示的事件，请使用这个类。</li>
<li>EKEventEditViewController: 使用这个类允许用户创建、编辑或删除事件。</li>
</ul>
<h2 id="显示事件数据"><a href="#显示事件数据" class="headerlink" title="显示事件数据"></a>显示事件数据</h2><p>要使用 EKEventViewController 类，你必须有一个从事件存储中获得的现有事件。在呈现这类视图控制器之前，你需要设置事件属性和任何其他显示选项。下面代码展示了如何创建事件视图控制器并将其添加到导航控制器中，假设 myEvent 已经存在。如果不允许用户编辑事件，则将 allowsEditing 属性设置为 NO。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">EKEventViewController *eventViewController = [[EKEventViewController alloc] init];</span><br><span class="line">    eventViewController.event = myEvent;</span><br><span class="line">    eventViewController.allowsEditing = <span class="literal">YES</span>;</span><br><span class="line">    navigationController = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:eventViewController];</span><br></pre></td></tr></table></figure>

<p>您需要为事件视图控制器分配一个委托，以便在用户完成查看事件时接收通知。该委托符合 <code>EKEventViewDelegate</code> 协议，并且必须实现 <code>eventViewController:didCompleteWithAction:</code> 方法。</p>
<h2 id="修改事件数据"><a href="#修改事件数据" class="headerlink" title="修改事件数据"></a>修改事件数据</h2><p>要允许用户创建、编辑或删除事件，请使用 <code>EKEventEditViewController</code> 类和 <code>EKEventEditViewDelegate</code> 协议。您可以创建一个类似于事件视图控制器的事件编辑视图控制器，但是必须设置 eventStore 属性(设置事件属性是可选的)。</p>
<ul>
<li>当你呈现视图控制器时，如果 event 属性为 nil，用户就会在默认日历中创建一个新事件，并将其保存到指定的事件存储中。</li>
<li>如果 event 属性不为 nil，则用户编辑一个现有的事件。事件必须驻留在指定的事件存储区中，否则将引发异常。</li>
</ul>
<p><code>EKEventEditViewController</code> 类的实例被设计为模态显示，如下面代码所示。在这段代码中，self 是导航控制器的顶视图控制器。关于模态视图控制器的详细信息，请阅读 modal Presenting a view Controller。</p>
<p>模态地呈现事件编辑视图控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">EKEventEditViewController* controller = [[EKEventEditViewController alloc] init];</span><br><span class="line">    controller.eventStore = myEventStore;</span><br><span class="line">    controller.editViewDelegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span> presentModalViewController:controller animated:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<p>您还必须指定一个委托，以便在用户完成事件编辑后接收通知。该委托符合 <code>EKEventEditViewDelegate</code> 协议，并且必须实现 <code>eventteditviewcontroller:didCompleteWithAction:</code> 方法来解散模态视图控制器。通常，模态地呈现视图控制器的对象负责解散它。</p>
<p>委托将解散模态视图</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)eventEditViewController:(EKEventEditViewController *)controller</span><br><span class="line">          didCompleteWithAction:(EKEventEditViewAction)action</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> dismissModalViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>委托还传递了用户在完成编辑时所采取的操作。用户可以取消更改、保存事件或删除事件。如果你需要在用户退出模态视图后执行更多代码，实现 <code>eventteditviewcontroller:didCompleteWithAction: delegate</code> 方法。</p>
]]></content>
      <categories>
        <category>Apple 文档翻译</category>
      </categories>
      <tags>
        <tag>EventKit</tag>
        <tag>Calendar</tag>
        <tag>Reminders</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC</title>
    <url>/2025/07/29/KVC/</url>
    <content><![CDATA[<p>我不知道有多少人像作者一样，n 年来查看过不知道多少次 KVC 文档，但是每次通篇读下来总是会遇到读不懂的地方，总是莫名其妙的出现一个章节完全不知道在讲什么东西，不论是用传统的 Google 翻译或者目前主流的 AI 翻译翻译了，也还是会遇到读起来狗屁不通的情况。这次作者决定结合 AI 和个人的理解将 KVC 文档彻底弄清楚，即使不能完全弄明白也要留下一个深刻的印象，方便后续遇到文章中的场景时能够回想起来。</p>
<!--# 章节概览

- 入门
    - 关于键值编码
        - 使用符合键值编码的对象
        - 使对象符合键值编码
        - 键值编码和 Swift
        - 其他依赖于键值编码的 Cocoa 技术
- 键值编码基础知识
    - 访问对象属性
        - 使用键和键路径识别对象的属性
        - 使用键获取属性的值	
        - 使用键设置属性的值
        - 使用键简化对象访问	
    - 访问集合属性
    - 使用集合运算符
        - 示例数据
        - 聚合运算符
        - 数组运算符
        - 嵌套运算符
    - 表示非对象类型的数据
        - 包装和解包标量类型
        - 包装盒解包结构体类型
    - 验证属性值
        - 自动验证
    - 访问器搜索模式
        - 基本 getter 的搜索模式
        - 基本 setter 的搜索模式
        - 可变数组的搜索模式
        - 可变有序集合的搜索模式
        - 可变集合的搜索模式
- 采用键值编码协议
    - 实现基础的键值编码符合性
        - 基础获取方法
        - 基础设置方法
        - 实例变量
    - 定义集合操作方法
        - 访问有序的集合
            - 有序集合的获取方法
            - 有序集合的修改方法
        - 访问无序集合中的元素
            - 无序集合的获取方法
            - 无需集合的修改方法
    - 处理非对象类型值
    - 添加验证步骤
        - 实现一个验证方法
        - 标量值的验证
    - 描述属性之间的关系
        - 类描述
    - 以性能为目的进行设计
        - 重写键值编码方法
        - 优化一对多关系
    - 符合性检查清单
        - 属性和一对一关系的合规性
        - 有序的对多关系合规性
        - 无序的多多关系合规性
        - 验证
-->



<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="关于键值编码"><a href="#关于键值编码" class="headerlink" title="关于键值编码"></a>关于键值编码</h2><p>键值编码是由 NSKeyValueCoding 非正式协议启用的一种机制，对象采用该机制来提供对其属性的间接访问。当对象实现了 NSKeyValueCoding 协议时（文章后续提到的实现了键值编码协议，实现了键值编码都是一个意思），其属性可以通过简洁、统一的接口通过字符串参数进行寻址。这种间接访问机制补充了实例变量及其相关访问方法所提供的直接访问。</p>
<p>通常使用访问器方法来访问对象的属性。get 访问器（或 getter）返回属性的值。set 访问器（或 setter）设置属性的值。在 Objective-C 中，您还可以直接访问属性的底层实例变量。通过任何一种方式访问对象属性都很简单，但需要调用特定于属性的方法或变量名（如属性名是 name 那么 getter 方法就是 name，setter 方法就是 setName: 或者直接访问实例变量 _name）。随着属性列表的增长或变化，访问这些属性的代码也必须随之变化。相比之下，实现了键值编码协议的对象提供了一个简单的编程接口，该接口在其所有属性之间保持一致。</p>
<p>键值编码是许多其他 Cocoa 技术（例如键值观察、Cocoa 绑定、Core Data 和 AppleScript 能力）的基础概念。在某些情况下，键值编码还可以帮助简化代码。</p>
<h3 id="使用符合键值编码的对象"><a href="#使用符合键值编码的对象" class="headerlink" title="使用符合键值编码的对象"></a>使用符合键值编码的对象</h3><p>对象通常从 NSObject（直接或间接）继承时就符合了键值编码协议，NSObject 它实现了 NSKeyValueCoding 协议，又为必要方法提供默认实现。此类对象（基本可以认为是所有 Objective-C 对象）允许其他对象通过紧凑的消息传递接口执行以下操作：</p>
<ul>
<li><p><strong>访问对象属性。</strong> 该协议指定了方法，例如通用 getter valueForKey: 和通用 setter setValue:forKey: 用于通过名称或键（以字符串为参数）访问对象属性。这些方法和相关方法的默认实现使用键来定位和与底层数据交互，如访问对象属性中所述。</p>
</li>
<li><p><strong>操作集合属性。</strong> 访问方法的默认实现与对象的集合属性（例如 NSArray 对象）一起工作，就像任何其他属性一样。此外，如果对象为属性定义了集合访问器方法，它就可以实现对集合内容的键值访问。这通常比直接访问更有效，并且允许您通过标准化接口使用自定义集合对象，如访问集合属性中所述。</p>
</li>
<li><p><strong>在集合对象上调用集合运算符。</strong> 当访问符合键值编码的对象中的集合属性时，可以将集合运算符插入到键字符串中，如使用集合运算符中所述。集合运算符指示默认的 NSKeyValueCoding getter 实现对集合执行操作，然后返回集合的新过滤版本，或代表集合某些特征的单个值。</p>
</li>
<li><p><strong>访问非对象属性。</strong> 该协议的默认实现检测非对象属性，包括标量和结构，并自动将它们包装和解包装为对象以便在协议接口上使用，如表示非对象值中所述。此外，该协议声明了一种方法，允许兼容对象为通过键值编码接口在非对象属性上设置 nil 值的情况提供适当的操作。</p>
</li>
<li><p><strong>通过键路径访问属性。</strong> 当您拥有一个符合键值编码的对象层次结构时，您可以使用基于键路径的方法调用来深入研究，使用单个调用获取或设置层次结构深处的值。</p>
</li>
</ul>
<blockquote>
<p>个人总结</p>
<p>呃，看上去提供了1，2，3，4，5很多功能啰里八嗦的其实就一句话可以利用 KVC 协议提供的方法访问对象的所有属性。。。感觉像是按字数拿稿费的作者想方设法多凑点儿字数出来</p>
</blockquote>
<h3 id="使对象符合键值编码"><a href="#使对象符合键值编码" class="headerlink" title="使对象符合键值编码"></a>使对象符合键值编码</h3><p>为了使你自己的对象符合键值编码，您应该确保它们采用 NSKeyValueCoding 非正式协议并实现相应的方法，例如 valueForKey: 作为通用 getter 和 setValue:forKey: 作为通用 setter。幸运的是，如前面所述，NSObject 采用了该协议并为其必要方法提供了默认实现。因此，如果您从 NSObject（或其众多子类中的任何一个）派生对象，那么大部分工作已经为您完成。</p>
<p>为了使默认方法能够发挥作用，您需要确保对象的访问器方法和实例变量遵循某些明确定义的模式。这允许默认实现根据键值编码消息来查找对象的属性。然后，您可以选择通过提供验证方法和处理某些特殊情况的方法来扩展和定制键值编码。</p>
<h3 id="键值编码和-Swift"><a href="#键值编码和-Swift" class="headerlink" title="键值编码和 Swift"></a>键值编码和 Swift</h3><p>从 NSObject 或其子类继承的 Swift 对象默认对其属性遵循键值编码。而在 Objective-C 中，属性的访问器和实例变量必须遵循某些模式，而 Swift 中的标准属性声明会自动保证这一点。另一方面，该协议的许多功能要么不相关，要么可以使用 Objective-C 中不存在的原生 Swift 构造或技术更好地处理。例如，由于所有 Swift 属性都是对象，因此您永远不会使用默认实现对非对象属性的特殊处理。</p>
<p>因此，虽然键值编码协议方法可以直接转换为 Swift，但本指南主要关注 Objective-C，您需要做更多工作来确保合规性，并且键值编码通常最有用。整个指南都指出了需要在 Swift 中采用明显不同方法的情况。</p>
<p>如需了解更多关于如何将 Swift 与 Cocoa 技术结合使用的信息，请阅读《将 Swift 与 Cocoa 和 Objective-C 结合使用 (Swift 3)》。如需 Swift 的完整描述，请阅读《Swift 编程语言 (Swift 3)》。</p>
<h3 id="其他依赖于键值编码的-Cocoa-技术"><a href="#其他依赖于键值编码的-Cocoa-技术" class="headerlink" title="其他依赖于键值编码的 Cocoa 技术"></a>其他依赖于键值编码的 Cocoa 技术</h3><p>符合键值编码的对象可以参与依赖于这种访问方式的各种 Cocoa 技术，包括：</p>
<ul>
<li><strong>键值观察。</strong> 该机制使对象能够注册由另一个对象属性的变化驱动的异步通知，如《键值观察编程指南》中所述。</li>
<li><strong>Cocoa绑定。</strong> 这套技术完全实现了模型-视图-控制器范例，其中模型封装应用程序数据，视图显示和编辑该数据，控制器在两者之间进行调解。阅读 Cocoa Bindings 编程主题以了解有关 Cocoa Bindings 的更多信息。</li>
<li><strong>Core Data。</strong> 该框架为与对象生命周期和对象图管理（包括持久化）相关的常见任务提供了通用且自动化的解决方案。您可以在《Core Data 编程指南》中阅读关于 Core Data 的内容。</li>
<li><strong>AppleScript。</strong> 这种脚本语言可以直接控制可编写脚本的应用以及 macOS 的许多部分。Cocoa 的脚本支持利用键值编码来获取和设置可编写脚本的对象中的信息。NSScriptKeyValueCoding 非正式协议中的方法扩展了键值编码功能，包括通过索引在多值键中获取&#x2F;设置键值，以及将键值强制转换（或转换）为适当数据类型。《AppleScript概述》提供了对AppleScript及其相关技术的高层介绍。</li>
</ul>
<h1 id="键值编码基础知识"><a href="#键值编码基础知识" class="headerlink" title="键值编码基础知识"></a>键值编码基础知识</h1><h2 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h2><p>对象通常在其接口声明中指定属性，这些属性属于以下几个类别之一：</p>
<ul>
<li><strong>属性。</strong> 这些是简单值，例如标量、字符串或布尔值。数值对象（例如 NSNumber）和其他不可变类型（例如 NSColor）也被视为属性。</li>
<li><strong>一对一关系。</strong> 这些是具有自身属性的可变对象。对象的属性可以在不改变对象本身的情况下发生变化。例如，银行账户对象可能具有 owner 属性，该属性是 Person 对象的一个实例，而 Person 对象本身具有 address 属性。账户所有人的地址可能会更改，但银行账户持有的所有人参考号不会改变。银行账户所有人并没有改变，只是她的地址改变了。</li>
<li><strong>一对多关系。</strong> 这些是集合对象。通常使用 NSArray 或 NSSet 的实例来保存此类集合，尽管也可以使用自定义集合类。</li>
</ul>
<p>清单 2-1 中声明的 BankAccount 对象演示了每种类型的属性。</p>
<p>清单 2-1 BankAccount 对象的属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BankAccount</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span>* currentBalance;              <span class="comment">// An attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) Person* owner;                         <span class="comment">// A to-one relation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span>&lt; Transaction* &gt;* transactions; <span class="comment">// A to-many relation</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>为了保持封装性，对象通常会在其接口上提供属性的访问器方法。对象作者可以显式编写这些方法，也可以依赖编译器自动合成。无论哪种方式，使用这些访问器的代码作者都必须在编译前将属性名写入代码中。访问器方法的名称由此成为调用代码的静态组成部分。例如，给定清单 2-1 中声明的银行账户对象，编译器会合成一个可以为 myAccount 实例调用的 setter：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[myAccount setCurrentBalance:@(<span class="number">100.0</span>)];</span><br></pre></td></tr></table></figure>

<p>这种方式虽然直接，但缺乏灵活性。相比之下，实现了键值编码协议的对象提供了一种更通用的机制 —— 通过字符串标识符来访问对象属性。</p>
<h3 id="使用键和键路径识别对象的属性"><a href="#使用键和键路径识别对象的属性" class="headerlink" title="使用键和键路径识别对象的属性"></a>使用键和键路径识别对象的属性</h3><p>键是标识特定属性的字符串。通常，按照惯例，表示属性的键是代码中的属性本身的名称。键必须使用 ASCII 编码，不得包含空格，并且通常以小写字母开头（尽管也有例外，例如许多类中的 URL 属性）。</p>
<p>因为清单 2-1 中的 BankAccount 类是实现了键值编码协议的，所以它识别键 owner ，currentBalance 和 transactions，它们是它的属性的名称。您可以通过其键设置其值，而不是调用 setCurrentBalance: 方法。</p>
<blockquote>
<p><code>[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];</code></p>
</blockquote>
<p>实际上，你可以使用同一个方法，通过传入不同的键参数来设置 myAccount 对象的所有属性。由于参数是字符串类型，它可以作为运行时动态操作的变量。</p>
<p>键路径是由点分隔的键序列组成的字符串，用于指定需要连续访问的对象属性链。序列中首个键的属性相对于消息接收者而确定，后续每个键的值都基于前一个属性的值来获取。因此通过单次调用方法就能深入访问对象层级结构，这便是键路径的核心价值所在。</p>
<p>例如，将键路径 owner.address.street 应用于银行账户实例时，其含义可解析为：</p>
<ol>
<li>首先获取银行账户持有者（owner，Person类实例）</li>
<li>继而访问该持有者的地址（address，Address类实例）</li>
<li>最终取得地址对象中的街道字符串值（street）</li>
</ol>
<blockquote>
<p>在 Swift 中，您可以使用 #keyPath 表达式替代字符串来指定键或键路径。这种方法提供编译时检查的优势，正如《Swift与Cocoa、Objective-C互操作性指南（Swift 3版）》中”键与键路径”章节所述。</p>
</blockquote>
<h3 id="使用键获取属性的值"><a href="#使用键获取属性的值" class="headerlink" title="使用键获取属性的值"></a>使用键获取属性的值</h3><p>当对象遵循 NSKeyValueCoding 协议时，即视为支持键值编码。继承自 NSObject 的对象会自动遵循此协议（NSObject 已提供该协议核心方法的默认实现），并具备特定的默认行为。此类对象至少实现以下基于键的基本读取方法：</p>
<ol>
<li><p>valueForKey:</p>
<ul>
<li>返回由键参数指定的属性值。若根据《访问器检索模式》规则无法找到对应键的属性，对象会向自身发送 valueForUndefinedKey: 消息。</li>
<li>valueForUndefinedKey: 默认实现会抛出 NSUndefinedKeyException 异常，但子类可重写此方法以更优雅地处理该场景。</li>
</ul>
</li>
<li><p>valueForKeyPath:</p>
<ul>
<li>返回相对于消息接收者的指定键路径值。若键路径序列中任意对象对特定键不兼容键值编码（即 valueForKey: 的默认实现无法找到访问器方法），该对象会收到 valueForUndefinedKey: 消息。</li>
</ul>
</li>
<li><p>dictionaryWithValuesForKeys:</p>
<ul>
<li>返回与接收者相关的键数组对应值。该方法会遍历数组中的每个键并调用 valueForKey:。</li>
<li>返回的 NSDictionary 包含数组中所有键的对应值。</li>
</ul>
</li>
</ol>
<blockquote>
<p>重要提示</p>
<p>集合对象（如NSArray&#x2F;NSSet&#x2F;NSDictionary）不可包含 nil 值，需用 NSNull 实例表示空值。dictionaryWithValuesForKeys: 及其相关方法 setValuesForKeysWithDictionary: 的默认实现会自动完成 NSNull（字典参数中）与 nil（存储属性中）的转换。</p>
</blockquote>
<p>使用键路径寻址属性时，如果键路径中除最后一个键外的任何键是对多关系（即，它引用集合），则返回值是一个集合，其中包含对多键右侧键的所有值。例如，请求键路径 transactions.payee 的值将返回一个数组，其中包含所有交易的 payee 对象。这也适用于键路径中的多个数组。键路径 accounts.transactions.payee 返回一个数组，其中包含所有账户中所有交易的所有收款人对象。</p>
<h3 id="使用键设置属性的值"><a href="#使用键设置属性的值" class="headerlink" title="使用键设置属性的值"></a>使用键设置属性的值</h3><p>与 getter 一样，符合键值编码的对象还提供了一小组通用 setter，其默认行为基于 NSObject 中的 NSKeyValueCoding 协议的实现。</p>
<ul>
<li><p>setValue:forKey:</p>
<ul>
<li>为消息接收对象的指定键设置给定值。该方法默认实现会自动拆解表示标量和结构体的 NSNumber 与 NSValue 对象，并将其赋值给对应属性。非对象值的包装与解包语义详见《表示非对象类型的数据》。</li>
<li>若指定键在接收对象中无对应属性，对象将向自身发送 setValue:forUndefinedKey: 消息。该消息默认实现会触发 NSUndefinedKeyException 异常，但子类可通过覆写此方法实现自定义处理逻辑。</li>
</ul>
</li>
<li><p>setValue:forKeyPath:</p>
<ul>
<li>沿指定键路径为接收对象设置给定值。若键路径中任一节点对象不遵循键值编码规范，该节点将收到 setValue:forUndefinedKey: 消息。</li>
</ul>
</li>
<li><p>setValuesForKeysWithDictionary:</p>
<ul>
<li>通过字典键名批量设置接收对象的属性值。默认实现将遍历字典键值对，为每个键调用 setValue:forKey: 方法，并根据需要将 NSNull 对象替换为 nil。</li>
</ul>
</li>
</ul>
<p>根据默认实现，当尝试为非对象属性设置 nil 值时，遵循键值编码规范的对象会向自身发送 setNilValueForKey: 消息。该消息默认实现将触发 NSInvalidArgumentException 异常，但开发者可通过覆写方法替换为默认值或标记值（详见《非对象值处理机制》）。</p>
<h3 id="使用键简化对象访问"><a href="#使用键简化对象访问" class="headerlink" title="使用键简化对象访问"></a>使用键简化对象访问</h3><p>若要了解基于键的 getter 和 setter 如何简化代码，请考虑以下示例。在 macOS 中，NSTableView 和 NSOutlineView 对象将标识符字符串与其每列相关联。如果支持表的模型对象不符合键值编码，则表的数据源方法将被迫依次检查每个列标识符以找到要返回的正确属性，如示例 2-2 所示。此外，将来，当您向模型添加另一个属性（在本例中为 Person 对象）时，还必须重新访问数据源方法，添加另一个条件来测试新属性并返回相关值。</p>
<p>示例 2-2 未采用键值编码的数据源方法的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">NSTableView</span> *)tableview objectValueForTableColumn:(<span class="type">id</span>)column row:(<span class="built_in">NSInteger</span>)row</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> result = <span class="literal">nil</span>;</span><br><span class="line">    Person *person = [<span class="keyword">self</span>.people objectAtIndex:row];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([[column identifier] isEqualToString:<span class="string">@&quot;name&quot;</span>]) &#123;</span><br><span class="line">        result = [person name];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([[column identifier] isEqualToString:<span class="string">@&quot;age&quot;</span>]) &#123;</span><br><span class="line">        result = @([person age]);  <span class="comment">// 将标量年龄值包装为NSNumber对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([[column identifier] isEqualToString:<span class="string">@&quot;favoriteColor&quot;</span>]) &#123;</span><br><span class="line">        result = [person favoriteColor];</span><br><span class="line">    &#125; <span class="comment">// 其他属性判断...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，示例 2-3 显示了同一数据源方法的更简洁的实现，该方法利用了符合键值编码的 Person 对象。仅使用 valueForKey: getter，数据源方法使用列标识符作为键返回适当的值。除了更短之外，它还更通用，因为稍后添加新列时，只要列标识符始终与模型对象的属性名称匹配，它就会继续保持不变地工作。</p>
<p>示例 2-3 使用键值编码实现数据源方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">NSTableView</span> *)tableview objectValueForTableColumn:(<span class="type">id</span>)column row:(<span class="built_in">NSInteger</span>)row</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接通过列标识符作为键值获取对应属性</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span>.people objectAtIndex:row] valueForKey:[column identifier]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h2><p>遵循键值编码规范的对象以统一方式暴露其集合类型属性（To-Many）。与普通属性操作类似，开发者可使用 valueForKey: 与 setValue:forKey:（或其键路径变体）直接访问集合对象。但若需修改集合内容，采用协议定义的可变代理方法通常更高效。</p>
<p>协议定义三类代理访问方法（均含键与键路径版本）：</p>
<ul>
<li><p>mutableArrayValueForKey: 和 mutableArrayValueForKeyPath:</p>
<ul>
<li>它们返回一个代理对象，其行为类似于 NSMutableArray 对象。</li>
</ul>
</li>
<li><p>mutableSetValueForKey: and mutableSetValueForKeyPath:</p>
<ul>
<li>它们返回一个代理对象，其行为类似于 NSMutableSet 对象。</li>
</ul>
</li>
<li><p>mutableOrderedSetValueForKey: and mutableOrderedSetValueForKeyPath:</p>
<ul>
<li>它们返回一个代理对象，其行为类似于 NSMutableOrderedSet 对象。</li>
</ul>
</li>
</ul>
<p>当您操作代理对象（添加&#x2F;移除&#x2F;替换元素）时，协议的默认实现会相应修改基础属性。这种方式比传统流程更高效 —— 即先用 valueForKey: 获取不可变集合副本，修改内容后通过 setValue:forKey: 回写。多数情况下，此方式甚至比直接操作可变属性更高效。这些方法还具有额外优势：能自动维护集合内对象的键值观察合规性（详见《键值观察编程指南》）。</p>
<h2 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h2><p>当向实现了键值编码的对象发送 valueForKeyPath: 消息时，可在键路径中嵌入集合运算符。集合运算符是以 “at” 符号（@）为前缀的关键字，指示 getter 在返回数据前执行特定操作。NSObject 提供的 valueForKeyPath: 默认实现支持此功能。</p>
<p>若键路径包含集合运算符，运算符前的部分（称为左路径）指明操作所针对的集合对象，该集合相对于消息接收者。当直接向集合对象（如 NSArray 实例）发送消息时，左路径可省略。</p>
<p>运算符后的键路径部分（称为右路径）指定运算符处理的集合内属性。除 @count 外，所有集合运算符都需要右路径。图 4-1 展示了运算符键路径的格式。</p>
<p>图 4-1 运算符键路径格式</p>
<img src="/2025/07/29/KVC/keypath.jpg" class="">

<p>集合运算符分为三种基本行为类型：</p>
<ul>
<li><p>聚合运算符</p>
<ul>
<li>对集合对象进行归约计算，返回与右路径属性数据类型匹配的单个对象。@count 是例外 —— 它不需要右路径，且始终返回 NSNumber 实例。</li>
</ul>
</li>
<li><p>数组运算符</p>
<ul>
<li>返回 NSArray 实例，包含目标集合中的特定对象子集。</li>
</ul>
</li>
<li><p>嵌套运算符</p>
<ul>
<li>处理包含其他集合的集合对象，根据运算符类型返回 NSArray 或 NSSet 实例，该结果集以特定方式合并嵌套集合内的对象。</li>
</ul>
</li>
</ul>
<h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h3><p>以下描述包含展示各运算符调用方式及结果的代码片段。示例基于代码清单 2-1 的 BankAccount 类，该类持有 Transaction 对象数组（如代码清单 4-1 所声明）。每个 Transaction 对象代表一条简易支票簿记录。</p>
<p>清单 4-1 Transaction 对象的接口声明。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Transaction</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span>* payee;   <span class="comment">// To whom</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span>* amount;  <span class="comment">// How much</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSDate</span>* date;      <span class="comment">// When</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>为便于说明，假设您的 BankAccount 实例包含由表 4-1 数据构成的 transactions 数组，且所有示例调用均在 BankAccount 对象内部执行。</p>
<p>表 4-1 Transactions 对象的示例数据</p>
<table>
<thead>
<tr>
<th>payee</th>
<th>amount</th>
<th>date</th>
</tr>
</thead>
<tbody><tr>
<td>Green Power</td>
<td>$120.00</td>
<td>Dec 1, 2015</td>
</tr>
<tr>
<td>Green Power</td>
<td>$150.00</td>
<td>Jan 1, 2016</td>
</tr>
<tr>
<td>Green Power</td>
<td>$170.00</td>
<td>Feb 1, 2016</td>
</tr>
<tr>
<td>Car Loan</td>
<td>$250.00</td>
<td>Jan 15, 2016</td>
</tr>
<tr>
<td>Car Loan</td>
<td>$250.00</td>
<td>Feb 15, 2016</td>
</tr>
<tr>
<td>Car Loan</td>
<td>$250.00</td>
<td>Mar 15, 2016</td>
</tr>
<tr>
<td>General Cable</td>
<td>$120.00</td>
<td>Dec 1, 2015</td>
</tr>
<tr>
<td>General Cable</td>
<td>$155.00</td>
<td>Jan 1, 2016</td>
</tr>
<tr>
<td>General Cable</td>
<td>$120.00</td>
<td>Feb 1, 2016</td>
</tr>
<tr>
<td>Mortgage</td>
<td>$1,250.00</td>
<td>Jan 15, 2016</td>
</tr>
<tr>
<td>Mortgage</td>
<td>$1,250.00</td>
<td>Feb 15, 2016</td>
</tr>
<tr>
<td>Mortgage</td>
<td>$1,250.00</td>
<td>Mar 15, 2016</td>
</tr>
<tr>
<td>Animal Hospital</td>
<td>$600.00</td>
<td>Jul 15, 2016</td>
</tr>
</tbody></table>
<h3 id="聚合运算符"><a href="#聚合运算符" class="headerlink" title="聚合运算符"></a>聚合运算符</h3><p>聚合运算符作用于 array 或 set 属性，生成反映该集合特定维度特征的单一结果值。</p>
<h4 id="avg"><a href="#avg" class="headerlink" title="@avg"></a><strong>@avg</strong></h4><p>指定 @avg 运算符时，valueForKeyPath: 将读取集合中每个元素的正确键路径指定的属性，将其转换为 double（将 0 替换为 nil 值），并计算这些值的算术平均值。然后返回存储在 NSNumber 实例中的结果。</p>
<p>要获取表 4-1 中示例数据的平均交易金额：</p>
<blockquote>
<p><code>NSNumber *transactionAverage = [self.transactions valueForKeyPath:@&quot;@avg.amount&quot;];</code></p>
</blockquote>
<p>返回的的结果是 456.54</p>
<h4 id="count"><a href="#count" class="headerlink" title="@count"></a><strong>@count</strong></h4><p>指定 @count 运算符时，valueForKeyPath: 将返回集合的数量在一个 NSNumber 对象中。如果出现了右路径将会被忽略。</p>
<p>获取 Transaction 中 transactions 个对象的数量：</p>
<blockquote>
<p><code>NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@&quot;@count&quot;];</code></p>
</blockquote>
<p>返回的结果是 13。</p>
<h4 id="max"><a href="#max" class="headerlink" title="@max"></a><strong>@max</strong></h4><p>指定 @max 操作符时，valueForKeyPath: 方法将在右路径指向的集合元素中执行搜索，并返回最大值。该搜索通过调用 compare: 方法进行比较（此方法由许多 Foundation 类（如NSNumber）定义）。因此，右路径对应的属性必须包含能响应此方法的有效对象，搜索过程会自动忽略值为 nil 的集合元素。</p>
<p>要获取表 4-1 中列出的交易中最大日期值，即最新交易的日期：</p>
<blockquote>
<p><code>NSDate *latestDate = [self.transactions valueForKeyPath:@&quot;@max.date&quot;];</code></p>
</blockquote>
<p>格式化的 latestDate 值为 2016 年 7 月 15 日。</p>
<h4 id="min"><a href="#min" class="headerlink" title="@min"></a><strong>@min</strong></h4><p>指定 @min 运算符时，valueForKeyPath: 将在右路径命名的集合元素中搜索并返回最小的元素。搜索使用 compare: 方法进行比较，该方法由许多基础类（例如 NSNumber 类）定义。因此，右路径对应的属性必须包含能响应此方法的有效对象，搜索过程会自动忽略值为 nil 的集合元素。</p>
<p>要获得表 4-1 中列出的交易中最早交易的最小日期值，即最早交易的日期：</p>
<blockquote>
<p><code>NSDate *earliestDate = [self.transactions valueForKeyPath:@&quot;@min.date&quot;]; </code></p>
</blockquote>
<p>格式化的 earliestDate 值为 2015 年 12 月 1 日。</p>
<h4 id="sum"><a href="#sum" class="headerlink" title="@sum"></a><strong>@sum</strong></h4><p>指定 @sum 运算符时，valueForKeyPath: 会读取集合中每个元素的正确键路径指定的属性，将其转换为 double（用 0 替换 nil 值），并计算这些值的总和。然后返回存储在 NSNumber 实例中的结果。</p>
<p>要获取表 4-1 中示例数据中交易金额的总和：</p>
<blockquote>
<p><code>NSNumber *amountSum = [self.transactions valueForKeyPath:@&quot;@sum.amount&quot;]; </code></p>
</blockquote>
<p>返回的结果是 5,935.00</p>
<h3 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h3><p>数组运算符导致 valueForKeyPath: 返回一个对象数组，该数组对应于右键路径指示的特定对象集。</p>
<blockquote>
<p>重要</p>
<p>如果使用数组运算符时，如果任何叶对象为 nil，则 valueForKeyPath: 方法会引发异常。</p>
</blockquote>
<h4 id="distinctUnionOfObjects"><a href="#distinctUnionOfObjects" class="headerlink" title="@distinctUnionOfObjects"></a><strong>@distinctUnionOfObjects</strong></h4><p>指定 @distinctUnionOfObjects 运算符时，valueForKeyPath: 将创建并返回一个数组，其中包含与正确键路径指定的属性相对应的集合的不同对象。</p>
<p>要获取 transactions 中交易的 payee 属性值集合，但省略重复值：</p>
<blockquote>
<p><code>NSArray *distinctPayees = [self.transactions valueForKeyPath:@&quot;@distinctUnionOfObjects.payee&quot;]; </code></p>
</blockquote>
<p>生成的 distinctPayees 数组包含以下字符串中的每个实例：Car Loan、General Cable、Animal Hospital、Green Power、Mortgage。</p>
<h4 id="unionOfObjects"><a href="#unionOfObjects" class="headerlink" title="@unionOfObjects"></a><strong>@unionOfObjects</strong></h4><p>指定 @unionOfObjects 运算符时，valueForKeyPath: 将创建并返回一个数组，其中包含与正确键路径指定的属性相对应的集合的所有对象。与 @distinctUnionOfObjects 不同，重复的对象不会被删除。</p>
<p>要获取 transactions 中交易的 payee 属性值的集合：。</p>
<blockquote>
<p><code>NSArray *payees = [self.transactions valueForKeyPath:@&quot;@unionOfObjects.payee&quot;]; </code></p>
</blockquote>
<p>生成的 payees 数组包含以下字符串：Green Power、Green Power、Green Power、Car Loan、Car Loan、Car Loan、General Cable、General Cable、General Cable、Mortgage、Mortgage、Mortgage、Animal Hospital。注意重复项</p>
<h3 id="嵌套运算符"><a href="#嵌套运算符" class="headerlink" title="嵌套运算符"></a>嵌套运算符</h3><p>嵌套运算符作用于嵌套集合 —— 即集合中的每个条目本身又包含一个集合。</p>
<blockquote>
<p>重要提示</p>
<p>当使用嵌套操作符时，若任何叶节点对象为 nil，valueForKeyPath: 方法将触发异常。</p>
</blockquote>
<p>下文描述基于名为 moreTransactions 的新数据数组（数据内容见表4-2），该数组与原始 transactions 数组（来自”样本数据”部分）共同构成嵌套数组：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>* moreTransactions = @[&lt;<span class="meta"># transaction data #&gt;];</span></span><br><span class="line"><span class="built_in">NSArray</span>* arrayOfArrays = @[<span class="keyword">self</span>.transactions, moreTransactions];</span><br></pre></td></tr></table></figure>

<p>表4-2 moreTransactions阵列中假设的Transaction数据。</p>
<table>
<thead>
<tr>
<th>payee</th>
<th>amount</th>
<th>date</th>
</tr>
</thead>
<tbody><tr>
<td>General Cable - Cottage</td>
<td>$120.00</td>
<td>Dec 18, 2015</td>
</tr>
<tr>
<td>General Cable - Cottage</td>
<td>$155.00</td>
<td>Jan 9, 2016</td>
</tr>
<tr>
<td>General Cable - Cottage</td>
<td>$120.00</td>
<td>Dec 1, 2016</td>
</tr>
<tr>
<td>Second Mortgage</td>
<td>$1,250.00</td>
<td>Nov 15, 2016</td>
</tr>
<tr>
<td>Second Mortgage</td>
<td>$1,250.00</td>
<td>Sep 20, 2016</td>
</tr>
<tr>
<td>Second Mortgage</td>
<td>$1,250.00</td>
<td>Feb 12, 2016</td>
</tr>
<tr>
<td>Hobby Shop</td>
<td>$600.00</td>
<td>Jun 14, 2016</td>
</tr>
</tbody></table>
<h4 id="distinctUnionOfArrays"><a href="#distinctUnionOfArrays" class="headerlink" title="@distinctUnionOfArrays"></a><strong>@distinctUnionOfArrays</strong></h4><p>当指定 @distinctUnionOfArrays 操作符时，valueForKeyPath: 方法将创建并返回一个新数组，其中包含右路径指定属性对应的所有集合去重合并后的唯一对象。</p>
<p>要获取数组集合 arrayOfArrays 中所有 payee 属性的去重值：</p>
<blockquote>
<p><code>NSArray *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:@&quot;@distinctUnionOfArrays.payee&quot;]; </code></p>
</blockquote>
<p>生成的 collectedDistinctPayees 数组将包含以下值：Hobby Shop, Mortgage, Animal Hospital, Second Mortgage, Car Loan, General Cable - Cottage, General Cable, Green Power。</p>
<h4 id="unionOfArrays"><a href="#unionOfArrays" class="headerlink" title="@unionOfArrays"></a><strong>@unionOfArrays</strong></h4><p>指定 @unionOfArrays 运算符时，valueForKeyPath: 将创建并返回一个数组，其中包含与正确键路径指定的属性相对应的所有集合组合的所有对象，而不删除重复项。</p>
<p>获取 arrayOfArrays 内所有数组中的 payee 属性的值：。</p>
<blockquote>
<p><code>NSArray *collectedPayees = [arrayOfArrays valueForKeyPath:@&quot;@unionOfArrays.payee&quot;];</code></p>
</blockquote>
<p>生成的 collectedPayees 数组包含以下值：Green Power、Green Power、Green Power、Car Loan、Car Loan、Car Loan、General Cable、General Cable、General Cable、Mortgage、Mortgage、Mortgage、Mortgage、Animal Hospital、General Cable - Cottage、General Cable - Cottage、General Cable - Cottage、Second Mortgage、Second Mortgage、Second Mortgage、Hobby Shop。</p>
<h4 id="distinctUnionOfSets"><a href="#distinctUnionOfSets" class="headerlink" title="@distinctUnionOfSets"></a><strong>@distinctUnionOfSets</strong></h4><p>指定 @distinctUnionOfSets 运算符时，valueForKeyPath: 将创建并返回一个 NSSet 对象，其中包含与右键路径指定的属性相对应的所有集合组合的不同对象。</p>
<p>此运算符的行为与 @distinctUnionOfArrays 类似，不同之处在于它需要一个包含 NSSet 对象实例的 NSSet 实例，而不是 NSArray 实例的 NSArray 实例。此外，它还返回一个 NSSet 实例。假设示例数据存储在集合而不是数组中，则示例调用和结果与 @distinctUnionOfArrays 中显示的结果相同。</p>
<h2 id="表示非对象类型的数据"><a href="#表示非对象类型的数据" class="headerlink" title="表示非对象类型的数据"></a>表示非对象类型的数据</h2><p>NSObject 默认提供的键值编码协议方法实现，既能处理对象类型的属性，也能处理非对象类型（比如标量或结构体）的属性。它的默认实现会在对象类型的参数或返回值，与底层存储的非对象类型属性之间，自动进行封装和拆箱（boxing&#x2F;unboxing）。这样一来，无论属性实际是一个对象，还是一个整型、浮点数或结构体，键值访问方法（getter&#x2F;setter）的参数和返回值签名始终保持为对象类型，接口一致性得以保证。</p>
<blockquote>
<p>注意：</p>
<p>由于 Swift 中的所有属性都是对象，因此本部分仅适用于 Objective-C 属性。</p>
</blockquote>
<p>当您调用协议中的某个获取器，例如 valueForKey: 时，默认实现会根据《访问器搜索模式》中描述的规则确定为指定键提供值的具体访问器方法或实例变量。如果返回值不是对象，获取器会使用该值初始化一个 NSNumber 对象（对于标量）或 NSValue 对象（对于结构），然后返回该对象。</p>
<p>同样，默认情况下，像 setValue:forKey: 这样的 setter 会根据特定的键确定属性访问器或实例变量所需的数据类型。如果数据类型不是对象，setter 会先向传入的值对象发送一个适当的 <type>Value 消息来提取底层数据，并将该数据存储起来。</p>
<blockquote>
<p>注意：</p>
<p>当您使用非对象属性的 nil 值调用 key-value coding 协议的 setter 方法时，setter 方法没有明显的一般处理方式。因此，它会向接收 setter 调用的对象发送一个 setNilValueForKey: 消息。默认实现会抛出一个 NSInvalidArgumentException 异常，但子类可以覆盖此行为，例如设置一个标记值或提供一个有意义的默认值。</p>
</blockquote>
<h3 id="包装和解包标量类型"><a href="#包装和解包标量类型" class="headerlink" title="包装和解包标量类型"></a>包装和解包标量类型</h3><p>表 5-1 列出了默认键值编码实现使用 NSNumber 实例包装的标量类型。对于每种数据类型，表格显示了用于从底层属性值初始化 NSNumber 以提供 getter 返回值的创建方法。然后显示了在设置操作中从 setter 输入参数提取值的访问器方法。</p>
<p>表 5-1 中的标量类型作为 NSNumber 对象的封装</p>
<table>
<thead>
<tr>
<th>Data type</th>
<th>Creation method</th>
<th>Accessor method</th>
</tr>
</thead>
<tbody><tr>
<td>BOOL</td>
<td>numberWithBool:</td>
<td>boolValue(在 iOS 中)<br>charValue(在 macOS 中)</td>
</tr>
<tr>
<td>char</td>
<td>numberWithChar:</td>
<td>charValue</td>
</tr>
<tr>
<td>double</td>
<td>numberWithDouble:</td>
<td>doubleValue</td>
</tr>
<tr>
<td>float</td>
<td>numberWithFloat:</td>
<td>floatValue</td>
</tr>
<tr>
<td>int</td>
<td>numberWithInt:</td>
<td>intValue</td>
</tr>
<tr>
<td>long</td>
<td>numberWithLong:</td>
<td>longValue</td>
</tr>
<tr>
<td>long long</td>
<td>numberWithLongLong:</td>
<td>longLongValue</td>
</tr>
<tr>
<td>short</td>
<td>numberWithShort:</td>
<td>shortValue</td>
</tr>
<tr>
<td>unsigned char</td>
<td>numberWithUnsignedChar:</td>
<td>unsignedChar</td>
</tr>
<tr>
<td>unsigned int</td>
<td>numberWithUnsignedInt:</td>
<td>unsignedInt</td>
</tr>
<tr>
<td>unsigned long</td>
<td>numberWithUnsignedLong:</td>
<td>unsignedLong</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>numberWithUnsignedLongLong:</td>
<td>unsignedLongLong</td>
</tr>
<tr>
<td>unsigned short</td>
<td>numberWithUnsignedShort:</td>
<td>unsignedShort</td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<p>在 macOS 中，由于历史原因， BOOL 被定义为 signed char 类型，而 KVC 不区分这两种类型。因此，当你使用一个 BOOL 类型的键时，不应该传递字符串值如 @“true” 或 @“YES” 给 setValue:forKey: 。KVC 会尝试调用 charValue （因为 BOOL 本质上是 char 类型），但 NSString 并没有实现这个方法，这会导致运行时错误。相反，当你使用一个 BOOL 类型的键时，应该只传递一个 NSNumber 对象，如 @(1) 或 @(YES) 作为 setValue:forKey: 方法的值参数。这种限制在 iOS 中并不适用，因为在 iOS 中 BOOL 被定义为原生的布尔类型 bool ，KVC 会调用 boolValue ，它可以处理 NSNumber 对象或格式正确的 NSString 对象。</p>
</blockquote>
<h3 id="包装和解包结构类型"><a href="#包装和解包结构类型" class="headerlink" title="包装和解包结构类型"></a>包装和解包结构类型</h3><p>表 5-2 列出了默认访问器用于包装和解包常见的 NSPoint 、 NSRange 、 NSRect 和 NSSize 结构的创建和访问方法。</p>
<p>表 5-2 中常见的 struct 类型是如何使用 NSValue 进行包装的。</p>
<table>
<thead>
<tr>
<th>Data type</th>
<th>Creation method</th>
<th>Accessor method</th>
</tr>
</thead>
<tbody><tr>
<td>NSPoint</td>
<td>valueWithPoint:</td>
<td>pointValue</td>
</tr>
<tr>
<td>NSRange</td>
<td>valueWithRange::</td>
<td>rangeValue</td>
</tr>
<tr>
<td>NSRect</td>
<td>valueWithRect: (仅限 macOS)</td>
<td>rectValue</td>
</tr>
<tr>
<td>NSSize</td>
<td>valueWithSize:</td>
<td>sizeValue</td>
</tr>
</tbody></table>
<p>自动包装和解包不仅限于 NSPoint 、 NSRange 、 NSRect 和 NSSize 。结构类型（即其 Objective-C 类型编码字符串以 { 开头的类型）可以被包装成一个 NSValue 对象。例如，考虑在列表 5-1 中声明的结构和类接口。</p>
<p>列表 5-1 一个使用自定义结构的示例类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">&#125; ThreeFloats;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) ThreeFloats threeFloats;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>通过名为 myClass 的此类实例，您可以使用键值编码获取 threeFloats 的值</p>
<blockquote>
<p><code>NSValue* result = [myClass valueForKey:@&quot;threeFloats&quot;]; </code></p>
</blockquote>
<p>默认实现的 valueForKey: 调用 threeFloats 的获取器方法，然后将结果包装在一个 NSValue 对象中返回。</p>
<p>同样，你可以使用键值编码设置 threeFloats 的值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ThreeFloats floats = &#123;<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>&#125;;</span><br><span class="line"><span class="built_in">NSValue</span>* value = [<span class="built_in">NSValue</span> valueWithBytes:&amp;floats objCType:<span class="keyword">@encode</span>(ThreeFloats)];</span><br><span class="line">[myClass setValue:value forKey:<span class="string">@&quot;threeFloats&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>默认实现会通过 getValue: 消息解包值，然后使用结果结构调用 setThreeFloats: 。</p>
<h2 id="验证属性"><a href="#验证属性" class="headerlink" title="验证属性"></a>验证属性</h2><p>键值编码协议定义了方法来支持属性验证。就像你使用基于键的访问器来读取和写入键值编码兼容对象的属性一样，你也可以通过键（或键路径）来验证属性。当你调用 validateValue:forKey:error: （或 validateValue:forKeyPath:error: ）方法时，协议的默认实现会在接收验证消息的对象（或键路径的终点对象）中搜索一个方法，该方法的名称符合 validate<Key>:error: 的模式。如果对象没有这样的方法，验证默认成功，并返回 YES 。当存在特定于属性的验证方法时，协议的默认实现会调用该方法并返回其结果。</p>
<blockquote>
<p>注意</p>
<p>通常你只在 Objective-C 中使用这里描述的验证。在 Swift 中，属性验证通常通过依赖编译器对可选类型和强类型检查的支持来处理，同时使用内置的 willSet 和 didSet 属性观察者来测试任何运行时 API 合约，如《Swift 编程语言（Swift 3）》一书的属性观察者部分所述。</p>
</blockquote>
<p>因为属性特定的验证方法通过引用接收值和错误参数，验证可能有三种结果：</p>
<ol>
<li><p>验证方法认为值对象有效，并返回 YES ，而不修改值或错误。</p>
</li>
<li><p>验证方法认为值对象无效，但不对其进行修改。在这种情况下，该方法返回 NO ，并设置错误引用（如果由调用者提供）为一个表示失败原因的 NSError 对象。</p>
</li>
<li><p>验证方法认为值对象无效，但会创建一个新的有效对象作为替代。在这种情况下，方法返回 YES ，同时保留错误对象不变。在返回之前，方法会修改值引用，使其指向新的值对象。每当进行修改时，方法总是会创建一个新的对象，而不是修改旧的对象，即使该对象是可变的。</p>
</li>
</ol>
<p>列表 6-1 展示了如何为名称字符串调用验证的示例。</p>
<p>列表 6-1 名称属性的验证</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person* person = [[Person alloc] init];</span><br><span class="line"><span class="built_in">NSError</span>* error;</span><br><span class="line"><span class="built_in">NSString</span>* name = <span class="string">@&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (![person validateValue:&amp;name forKey:<span class="string">@&quot;name&quot;</span> error:&amp;error]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动验证"><a href="#自动验证" class="headerlink" title="自动验证"></a>自动验证</h3><p>通常，键值编码协议及其默认实现并未定义任何自动执行验证的机制。相反，您应在适当的情况下使用验证方法。</p>
<p>某些其他 Cocoa 技术在某些情况下会自动进行验证。例如，Core Data 在保存管理对象上下文时会自动进行验证（参见 Core Data 编程指南）。此外，在 macOS 中，Cocoa 绑定允许您指定验证应自动进行（参见 Cocoa 绑定编程主题以获取更多信息）。</p>
<h2 id="访问器搜索模式"><a href="#访问器搜索模式" class="headerlink" title="访问器搜索模式"></a>访问器搜索模式</h2><p>键值编码协议的默认实现由 <code>NSObject</code> 提供，通过一组明确定义的规则将基于键的访问器调用映射到对象的底层属性。这些协议方法使用一个键参数，在其自身对象实例中搜索访问器、实例变量以及遵循特定命名约定的相关方法。尽管你很少会修改这种默认搜索，但了解其工作原理对于追踪键值编码对象的行为以及使自己的对象符合要求都是很有帮助的。</p>
<blockquote>
<p>注意</p>
<p>本节中的描述使用了 <code>&lt;key&gt;</code> 或 <code>&lt;Key&gt;</code> 作为占位符，代表出现在某个键值编码协议方法参数中的键字符串，该方法随后使用该字符串作为次要方法调用或变量名查找的一部分。映射的属性名称遵循占位符的大小写。例如，对于获取器 <code>&lt;key&gt;</code> 和 <code>is&lt;Key&gt;</code>，名为 hidden 的属性映射到 <code>hidden</code> 和 <code>isHidden</code>。</p>
</blockquote>
<h3 id="基本-getter-的搜索模式"><a href="#基本-getter-的搜索模式" class="headerlink" title="基本 getter 的搜索模式"></a>基本 getter 的搜索模式</h3><p>默认实现的 valueForKey: ，在接收到 valueForKey: 参数时，会在接收该调用的类实例内部执行以下过程。</p>
<ol>
<li><p>首先，在实例中查找第一个名为 get<Key> 、 <key> 、 is<Key> 或 _<key> 的访问器方法。如果找到该方法，则调用它，并将结果作为输入进行第 5 步。否则，继续下一步。</p>
</li>
<li><p>如果没有找到简单的访问器方法，则在实例中查找名称匹配 countOf<Key> 和 objectIn<Key>AtIndex: （对应于 NSArray 类定义的原始方法）以及 <key>AtIndexes: （对应于 NSArray 方法 objectsAtIndexes: ）的方法。</p>
<p> 如果找到了第一个这些方法，并且至少找到了另外两个方法中的一个，则创建一个集合代理对象，该对象能够响应所有 NSArray 方法，并返回该对象。否则，继续下一步。</p>
<p> 代理对象随后会将接收到的任何 NSArray 消息转换为对符合键值编码的对象的一些 countOf<Key> 、 objectIn<Key>AtIndex: 和 <key>AtIndexes: 消息。如果原始对象还实现了一个可选的方法，其名称类似于 get<Key>:range: ，代理对象在适当的情况下也会使用该方法。实际上，代理对象与符合键值编码的对象一起工作，使得底层属性的行为类似于 NSArray ，即使它不是。</p>
</li>
<li><p>如果未找到简单的访问器方法或一组数组访问方法，则查找名为 countOf<Key> 、 enumeratorOf<Key> 和 memberOf<Key>: 的三组方法（对应于由 NSSet 类定义的基本方法）。</p>
<p> 如果找到了这三个方法，创建一个集合代理对象，该对象能够响应所有 NSSet 消息，并返回该对象。否则，继续执行步骤 4。</p>
<p> 代理对象随后会将接收到的任何 NSSet 消息转换为对创建它的对象的一些 countOf<Key> 、 enumeratorOf<Key> 和 memberOf<Key>: 消息。实际上，代理对象与符合键值编码的对象一起工作，使得底层属性的行为类似于 NSSet ，即使它不是。</p>
</li>
<li><p>如果未找到简单的访问器方法或集合访问器方法组，并且接收者的类方法 accessInstanceVariablesDirectly 返回 YES ，则按顺序查找名为 _<key> 、 _is<Key> 、 <key> 或 is<Key> 的实例变量。如果找到，直接获取实例变量的值并进行第 5 步。否则，进行第 6 步。</p>
</li>
<li><p>如果检索到的属性值是对象指针，则直接返回结果。</p>
<p> 如果值是 NSNumber 支持的标量类型，则将其存储在 NSNumber 实例中并返回该实例。</p>
<p> 如果结果是 NSValue 不支持的标量类型，则将其转换为 NSValue 对象并返回该对象。</p>
</li>
<li><p>如果其他方法都无效，可以调用 valueForUndefinedKey: 。默认情况下，这会抛出异常，但 NSObject 的子类可以提供特定于键的行为。</p>
</li>
</ol>
<h3 id="基本-setter-的搜索模式"><a href="#基本-setter-的搜索模式" class="headerlink" title="基本 setter 的搜索模式"></a>基本 setter 的搜索模式</h3><p>给定 key 和 value 参数， setValue:forKey: 的默认实现尝试在接收调用的对象中将名为 key 的属性设置为 value （或者，对于非对象属性，设置为其未包装的版本，如在表示非对象值中所述），使用以下步骤：</p>
<ol>
<li><p>首先查找名为 set<Key>: 或 _set<Key> 的第一个访问器。如果找到，使用输入值（或根据需要的未包装值）调用它并结束。</p>
</li>
<li><p>如果未找到简单的访问器，并且类方法 accessInstanceVariablesDirectly 返回 YES ，则查找名为 _<key> 、 _is<Key> 、 <key> 或 is<Key> 的实例变量（按此顺序）。如果找到，则直接使用输入值（或未包装值）设置该变量并结束。</p>
</li>
<li><p>若未找到访问器或实例变量，则调用 setValue:forUndefinedKey: 。默认情况下这将引发异常，但 NSObject 的子类可以提供特定键的行为。</p>
</li>
</ol>
<h3 id="可变数组的搜索模式"><a href="#可变数组的搜索模式" class="headerlink" title="可变数组的搜索模式"></a>可变数组的搜索模式</h3><p>给定一个 key 参数， mutableArrayValueForKey: 的默认实现返回一个代理数组，该数组用于接收访问器调用的对象中的名为 key 的属性，具体步骤如下：</p>
<ol>
<li><p>寻找名为 insertObject:in<Key>AtIndex: 和 removeObjectFrom<Key>AtIndex: 的方法对（分别对应 NSMutableArray 原始方法 insertObject:atIndex: 和 removeObjectAtIndex: ），或者名为 insert<Key>:atIndexes: 和 remove<Key>AtIndexes: 的方法对（分别对应 NSMutableArray 、 insertObjects:atIndexes: 和 removeObjectsAtIndexes: 方法）。</p>
<p> 如果对象至少有一个插入方法和至少一个移除方法，返回一个代理对象，该对象通过发送 insertObject:in<Key>AtIndex: 、 removeObjectFrom<Key>AtIndex: 、 insert<Key>:atIndexes: 和 remove<Key>AtIndexes: 方法的消息来响应 NSMutableArray 消息，这些消息是发送给 mutableArrayValueForKey: 的原始接收者的。</p>
<p> 当对象接收 mutableArrayValueForKey: 消息时，如果该对象还实现了可选的替换对象方法，方法名为 replaceObjectIn<Key>AtIndex:withObject: 或 replace<Key>AtIndexes:with<Key>: ，则代理对象在适当的情况下也会利用这些方法以获得最佳性能。</p>
</li>
<li><p>如果对象没有可变数组方法，而是寻找一个方法名符合 set<Key>: 模式的访问器方法。在这种情况下，返回一个代理对象，该对象通过向 mutableArrayValueForKey: 的原始接收者发送 set<Key>: 消息来响应 NSMutableArray 消息。</p>
<blockquote>
<p>注意</p>
<p>本步骤描述的机制比上一步骤的效率要低得多，因为它可能会反复创建新的集合对象，而不是修改现有的对象。因此，在设计自己的符合键值编码的对象时，你应该尽量避免使用这种方法。</p>
</blockquote>
</li>
<li><p>如果既没有找到可变数组方法，也没有找到访问器，且接收者的类响应 YES 方法 accessInstanceVariablesDirectly ，则按顺序查找名为 _<key> 或 <key> 的实例变量。</p>
<p> 如果找到了这样的实例变量，则返回一个代理对象，该对象将接收到的每个 NSMutableArray 消息转发给实例变量的值，通常该值是 NSMutableArray 的实例或其子类的实例。</p>
</li>
<li><p>如果所有方法都失败了，则返回一个可变集合代理对象，该对象在接收到 NSMutableArray 消息时，向原始接收者 mutableArrayValueForKey: 消息的接收者发出 setValue:forUndefinedKey: 消息。</p>
<p> 默认的 setValue:forUndefinedKey: 实现会抛出一个 NSUndefinedKeyException 错误，但子类可以覆盖这种行为。</p>
</li>
</ol>
<h3 id="可变有序集合的搜索模式"><a href="#可变有序集合的搜索模式" class="headerlink" title="可变有序集合的搜索模式"></a>可变有序集合的搜索模式</h3><p>mutableOrderedSetValueForKey: 的默认实现与 valueForKey: 认识到相同的基本访问器方法和有序集合访问器方法（参见基本获取器的默认搜索模式），并且遵循相同的直接实例变量访问策略，但总是返回一个可变集合代理对象，而不是 valueForKey: 返回的不可变集合。此外，它还会执行以下操作：</p>
<ol>
<li><p>搜索名称类似于 insertObject:in<Key>AtIndex: 和 removeObjectFrom<Key>AtIndex: （对应于 NSMutableOrderedSet 类定义的两个最基本的方法）以及 insert<Key>:atIndexes: 和 remove<Key>AtIndexes: （对应于 insertObjects:atIndexes: 和 removeObjectsAtIndexes: ）的方法。</p>
<p> 如果找到至少一个插入方法和至少一个移除方法，当代理对象接收到 NSMutableOrderedSet 消息时，它会向原始接收者发送 insertObject:in<Key>AtIndex: 、 removeObjectFrom<Key>AtIndex: 、 insert<Key>:atIndexes: 和 remove<Key>AtIndexes: 消息中的某些组合消息。</p>
<p> 代理对象在原对象中存在类似 replaceObjectIn<Key>AtIndex:withObject: 或 replace<Key>AtIndexes:with<Key>: 的方法时也会使用这些方法。</p>
</li>
<li><p>如果未找到可变集合方法，则会搜索类似 set<Key>: 的访问器方法。在这种情况下，每次代理对象接收到 NSMutableOrderedSet 消息时，都会向原 mutableOrderedSetValueForKey: 接收者发送一个 set<Key>: 消息。</p>
<blockquote>
<p>注意：</p>
<p>本步骤中描述的机制比上一步骤中的机制效率低得多，因为它可能会反复创建新的集合对象而不是修改现有的一个。因此，在设计您自己的符合键值编码的对象时，您应该尽量避免使用它。</p>
</blockquote>
</li>
<li><p>如果既没有找到可变集合消息也没有找到访问器，并且接收者的 accessInstanceVariablesDirectly 类方法返回 YES ，则按顺序查找一个名为 _<key> 或 <key> 的实例变量。如果找到了这样的实例变量，返回的代理对象会将接收到的 NSMutableOrderedSet 消息转发给该实例变量的值，该值通常是 NSMutableOrderedSet 或其子类的一个实例。</p>
</li>
<li><p>如果所有方法都失败了，返回的代理对象会在接收到可变集合消息时，向原始接收者 mutableOrderedSetValueForKey: 发送一个 setValue:forUndefinedKey: 消息。</p>
<p> setValue:forUndefinedKey: 的默认实现会抛出一个 NSUndefinedKeyException 异常，但对象可以覆盖此行为。</p>
</li>
</ol>
<h3 id="可变集合的搜索模式"><a href="#可变集合的搜索模式" class="headerlink" title="可变集合的搜索模式"></a>可变集合的搜索模式</h3><p>mutableSetValueForKey: 的默认实现，给定一个 key 参数作为输入，返回一个指向接收访问器调用的对象内部名为 key 的数组属性的可变代理集合，采用以下步骤：</p>
<ol>
<li><p>搜索名称类似于 add<Key>Object: 和 remove<Key>Object: （分别对应于 NSMutableSet 原始方法 addObject: 和 removeObject: ）以及 add<Key>: 和 remove<Key>: （分别对应于 NSMutableSet 方法 unionSet: 和 minusSet: ）的方法。如果至少找到一个添加方法和一个移除方法，则返回一个代理对象，该对象在接收到 add<Key>Object: 消息时，将发送 remove<Key>Object: 、 add<Key>: 、 remove<Key>: 中的某些组合消息到原始接收者 mutableSetValueForKey: 。</p>
</li>
<li><p>如果 mutableSetValueForKey: 调用的接收者是一个受管理的对象，则搜索模式不会继续，就像对于非受管理的对象那样。有关更多信息，请参阅《Core Data 编程指南》中的受管理对象访问器方法。</p>
</li>
<li><p>如果找不到可变集合方法，并且对象不是管理对象，则搜索一个名为 set<Key>: 的访问器方法。如果找到这样的方法，返回的代理对象会将它接收到的每个 set<Key>: 消息转发给原始接收者 mutableSetValueForKey: 。</p>
<blockquote>
<p>注意</p>
<p>本步骤中描述的机制比第一步的机制效率低得多，因为它可能会反复创建新的集合对象而不是修改现有的对象。因此，在设计自己的符合键值编码的对象时，您应该尽量避免使用它。</p>
</blockquote>
</li>
<li><p>如果找不到可变集合方法和访问器方法，并且 accessInstanceVariablesDirectly 类方法返回 YES ，则按顺序搜索一个名为 _<key> 或 <key> 的实例变量。如果找到这样的实例变量，代理对象会将它接收到的每个 NSMutableSet 消息转发给实例变量的值，该值通常是 NSMutableSet 或其子类的一个实例。</p>
</li>
<li><p>如果所有其他方法都失败了，返回的代理对象会将接收到的 NSMutableSet 消息转发给原始接收者 mutableSetValueForKey: ，并发送一个 setValue:forUndefinedKey: 消息。</p>
</li>
</ol>
<hr>
<blockquote>
<p>重要提示：</p>
<p>作为 iOS，macOS，或 Apple 生态应用层开发者，只要你的类继承自 NSObject，就完全不必阅读和理解文档里的以下这一章 —— NSObject 已经帮你把所有默认的 KVC 行为（包括 to-many 集合代理）都做好了。</p>
</blockquote>
<h1 id="采用键值编码协议"><a href="#采用键值编码协议" class="headerlink" title="采用键值编码协议"></a>采用键值编码协议</h1><h2 id="实现基本键值编码合规性"><a href="#实现基本键值编码合规性" class="headerlink" title="实现基本键值编码合规性"></a>实现基本键值编码合规性</h2><h2 id="定义集合方法"><a href="#定义集合方法" class="headerlink" title="定义集合方法"></a>定义集合方法</h2><h2 id="处理非对象值"><a href="#处理非对象值" class="headerlink" title="处理非对象值"></a>处理非对象值</h2><h2 id="添加验证"><a href="#添加验证" class="headerlink" title="添加验证"></a>添加验证</h2><h2 id="描述属性关系"><a href="#描述属性关系" class="headerlink" title="描述属性关系"></a>描述属性关系</h2><h2 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h2><h2 id="合规性检查清单"><a href="#合规性检查清单" class="headerlink" title="合规性检查清单"></a>合规性检查清单</h2>]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
      <tags>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Associative References</title>
    <url>/2025/06/06/Associative-References/</url>
    <content><![CDATA[<!--
1. 分类中能不能添加属性？实践得知，可以添加属性，但是不会生成成员变量导致无法正常存取值。
2. 那么问题就来了，为什么 Objective-C 语言设计了 Category 语法，但是又不能通过 Category 添加成员变量呢？
3. 虽然在 Category 中无法添加成员变量，但是 objc/runtime.h 提供了 Associative References 技术实现在分类中添加属性也能实现类似成员变量的效果
4. Associative References 的使用，只有 3 个 API，使用起来很简单的。
5. Associative References 的底层原理。就是 API 的底层实现。在 objc4 源码中的 objc-references.mm 文件中。
-->

<h1 id="分类能否添加属性？实例变量？"><a href="#分类能否添加属性？实例变量？" class="headerlink" title="分类能否添加属性？实例变量？"></a>分类能否添加属性？实例变量？</h1><p>在讲解 Associative References 为为何物之前，我们先看一下这个问题：</p>
<blockquote>
<p>分类中能否添加实例变量？如果可以如何添加？如果不可以，解释为什么？</p>
</blockquote>
<p>可以通过编译器看看能否在分类中添加实例变量：</p>
<img src="/2025/06/06/Associative-References/Snip20250607_1.png" class="">

<p>如上图所示，在分类中虽然可以添加属性，但是并不会生成对应的实例变量，也无法手动添加实例变量。编译器提示，实例变量不能放在分类中。那么现在的问题是，为什么 Objective-C 语言设计了分类语法，但是分类中却无法给类添加实例变量？</p>
<p>Objective-C 的分类 (@category) 被设计为一个​​轻量级、无侵入式​​扩展已有类的方式，其首要目标是​​添加方法（包括实例方法和类方法）​​，而不是修改类的实例结构。不允许添加成员变量（实例变量&#x2F;ivar）是经过深思熟虑的设计选择，主要原因如下：</p>
<ol>
<li><strong>保持运行时稳定性和避免内存布局冲突（核心原因）：</strong><ul>
<li>当你定义一个类时，编译器会为其创建固定的内存布局信息（类结构在底层的定义 objc_class），其中包含了实例变量（ivars）的名称、类型、偏移量等信息。编译后的代码（包括其他可能依赖这个类的代码）以及运行时环境都基于这个布局信息来访问对象的数据（比如 object-&gt;ivar）。</li>
<li>如果分类可以添加 ivars，这就意味着​​<strong>需要在运行时动态改变类的内存布局​​</strong>！想象一下：<ul>
<li>程序启动，类 A 被加载，它的内存布局是固定的 (包含 ivar1, ivar2)。</li>
<li>稍后，一个包含新增 ivar3 的分类被加载。运行时必须尝试“扩展”类 A 的内存布局来容纳 ivar3。</li>
<li>所有已经存在的类 A 的实例都需要被“调整”！因为之前创建时并没有预留 ivar3 的空间。这不仅成本极高（遍历所有现有实例并调整大小几乎不可能高效完成），而且在多线程环境下极其脆弱。</li>
<li>更重要的是，任何编译时依赖于原内存布局的代码（如直接使用偏移量访问成员变量的代码——编译器优化后常有）会立即出错，因为 ivar1 和 ivar2 的偏移量很可能因为新增了 ivar3 而改变。</li>
</ul>
</li>
<li>这种对内存布局的动态修改会引入巨大的不稳定性、兼容性问题和性能瓶颈。禁止分类添加 ivars 确保了类一旦被编译和加载，其基结构就是稳定的。</li>
</ul>
</li>
<li>内存管理和生命周期复杂性：<ul>
<li>成员变量是对象的一部分，与对象本身具有相同的生命周期（随对象创建而创建，随对象销毁而销毁）。内存管理也由其所属类（或其父类）负责。</li>
<li>如果分类可以添加 ivars，那么这个变量内存的分配、初始化（构造函数逻辑放在哪？）、析构（析构函数逻辑放在哪？）、内存管理（如 retain&#x2F;release，ARC 时代自动合成）的职责归属就变得模糊不清。它打破了类本身对其实例数据的单一管理责任原则。特别是当多个分类都试图管理自己的 ivars 时，问题会变得非常混乱。分类本身也不具有像类那样的初始化（+initialize）和析构机制。</li>
</ul>
</li>
<li>分类的设计哲学：无状态的行为扩展：​​<ul>
<li>分类的主要设计目的是​​扩展类的行为（方法）​​，而不是​​修改类或实例的状态（数据）​​。它让你可以：<ul>
<li>为系统类或第三方类添加新功能（方法）。</li>
<li>将一个庞大类的实现分拆到多个文件中（模块化管理）。</li>
<li>声明那些本应是私有的方法（在实现文件里声明匿名分类&#x2F;类扩展 @interface ClassName ()）来避免公开声明。</li>
</ul>
</li>
<li>它被设计为一种​​相对安全、隔离的方式​​来添加功能。添加方法通常不会破坏已有的代码或内存布局（重写现有方法或类方法除外，那需要谨慎）。保持分类“无状态”（指不携带自己的数据）是这个安全隔离的关键。</li>
</ul>
</li>
<li>替代方案：关联对象<ul>
<li>虽然不能直接添加 ivars，但 Objective-C 运行时提供了 ​​关联对象（Associated Objects）​​ 机制来模拟给已有类的实例动态添加关联值（不是真正的实例变量！）。</li>
<li>原理：运行时维护一个全局的弱引用表，将键值对（key-value）关联到指定的对象实例上。访问关联对象时，通过这个表和对象实例来查找。</li>
<li>关键区别：<ul>
<li><strong>内存位置</strong>：​​ Ivars 存储在对象实例内部的内存块中。关联对象存储在运行时管理的独立表中。</li>
<li><strong>访问速度</strong>：​​ Ivar 访问是直接的内存偏移访问，非常快。关联对象访问需要查表，相对慢一些（虽然对于绝大多数应用场景可忽略）。</li>
<li><strong>生命周期</strong>：​​ Ivars 与对象共存亡。关联对象可以通过策略（objc_AssociationPolicy）来控制其生命周期是随对象保留（OBJC_ASSOCIATION_RETAIN）、复制（OBJC_ASSOCIATION_COPY）还是赋值（OBJC_ASSOCIATION_ASSIGN），并且在对象释放时自动清理（根据策略）。但这需要手动管理策略。</li>
<li><strong>管理责任</strong>：​​ Ivars 是类定义的一部分，内存管理责任清晰（由类或父类负责）。关联对象的管理责任在添加分类的代码上。</li>
</ul>
</li>
<li>关联对象的权衡：​​ 关联对象提供了一种灵活性，但也引入了间接访问、潜在的循环引用风险（如果策略选择不当）和轻微的性能开销。语言设计者选择了在分类中添加“成员变量”的责任交给开发者显式地通过关联对象来实现，而不是破坏类实例内存布局的稳定性和简洁性。</li>
</ul>
</li>
</ol>
<p>Objective-C 限制分类添加成员变量是一个深思熟虑的设计决策，核心目的是：</p>
<ul>
<li><strong>保证运行时稳定</strong>：​​ 防止动态修改已加载类的内存布局而导致崩溃和不可预测行为。</li>
<li>​​<strong>明确内存管理责任</strong>：​​ 避免与类和对象固有生命周期管理模型冲突。</li>
<li><strong>维护分类的设计初衷</strong>：​​ 专注于安全、无状态地扩展行为（方法），而非状态（数据）。分类应该是功能的“插件”，而不是修改类根基的“手术刀”。</li>
</ul>
<h1 id="Associative-References"><a href="#Associative-References" class="headerlink" title="Associative References"></a>Associative References</h1><p>Associative References 中文直译过来是关联引用，在 Xcode 中，使用快捷键 Command + Shift + O 再输入 objc&#x2F;runtime.h 就能看到文件中有一个部分就是 Associative References。它包括了三个 API 和一个枚举类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">OBJC_ENUM</span><span class="params">(<span class="type">uintptr_t</span>, objc_AssociationPolicy)</span> &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies an unsafe unretained reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="type">void</span></span><br><span class="line"><span class="title function_">objc_setAssociatedObject</span><span class="params">(id _Nonnull object, <span class="type">const</span> <span class="type">void</span> * _Nonnull key,</span></span><br><span class="line"><span class="params">                         id _Nullable value, objc_AssociationPolicy policy)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line"><span class="title function_">objc_getAssociatedObject</span><span class="params">(id _Nonnull object, <span class="type">const</span> <span class="type">void</span> * _Nonnull key)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="type">void</span></span><br><span class="line"><span class="title function_">objc_removeAssociatedObjects</span><span class="params">(id _Nonnull object)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.6</span>, <span class="number">3.1</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到 Associative References 是 iOS 3.1 引入的技术。其中经常使用的只有前面两个 API。<code>objc_removeAssociatedObjects(id _Nonnull object)</code> 在 99.999% 的应用开发场景下都绝不应该调用，它仅推荐在某些极端的场景下谨慎的调用。比如：</p>
<ol>
<li>调试与测试：<ul>
<li>在编写单元测试时，你需要确保被测试对象在测试结束后没有任何残留状态（包括关联对象），以便下一个测试在一个干净的环境开始。</li>
<li>在调试极其复杂的内存泄漏或对象状态问题时，你可能想观察移除所有关联对象后对问题的影响（但这通常是最后手段）。</li>
</ul>
</li>
<li>非常特殊的框架或工具：<ul>
<li>如果你在开发一个底层调试工具、一个对象序列化&#x2F;反序列化框架（需要精确控制内存镜像）、或一个对象池实现（需要在对象回收时彻底清除所有外部状态），或许可以考虑在极端谨慎和严格控制上下文中使用它。即使在这里，也需要考虑兼容性问题。</li>
</ul>
</li>
<li>对第三方对象行为的应急干预（极其危险，不推荐）：<ul>
<li>遇到一个行为异常、怀疑其内部关联对象状态混乱的第三方对象，且在无其他解决方案时铤而走险尝试用它“重置”对象。这无异于赌博，极易引入新问题且难以维护。</li>
</ul>
</li>
</ol>
<p>总之应该把这个 API 当作核按钮看待，威力巨大，但按下后的后果通常是灾难性的、不可控的。日常开发中应该使用 <code>objc_setAssociatedObject()</code> 并传入 nil 作为 value 参数来实现移除关联对象。</p>
<p>接着就是如何设置关联对象和获取关联对象了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">associatedObject</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">associatedObject</span>)</span></span><br><span class="line">- (<span class="type">void</span>)setAge:(<span class="built_in">NSUInteger</span>)age &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(age), @(age), OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(age)) unsignedIntegerValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    Person *person1 = [Person new];</span><br><span class="line">    person1.name = <span class="string">@&quot;jack&quot;</span>;</span><br><span class="line">    person1.age = <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    Person *person2 = [Person new];</span><br><span class="line">    person2.name = <span class="string">@&quot;rose&quot;</span>;</span><br><span class="line">    person2.age = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,%zd&quot;</span>, person1.name, person1.age);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,%zd&quot;</span>, person2.name, person2.age);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用 <code>@selector(age)</code> 作为 key 用来存取关联对象。个人认为这种方式是最简洁方便的，当然除了这种方式，还有很多其他取 key 值的方式：</p>
<ul>
<li><code>static const void *kKeyName = &amp;kKeyName;</code> 这种方式及很多其他变体，都需要额外一个全局变量，不论如何都不如 @selector() 来的方便。</li>
<li>直接使用属性名字符串。这种方式同样也比较简洁，不需要额外的变量。但是需要自己拼写属性名字符串，何不直接使用 @selector() 还有编译器提示。</li>
</ul>
<h1 id="关联对象的底层实现"><a href="#关联对象的底层实现" class="headerlink" title="关联对象的底层实现"></a>关联对象的底层实现</h1><p>objc&#x2F;runtime.h 的实现在 objc4 库里面，Apple 开源了这个库，可以在 <a href="https://github.com/apple-oss-distributions/objc4">https://github.com/apple-oss-distributions/objc4</a> 下载到。搜索其中的 API 很容易就能找到实现的位置，位于 objc-references.mm 文件中。其实如果熟悉 C++ 语言的话，实现的代码看起来也不难。</p>
<p>关联对象（Associated Object）功能的大致流程和几个核心 C++ 类之间的关系可以归纳如下：</p>
<ol>
<li>AssociationsManager：全局管理者<ul>
<li>职责：管理所有对象的关联数据，确保线程安全</li>
<li>实现机制：<ul>
<li>内部通过静态变量 _mapStorage 存储全局唯一的 AssociationsHashMap。</li>
<li>使用自旋锁 spinlock_t AssociationsManagerLock 保证多线程环境下的数据安全，构造函数加锁，析构函数解锁。</li>
</ul>
</li>
</ul>
</li>
<li>AssociationsHashMap：全局存储表<ul>
<li>定义：typedef DenseMap&lt;DisguisedPtr<objc_object>, ObjectAssociationMap&gt; AssociationsHashMap;</li>
<li>职责：以对象地址为键，存储每个对象的关联数据表（ObjectAssociationMap）</li>
<li>数据结构：<ul>
<li>键：将对象包装为 DisguisedPtr<objc_object></li>
<li>值：ObjectAssociationMap</li>
</ul>
</li>
</ul>
</li>
<li>ObjectAssociationMap：对象专属关联表<ul>
<li>定义：typedef DenseMap&lt;const void *, ObjcAssociation&gt; ObjectAssociationMap;</li>
<li>职责：存储单个对象的所有关联键值对。</li>
<li>数据结构：<ul>
<li>键：用户传入的 void *key 参数（例如使用 @selector(propertyName) 或静态变量地址）</li>
<li>值：ObjcAssociation（封装关联值和内存管理策略）</li>
</ul>
</li>
</ul>
</li>
<li>ObjcAssociation：关联值包装器<ul>
<li>职责：存储关联值（id _value）和内存管理策略 （uintptr_t _policy）</li>
<li>要点：负责在 <code>objc_setAssociatedObject</code>,<code>objc_getAssociatedObject</code> 中根据 _policy 进行 retain、release、autorelease 等引用计数操作。</li>
</ul>
</li>
</ol>
<p>工作流程图：</p>
<img src="/2025/06/06/Associative-References/47fa45105cca18.png" class="">

<p>Objective-C runtime 就借助这几个 C++ 类高效、安全地在任意对象上动态「挂载」或「取回」任意类型的关联数据。我知道对于很多不熟悉 C++ 的同学来说，不论说明的再如何详细，其实看起来都还是一脸蒙蔽，于是，我使用 Objective-C 语法实现了类似结构的伪代码帮助理解。</p>
<h1 id="使用-Objective-C-模仿关联对象的底层实现"><a href="#使用-Objective-C-模仿关联对象的底层实现" class="headerlink" title="使用 Objective-C 模仿关联对象的底层实现"></a>使用 Objective-C 模仿关联对象的底层实现</h1><p>以下是基于 Objective-C 运行时关联对象底层原理的简化代码模拟，核心还原了四级结构（AssociationsManager → AssociationsHashMap → ObjectAssociationMap → ObjcAssociation）的设计逻辑。代码以伪实现为主，忽略线程安全等细节，重点展示数据结构关联性：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 模拟 ObjcAssociation（封装值和策略）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, ObjcAssociationPolicy) &#123;</span><br><span class="line">    K_OBJC_ASSOCIATION_ASSIGN,</span><br><span class="line">    K_OBJC_ASSOCIATION_RETAIN,</span><br><span class="line">    K_OBJC_ASSOCIATION_COPY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjcAssociation</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> value;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) ObjcAssociationPolicy policy;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ObjcAssociation</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 模拟 ObjectAssociationMap（对象专属关联表）</span></span><br><span class="line"><span class="comment">// 使用 NSMutableDictionary 存储 key → ObjcAssociation 的映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSValue</span> *, ObjcAssociation *&gt; ObjectAssociationMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 模拟 AssociationsHashMap（全局存储表）</span></span><br><span class="line"><span class="comment">// Key: 对象指针的伪装值（DISGUISE(object)），Value: ObjectAssociationMap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSNumber</span> *, ObjectAssociationMap *&gt; AssociationsHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 模拟 AssociationsManager（全局管理者）</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AssociationsManager</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (AssociationsHashMap *)sharedMap;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AssociationsManager</span></span></span><br><span class="line">+ (AssociationsHashMap *)sharedMap &#123;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_globalMap;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _globalMap = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _globalMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关联对象 API 的简化实现</span></span><br><span class="line"><span class="type">void</span> objc_setAssociatedObject_simulated(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="type">id</span> value, ObjcAssociationPolicy policy) &#123;</span><br><span class="line">    <span class="comment">// Step 1: 获取全局 AssociationsHashMap</span></span><br><span class="line">    AssociationsHashMap *globalMap = [AssociationsManager sharedMap];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 2: 生成对象伪装键（模拟 DISGUISE(object)）</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *disguisedKey = @((<span class="built_in">NSUInteger</span>)(__bridge <span class="type">void</span> *)object);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3: 查找或创建 ObjectAssociationMap</span></span><br><span class="line">    ObjectAssociationMap *objMap = globalMap[disguisedKey];</span><br><span class="line">    <span class="keyword">if</span> (!objMap) &#123;</span><br><span class="line">        objMap = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        globalMap[disguisedKey] = objMap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 4: 处理关联值</span></span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        ObjcAssociation *association = [ObjcAssociation new];</span><br><span class="line">        association.value = (policy == OBJC_ASSOCIATION_COPY) ? [value <span class="keyword">copy</span>] : value;</span><br><span class="line">        association.policy = policy;</span><br><span class="line">        <span class="comment">// 存储关联（key 转换为 NSValue 存储）</span></span><br><span class="line">        objMap[[<span class="built_in">NSValue</span> valueWithPointer:key]] = association;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value=nil 时移除关联</span></span><br><span class="line">        [objMap removeObjectForKey:[<span class="built_in">NSValue</span> valueWithPointer:key]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> objc_getAssociatedObject_simulated(<span class="type">id</span> object, <span class="keyword">const</span> <span class="type">void</span> *key) &#123;</span><br><span class="line">    <span class="comment">// 获取全局 AssociationsHashMap</span></span><br><span class="line">    AssociationsHashMap *globalMap = [AssociationsManager sharedMap];</span><br><span class="line">    <span class="built_in">NSNumber</span> *disguisedKey = @((<span class="built_in">NSUInteger</span>)(__bridge <span class="type">void</span> *)object);</span><br><span class="line">    <span class="comment">// 获取 object 对应的 ObjectAssociationMap</span></span><br><span class="line">    ObjectAssociationMap *objMap = globalMap[disguisedKey];</span><br><span class="line">    <span class="comment">// 获取 object 的 key 对应的关联对象</span></span><br><span class="line">    ObjcAssociation *association = objMap[[<span class="built_in">NSValue</span> valueWithPointer:key]];</span><br><span class="line">    <span class="keyword">return</span> association.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>Error Domain=NSURLErrorDomain Code=-999 已取消</title>
    <url>/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<p>今天遇到这么一个问题,在使用 SDWebimage 设置 UIImageView 的图片的时候,发现这个图片<br><code>http://img4.imgtn.bdimg.com/it/u=132600321,3123081067&amp;fm=27&amp;gp=0.jpg</code>怎么也设置不成功,后来调试一看发现</p>
<img src="/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/Snip20180403_4.png" class="">

<p>说是什么已取消,我是一脸懵逼啊,谁 TM 取消了啊???百思不得其解之后网上搜了一下;</p>
<p>嘿,还有人写了个总结</p>
<img src="/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/Snip20180403_5.png" class="">

<p>然而看了上面的总结后发现貌似都没有关系…所以说这个总结也并不全面…后来想想用浏览器打开这个图片试试看,发现浏览器上能正常打开;这下我估计是请求图片的请求头有问题了;于是我将浏览器的请求头和从 APP 发出的请求头都列出来了;如下</p>
<img src="/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/Snip20180403_1.png" class="">

<p><strong>浏览器上的请求头</strong></p>
<img src="/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/Snip20180403_2.png" class="">

<p><strong>使用Charles抓取APP发出的请求头</strong></p>
<p>其实一下子也看不出什么东西出来,那就先从都有的请求头开始试吧,再将 APP 发出的请求头的 User-Agent 设置之后发现能够设置成功了…那么问题就可以这么解释了,这个图片所在的服务器会对请求的 User-Agent 进行判断,具体判断规则是怎样的那我就不得而知了;如果不符合它的规则那么就会请求失败,在上图 Charles 抓包的响应里面可以看到一段 403 Forbidden 的 html 代码,而在 APP 中,就是报的 <code>Error Domain=NSURLErrorDomain Code=-999 &quot;已取消&quot;</code> 的错误</p>
<img src="/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/Snip20180403_6.png" class="">

<p>其实吧,这个问题根本不重要,因为实际我根本不可能使用这个 URL;重要的是解决问题的思路,你得学会一套方法去解决问题,而不是学会解决这个问题…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM之clang插件开发</title>
    <url>/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="最终实现的效果"><a href="#最终实现的效果" class="headerlink" title="最终实现的效果"></a>最终实现的效果</h1><p>在 Xcode 中使用自己编译的 clang 编译自己的源码,并给出符合自己风格或者公司所需的代码规范的提示!还可以给出修复建议</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/a1d5a0b308cd4eccaf650cc097ffc2bf~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在动手开发之前,先了解一下相关理论知识,特别强调 clang 插件开发并不是一件很容易的事情,需要有一定的知识储备,你需要:</p>
<ul>
<li>对 C++ 有一定的了解</li>
<li>对编译原理有一定的了解</li>
</ul>
<p>不想了解,只想直接动手开发 clang 插件的可以直接跳到 clang 插件开发</p>
<h1 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h1><p>计算机语言按照是否需要编译可以分为编译型语言和解释型语言,编译型语言和解释型语言是两种不同的编程语言类型，它们在代码执行方式、性能、开发速度和可移植性等方面存在一些区别。</p>
<ol>
<li><p>执行方式：</p>
<ul>
<li>编译型语言：编译型语言的代码在运行之前需要通过编译器将源代码转换为目标机器的可执行文件。在运行时，计算机直接执行生成的机器码，无需进一步解释。典型的编译型语言包括C、C++、Objective-C、Swift等。</li>
<li>解释型语言：解释型语言的代码在运行时逐行解释执行，而不需要事先进行编译。解释器逐行读取源代码，并将其转换为机器指令并立即执行。典型的解释型语言包括 Python、JavaScript 等。Mac 电脑自带 python 解释器,打开终端,输入 python 命令可以看到</li>
</ul>
</li>
<li><p>性能：</p>
<ul>
<li>编译型语言：由于编译型语言在运行之前已经将源代码转换为机器码，因此通常具有较高的执行速度和更好的性能。编译器可以进行各种优化，提高代码的效率。</li>
<li>解释型语言：解释型语言在每次执行时都需要进行解释，这会导致相对较低的执行速度和较低的性能。然而，一些解释型语言使用了即时编译（Just-in-Time Compilation）技术，可以提高执行速度。</li>
</ul>
</li>
<li><p>开发速度：</p>
<ul>
<li>编译型语言：编译型语言的开发过程需要先编写源代码，然后进行编译。这种过程可能需要额外的时间来编译和构建项目，因此在开发速度上可能相对较慢。</li>
<li>解释型语言：解释型语言通常具有更快的开发速度，因为它们无需编译和构建过程。开发人员可以更快地进行代码修改和测试。</li>
</ul>
</li>
<li><p>可移植性：</p>
<ul>
<li>编译型语言：由于编译型语言的可执行文件是针对特定的目标机器生成的，因此在不同的平台上可能需要重新编译以适应不同的体系结构。这可能导致一定程度的可移植性问题。</li>
<li>解释型语言：解释型语言的代码是在解释器上运行的，因此可以在不同的平台上运行，无需重新编译。这提高了解释型语言的可移植性。</li>
</ul>
</li>
</ol>
<p>需要注意的是，以上的对比只是一般情况下的概括，并不适用于所有编译型和解释型语言。实际上，有些语言可能具有混合型的特性，同时具备编译和解释的能力。此外，编译型和解释型语言在不同的应用场景中都有各自的优势和适用性。选择哪种类型的语言取决于具体的需求和项目要求。本篇文章关注的重点在编译器相关的知识介绍,不会讲解解释器相关的内容。</p>
<h1 id="传统的编译器架构"><a href="#传统的编译器架构" class="headerlink" title="传统的编译器架构"></a>传统的编译器架构</h1><img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/e628f0fbdb7648329be9690deeb3d11d~tplv-k3u1fbpfcp-watermark.png" class="" alt="poo0ql22r7.png">

<p>源代码经过编译器前端处理,结果交给优化器去优化,优化的结果交给编译器后端生成不同平台的机器码,也就是可执行文件,GCC 编译器就是采用这种架构</p>
<ul>
<li>前端(Frontend),对程序员编写的源代码进行<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>生成中间代码</li>
</ul>
</li>
<li>优化器(Optimizer)<ul>
<li>优化前端生成的中间代码</li>
</ul>
</li>
<li>后端(Backend)<ul>
<li>将中间代码处理成不同平台对应的机器码</li>
</ul>
</li>
</ul>
<h1 id="LLVM-架构"><a href="#LLVM-架构" class="headerlink" title="LLVM 架构"></a>LLVM 架构</h1><img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/624557b4d0ab47c5b5f1a5f88f976dac~tplv-k3u1fbpfcp-watermark.png" class="" alt="xxduqqvusx.png">

<p>LLVM 架构下,对传统的编译器架构进行了一步优化，不同的前端和后端使用统一的中间代码 LLVM InterMediate Representation(LLVM IR)</p>
<ul>
<li>如果需要支持一门新的编程语言，只需要实现一个新的前端</li>
<li>如果需要支持一款新的硬件设备，只需要实现一个新的后端</li>
</ul>
<p>优化阶段是一个通用的阶段，他针对的是统一的 LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段的代码做修改。相比之下，GCC 的前端后端没有实现分离，前端后端耦合在了一起，所以 GCC 为了支持一门新的编程语言，或者为了支持一个新的硬件设备，就变得特别困难。比如新增一门语言,如果是 GCC 就还需要编写这门语言生成不同平台的编译器后端,这需要对各个平台的指令都有深刻的了解。反之,如果新增了一个平台,那么还需要同时实现各个语言的编译器前端。LLVM 现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等）</p>
<h1 id="什么是-LLVM"><a href="#什么是-LLVM" class="headerlink" title="什么是 LLVM"></a>什么是 LLVM</h1><p>官方的说法是:<strong>LLVM</strong> 项目是模块化、可重用的编译器和工具链技术的集合。尽管名称如此，<strong>LLVM</strong> 与传统虚拟机关系不大。<strong>LLVM</strong> 并不是一个由首字母组成的缩略词，而是一个独特的项目名称它就叫 <strong>LLVM</strong>。</p>
<p><strong>LLVM</strong> 计划启动于 2000 年,最初是伊利诺伊大学的 Chris Lattner 博士主持开展一个研究项目，目标是提供一种基于 SSA 的现代编译策略，能够支持任意编程语言的静态和动态编译。从那时起，<strong>LLVM</strong> 已发展成为一个由许多子项目组成的伞型项目，其中许多子项目被各种商业和开源项目用于生产，并广泛用于学术研究。2006 年 Chris Lattner 加盟 Apple Inc. 并致力于 <strong>LLVM</strong> 在 Apple 开发体系中的应用，其中的故事后面会讲到。Apple 也是 <strong>LLVM</strong> 计划的主要资助者。Swift 语言的创造者也是 Chris Lattner</p>
<p><strong>个人的理解或者说通俗一点的说法是: LLVM 是一个主要由 C++ 语言编写的,开源的编译器框架,这个项目可以<br>用来编译,分析,优化许多不同语言的源代码;可以用它来实现一门新的编程语言;可以用来分析语法树;可以进行语言的转换;可以开发clang插件;Pass开发代码优化,代码混淆…等等功能</strong></p>
<p>LLVM 的主要子项目有：</p>
<ul>
<li>LLVM 核心库提供了一个现代的独立于源代码和目标平台的优化器，以及对许多流行 CPU 以及一些不太常见的 CPU 的代码生成支持。这些库是围绕称为 LLVM 中间表示（“LLVM IR”）构建的。LLVM 核心库有详细的文档记录，并且特别容易发明自己的语言（或移植现有的编译器）以使用 LLVM 作为优化器和代码生成器。</li>
<li>Clang 是一个“LLVM 原生”C&#x2F;C++&#x2F;Objective-C 编译器前端，旨在提供惊人的快速编译、极其有用的错误和警告消息，并提供一个用于构建出色的源代码级工具的平台。Clang 静态分析器和 clang-tidy 是自动查找代码中错误的工具，并且是可以使用 Clang 前端作为解析 C&#x2F;C++ 代码的库来构建的工具的绝佳示例。</li>
<li>LLDB 项目建立在 LLVM 和 Clang 提供的库的基础上，提供了一个出色的本机调试器。LLVM 项目使用 Clang 的 AST（抽象语法树）和表达式解析器、LLVM JIT（即时编译器）、LLVM 反汇编器等等，从而提供了一个”即插即用”的体验。它的速度非常快，加载符号时比 GDB 更加高效地利用内存。</li>
</ul>
<p>除了 LLVM 的官方子项目之外，还有各种各样的其他项目使用 LLVM 组件来执行各种任务。通过这些外部项目，您可以使用 LLVM 编译 Ruby、Python、Haskell、Rust、D、PHP、Pure、Lua、Julia 和许多其他语言。LLVM 的主要优势在于其多功能性、灵活性和可重用性，这就是它被用于如此广泛的不同任务的原因：从对 Lua 等嵌入式语言进行轻量级 JIT 编译，到为大型超级计算机编译 Fortran 代码，无所不包。</p>
<p>LLVM 是 Apple 目前官方使用的编译器，而该编译器的前端是 Clang，这两个工具都被集成到了 Xcode 里面。在使用 LLVM 之前苹果公司一直使用 GCC 作为官方的编译器。GCC 作为开源世界的编译器标准一直做得不错，但 Apple 对编译工具提出了更高的要求。仗着自己在开源社区的地位(又或者是 GCC 开发者根本忙不过来?)，GCC 开发者对 Apple 的 Objective-C 语言新增的很多特性不予理睬，甚至当 Apple 想做的很多功能需要用模块化的方式来调用 GCC 时，GCC 却一直不给做。一般的公司遇到这种情况可能会选择默默忍受，但乔布斯领导的 Apple 怎么会？</p>
<p>与 GCC 的不和让 Apple 一直在寻找一个高效的、模块化的、协议更放松的开源的编译器替代品。最终，Apple 相中了 Chris Lattner 的 LLVM。Chris Lattner 可是一位大神，他于 2000 年毕业于俄勒冈州波特兰大学计算机科学专业，同年前往 UIUC(伊利诺伊大学厄巴纳香槟分校)，攻读计算机科学硕士和博士学位。在 UIUC 期间，他的 GPA 是 4.0(满分)，并不断地研究探索关于编译器的未知领域，发表了多篇论文。在硕士毕业论文中，他提出了一套完整的在编译时、链接时、运行时甚至是在闲置时优化程序的编译思想，奠定了 LLVM 的基础。LLVM 在 Chris Lattner 念博士时更加的成熟。这项研究让 Chris Lattner 在 2005 年毕业的时候，成为了小有名气的编译器专家。他也因此早早地被 Apple 相中，成为其编译器项目的骨干。进入 Apple 之后，Chris Lattner 首先在 OpenGL 小组做代码优化，把 LLVM 运行时的编译架在 OpenGL 栈上，这样 OpenGL 栈能够产出更高效率的图形代码。这个强大的 OpenGL 实现被用在了后来发布的 Mac OS X 10.5 上。同时，LLVM 的链接优化被直接加入到 Apple 的代码链接器上。 </p>
<p>LLVM 能够实现很多华丽的功能，要归功于 LLVM 自身的新前端 —— Clang。 GCC 系统庞大而笨重，因此，Apple 决定从零开始写 C、C++、Objective-C 语言的前端 Clang，以求完全替代掉 GCC。 Clang 于 2007 年开始开发，C 编译器最早完成，在 2009 年的时候，Objective-C 编译器已经完全可以用于生产环境，而在一年之后，Clang 基本实现了对 C++ 编译的支持。 Clang 一个重要的特性是编译快速、占内存少，而代码质量还比 GCC 来得高。得益于本身健壮的架构和 Apple 的大力支持，Clang 越来越全能，支持的项目越来越多，如 Mac OS X 10.6 时代的 Xcode 和 Interface Builder 等，皆由 Clang 编译。Clang 的加入也代表着 LLVM 真正走向成熟。 此外，Clang 有一个重要的衍生项目是静态分析工具，能够通过自动分析程序的逻辑，在编译时就找出程序可能的 bug 。除了 LLVM 核心和 Clang 以外，LLVM 还包括一些重要的子项目，比如一个原生支持调试多线程程序的调试器 LLDB 和一个 C++ 的标准库 libstdc++ 等等。不光是 Apple，很多的项目和编程语言都从 LLVM 中取得了关键性的技术。</p>
<h1 id="什么是-clang"><a href="#什么是-clang" class="headerlink" title="什么是 clang"></a>什么是 clang</h1><p><a href="https://clang.llvm.org/">Clang</a> 是 LLVM 的项目的子项目。它是 LLVM 架构下的 C&#x2F;C++&#x2F;Objective-C 的编译器前端。诞生之初是为了替代 GCC，提供更快的编译速度。对比 GCC，Clang 具有如下优点：</p>
<ul>
<li>编译速度快:在某些平台上，Clang 的编译速度显著的快过 GCC (Debug模式下编译OC速度比GGC快3倍)</li>
<li>占用内存小: Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右</li>
<li>模块化设计: Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用</li>
<li>诊断信息可读性强:在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，调试和错误报告更容易阅读</li>
<li>设计清晰简单，容易理解，易于扩展增强</li>
</ul>
<h1 id="Clang-与-LLVM-关系"><a href="#Clang-与-LLVM-关系" class="headerlink" title="Clang 与 LLVM 关系"></a>Clang 与 LLVM 关系</h1><img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/56edfefa22b9489489eda33bac51a3a5~tplv-k3u1fbpfcp-watermark.png" class="" alt="1lvzyizdlk.png">

<p>Clang 作为 LLVM 的前端，负责词法分析、语法分析、语义分析，然后生成中间代码。接下来把中间代码转交给优化器，优化器会对中间代码进行与架构无关的代码优化，优化后的代码体积更小、运行速度更快。最终 LLVM 后端会把优化后的中间代码转化为机器码。流程如下：</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/688545e9ef6e4851bbde6582a37016e6~tplv-k3u1fbpfcp-watermark.png" class="" alt="4gah12s0a1.png">

<p>虽然 Clang 是 LLVM 的前端，但是 LLVM 的前端不只有 Clang。Clang 只是为 C、C++、Objective-C 设计的 LLVM 的编译器前端。除此之外，还有为 Swift 设计的编译器前端 Swiftc,兼容 gcc 的 llvm-gcc 前端，GHC 前端等等…这些在前面 LLVM 的配图中可以看到。</p>
<h1 id="LLVM-编译-Objective-C-源码完整流程"><a href="#LLVM-编译-Objective-C-源码完整流程" class="headerlink" title="LLVM 编译 Objective-C 源码完整流程"></a>LLVM 编译 Objective-C 源码完整流程</h1><p>可以使用 clang 查看 Objective-C 源代码的编译完整过程;为了简单,我们使用最简单的 Objective-C 源码,创建一个 main.m 文件,实现如下代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Number 10</span></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> c = a + b + Number;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello, World! %d&quot;</span>, c); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>预处理（Preprocessing）：使用 Clang 预处理器对<code>main.m</code>文件进行预处理。预处理阶段会将源代码中的<code>#import</code>指令替换为相应的头文件内容，展开宏定义，处理条件编译指令等。生成预处理后的源代码。</p>
<p> 输入命令 <code>clang -E main.m -o main_preprocessed.m</code> 之后查看 main_preprocessed.m 文件</p>
 <img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/f5e8e9937a1a4f228086bcf2d7a7d6b2~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">
<p>  可以明显看到我们的宏 <code>Number</code> 被直接替换成了 <code>10</code>,导入的头文件 <code>Foundation/Foundation.h</code> 也没替换成了实际的内容</p>
</li>
<li><p>词法分析（Lexical Analysis）：将预处理后的源代码分解为标记（tokens），例如标识符、关键字、运算符等。对于上述代码，将生成一系列的标记，如<code>#import</code>、<code>&lt;Foundation/Foundation.h&gt;</code>、<code>int</code>、<code>main</code>、<code>@autoreleasepool</code>、<code>NSLog</code>等。</p>
<p> 输入命令 <code>clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</code> 查看 <code>main.m</code> 经过 clang 词法分析后的结果</p>
 <img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/bc7e0553785c422ebcee6c832b7dffd6~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">
</li>
<li><p>语法分析（Parsing）：将标记转换为抽象语法树（Abstract Syntax Tree，AST）。我们的 clang 插件开发就是基于 AST 进行的。语法分析阶段会根据语法规则和上下文，将标记组织为语法树的结构，表示代码的语法结构和关系。对于上述代码，将生成一个包含语法树节点的层次结构，其中包括<code>import</code>、<code>function</code>、<code>expression</code>等节点。</p>
<p> 输入命令 <code>clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code> 查看 <code>main.m</code> 经过 clang 语法分析后的结果，一般都是对 .m 文件进行分析，因为 .m 文件中会导入 .h 头文件</p>
 <img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/95f7122f2e164f0eb5f68c51ba99f3c4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">
<p> 如果对导入了 UIKit.h 等其它系统库头文件的源码文件进行语法分析，需要给 clang 命令指定 SDK 路径，使用 <code>-isysroot sdk路径</code>，以 main.m 为例</p>
 <figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.4.sdk -fmodules -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure>
</li>
<li><p>语义分析（Semantic Analysis）：对 AST 进行语义分析。这一阶段涉及类型检查、符号解析、作用域分析等操作，以确保源代码的语义正确性。例如，检查变量的类型是否匹配、解析函数和类的定义以及查找符号的定义等。</p>
<p> 使用命令 <code>clang -fsyntax-only main.m</code> 可以分析 <code>main.m</code> 文件是否有语法或语义错误,如果没有任何输出就表示没有语义或语法错误</p>
</li>
<li><p>中间代码生成（Intermediate Code Generation）：将 AST 转换为中间表示（LLVM IR）。在 Objective-C 编译流程中，中间代码生成阶段将 AST 转换为 LLVM IR，这是一种抽象的低级表示形式，类似于汇编语言，但比机器码更抽象。LLVM IR 提供了对源代码进行优化和生成目标代码所需的基础。</p>
<p> 使用命令 <code>clang -S -emit-llvm main.m -o main.ll</code> 可以将 main.m 文件处理成 LLVM IR 格式的中间代码。执行上述命令后，Clang 将对<code>main.m</code>文件进行编译，并生成LLVM IR（中间代码）文件<code>main.ll</code>。在这个命令中，<code>-S</code>选项表示只执行编译阶段而不进行汇编和链接。<code>-emit-llvm</code>选项指示 Clang 生成 LLVM IR 作为输出。LLVM IR 是一种低级中间表示，类似于汇编语言，但比机器码更抽象。它可以用于进一步的优化、分析和目标代码生成。执行命令后，您将获得生成的<code>main.ll</code>文件，其中包含<code>main.m</code>的 LLVM IR 代码。您可以使用文本编辑器打开该文件，查看生成的中间代码。请注意，LLVM IR 是针对 LLVM 平台的中间表示，不直接对应特定的机器码。</p>
<p> LLVM IR 有三种不同的表现形式,可以用不同的格式进行表示和展示。</p>
<ul>
<li>文本格式（Textual Format）：通常使用<code>.ll</code>作为文件后缀名，表示 LLVM IR 的文本格式。LLVM IR 的文本格式是人类可读的，类似于类似于汇编语言。它使用类似于 LLVM 汇编的语法，可以用于查看和编辑 LLVM IR 代码。</li>
<li>位码格式（Bitcode Format）：位码格式的文件通常使用<code>.bc</code>作为文件后缀名。这些文件包含了 LLVM IR 的二进制表示。LLVM IR 还可以以二进制形式存储，称为位码（bitcode）。位码是一种紧凑的、可移植的中间表示形式，可以在不同平台和系统上进行传递和处理。位码可以使用<code>llvm-as</code>工具将文本格式的 LLVM IR 转换为位码格式，使用<code>llvm-dis</code>工具将位码格式的 LLVM IR 转换回文本格式。</li>
<li>内存表现形式（In-memory Representation）：LLVM IR 也可以在内存中以数据结构的形式表示。在 LLVM 编程接口中，可以使用 LLVM API 来创建、修改和处理 LLVM IR，而不需要使用文本或位码格式。这种内存表现形式使得可以在程序中动态生成和操作 LLVM IR。</li>
</ul>
</li>
<li><p>优化（Optimization）：对生成的 LLVM IR 进行各种优化，以改善代码的性能和效率。优化阶段使用 LLVM 提供的各种优化技术，例如内联展开、循环优化、指令选择等。这些优化技术可以根据配置和命令行选项进行调整。</p>
<p> Xcode 中集成了优化的选项,如图</p>
 <img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/0e914b5c90c84fa7b9be10d5acfdc675~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">
</li>
<li><p>目标代码生成（Code Generation）：将优化后的 LLVM IR 转换为特定目标机器的机器码。在 Objective-C 编译过程中，LLVM 会根据目标机器的架构、操作系统等信息，将优化后的 LLVM IR 转换为适当的机器码表示。</p>
<p> 使用命令 <code>clang -c main.m -o main.o</code> </p>
<p> 执行上述命令后，Clang将对<code>main.m</code>文件进行编译，并生成目标文件（object file）<code>main.o</code>。在这个命令中，<code>-c</code>选项指示 Clang 只进行编译，不进行链接操作。这将生成与目标平台相关的二进制目标代码。目标文件（object file）是一种机器代码的二进制表示形式，用于后续的链接操作，生成可执行文件或库文件。</p>
</li>
<li><p>链接（Linking）：将生成的目标代码与其他必要的库进行链接，以创建最终的可执行文件或库文件。在 Objective-C 编译过程中，需要链接 Objective-C 运行时库以支持 Objective-C 特定的功能。</p>
<p> 使用命令 <code>clang main.o -o main</code></p>
<p> 执行上述命令后，Clang 将对目标文件<code>main.o</code>进行链接，并生成可执行文件<code>main</code>。在这个命令中，<code>main.o</code>是之前使用 Clang 生成的目标文件，<code>-o</code>选项指定输出文件的名称，这里是<code>main</code>。通过指定输出文件名，您可以自定义生成的可执行文件的名称。链接操作将目标文件与所需的库文件进行关联，并解析符号引用，生成最终的可执行文件。</p>
</li>
</ol>
<hr>
<p>了解了以上理论知识部分之后,我们开始动手开发一个 clang 插件</p>
<h1 id="clang-插件开发"><a href="#clang-插件开发" class="headerlink" title="clang 插件开发"></a>clang 插件开发</h1><p>想要实现最终的效果,需要以下四个步骤</p>
<ol>
<li>下载 LLVM 源码</li>
<li>编译 LLVM 源码得到 clang 可执行文件</li>
<li>编写 clang 插件,编译后得到动态库</li>
<li>集成到 Xcode 中</li>
</ol>
<h2 id="下载-LLVM-源码"><a href="#下载-LLVM-源码" class="headerlink" title="下载 LLVM 源码"></a>下载 LLVM 源码</h2><p>大多数人可能第一步就放弃了,因为 <a href="https://github.com/llvm/llvm-project">LLVM</a> 源码在 github 上并且占用空间以 GB 为单位导致下载不下来,如果没有好的代理可以尝试一下 <a href="https://mirror.tuna.tsinghua.edu.cn/help/llvm-project.git/">清华大学提供的镜像站 </a></p>
<h2 id="编译-LLVM-源码得到-clang-可执行文件"><a href="#编译-LLVM-源码得到-clang-可执行文件" class="headerlink" title="编译 LLVM 源码得到 clang 可执行文件"></a>编译 LLVM 源码得到 clang 可执行文件</h2><p>编译这一步也是很多人放弃的一个环节,毕竟 LLVM 不是一个小项目,比较吃机器的配置,可能需要几个小时,这里推荐使用 ninja 编译,会比直接编译快很多,也是大多数 LLVM 开发者推荐使用的方式,安装 ninja 需要使用 brew ,作为开发者,我相信大多数人电脑上都已经安装 <a href="https://brew.sh/">brew</a> ,如果没有那就去官网下载安装,如果喜欢使用图形用户界面的 brew 可以尝试一下 <a href="https://www.cakebrew.com/">cakebrew</a> ,打开 cakebrew 可以很方便的管理,下载,更新,查看电脑上的这些工具</p>
<p>brew 安装好之后,可以使用以下方式安装好 cmake 和 ninja</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install cmake</span><br><span class="line">brew install ninja</span><br></pre></td></tr></table></figure>

<p>或者在 cakebrew 上搜索并安装</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/049a1a8ac81246f59fe375e620451a73~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/8d76153759aa40c68872377c64f15e92~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>上面两个工具都安装好之后,打开终端进入 LLVM 源码目录,输入以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为 clang 是 LLVM 的子项目,LLVM 默认只编译它的核心库,不会编译子项目所以需要添加参数 <code>-DLLVM_ENABLE_PROJECTS=&quot;clang&quot;</code> 这一步只是生成 ninja 相关文件,并不是真正的编译,还需要执行以下命令才是真正开始编译 LLVM 和 clang</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ninja -C build</span><br></pre></td></tr></table></figure>

<p>根据电脑配置,可能需要几十分钟到几个小时不等吧,这里是真正耗时的地方,编译成功之后在 llvm-project 目录下出现一个 build 目录, build 目录下会出现一个 bin 目录,里面能看到我们编译好的 clang 可执行文件</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/38e7e180cecf4d8daa644d0da1a4518c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="编写-clang-插件-实现需求"><a href="#编写-clang-插件-实现需求" class="headerlink" title="编写 clang 插件,实现需求"></a>编写 clang 插件,实现需求</h2><p>除了使用 Ninja 编译 LLVM ,其实还可以生成 Visual Studio 或者 Xcode 工程进行编译,作为 iOS 开发者当然是优先选择比较熟悉的 Xcode 工程来编写插件代码了;在生成 Xcode 工程编写插件代码之前,我们需要先创建一个插件</p>
<h3 id="创建-MKPlugin-目录"><a href="#创建-MKPlugin-目录" class="headerlink" title="创建 MKPlugin 目录"></a>创建 MKPlugin 目录</h3><img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/78611d4200c9474bab25fc94b612661d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>如上图所示,在 <code>llvm-project/clang/examples</code> 目录下创建一个目录 <code>MKPlugin</code> ,这个名称可以改成你自己插件名称,然后在 <code>MKPlugin</code> 目录下创建</p>
<ul>
<li><code>CMakeLists.txt</code> 文件：文件内容为 <code>add_llvm_library(MKPlugin MODULE MKPlugin.cpp PLUGIN_TOOL clang)</code></li>
<li><code>MKPlugin.cpp</code> 文件：这个文件是等会写插件代码的地方</li>
</ul>
<h3 id="配置-MKPlugin-插件"><a href="#配置-MKPlugin-插件" class="headerlink" title="配置 MKPlugin 插件"></a>配置 MKPlugin 插件</h3><p>插件目录创建好之后,需要在插件目录同级的 CMakeList.txt 文件中添加我们的插件,如下图所示</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/884c49b5cbf64ae4966caae1914ec37f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="生成-Xcode-工程"><a href="#生成-Xcode-工程" class="headerlink" title="生成 Xcode 工程"></a>生成 Xcode 工程</h3><p>上面两个步骤完成之后,就可以生成我们熟悉的 Xcode 工程了,首先在 <code>llvm-project</code> 目录下创建一个目录,用来存放我们生成的 Xcode 工程,我这里取名为 <code>llvm_xcode</code> ,如下图</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/2b60fb9e9a8a41289ceef39cc01ef698~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后使用终端,进入 <code>llvm_xcode</code> 目录,输入以下命令 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake -G Xcode ../llvm -DLLVM_ENABLE_PROJECTS=clang</span><br></pre></td></tr></table></figure>

<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/933df1fba17242f4aa992b231014a2d3~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>同样,默认不会生成 clang 子项目,所以需要添加参数 <code>-DLLVM_ENABLE_PROJECTS=clang</code> ,执行完成之后,终端结果如下图</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/a54e2d0964dd435f99462af217b0f43e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>使用 Finder 查看 <code>llvm_xcode</code> 目录如下</p>
<img src="LLVM之clang插件开发/d1453e7f392441ba9eba39c447662faf~tplv-k3u1fbpfcp-watermark.png" alt="image.png" width="50%" />

<p>打开 <code>LLVM.xcodeprog</code> 就到了熟悉的 Xcode 界面了,第一次打开会提示是否自动创建 Schemes</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/c4c1b4c108a048cda5e146cef3cc4d90~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里我个人还是推荐选择 <code>Automatically Create Schemes</code> 自动创建,因为 Schemes 特别多所以电脑配置不太行的 Xcode 可能会卡顿一会,一般等一会就好了,而且如果我的电脑不会卡顿,那应该大多数人的电脑都不会有太大问题…</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/faf65b6787cb482e92e6420b28fdd035~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>到这里,编写自己 clang 插件的 Xcode 工程就生成好了</p>
<h3 id="编写插件代码"><a href="#编写插件代码" class="headerlink" title="编写插件代码"></a>编写插件代码</h3><p>说明一下,我们需要实现的需求是:</p>
<ul>
<li>类名不建议使用小写字母开头,如果有小写字母开头的类名,报一个警告并给出修复的建议</li>
<li>类名中不允许包含下划线<code>_</code>,如果类名中有下划线<code>_</code>,报一个错误并给出修复的建议</li>
<li>不可变属性,如 NSArray, NSString, NSDictionary 的 setter 语义建议使用 copy 修饰</li>
</ul>
<p>编写插件思路是创建子类继承 clang 的解析语法树相关的类，重写父类的相关方法，在关键的节点插入我们的处理逻辑，源码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang/AST/AST.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang/AST/DeclObjC.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang/AST/ASTConsumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang/ASTMatchers/ASTMatchers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang/ASTMatchers/ASTMatchFinder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang/Frontend/CompilerInstance.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang/Frontend/FrontendPluginRegistry.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang::ast_matchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MKPlugin &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MKMatchCallback</span> : <span class="keyword">public</span> MatchFinder::MatchCallback &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        CompilerInstance &amp;CI;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isUserSourceCode</span><span class="params">(<span class="type">const</span> string filename)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (filename.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (filename.<span class="built_in">find</span>(<span class="string">&quot;/Applications/Xcode.app/&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">shouldUseCopy</span><span class="params">(<span class="type">const</span> string typeStr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSArray&quot;</span>) != string::npos ||</span><br><span class="line">                typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSString&quot;</span>) != string::npos ||</span><br><span class="line">                typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSDictionary&quot;</span>) != string::npos ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MKMatchCallback</span>(CompilerInstance &amp;CI):<span class="built_in">CI</span>(CI)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">const</span> MatchFinder::MatchResult &amp;Result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="type">const</span> ObjCPropertyDecl *propertyDecl = Result.Nodes.<span class="built_in">getNodeAs</span>&lt;ObjCPropertyDecl&gt;(<span class="string">&quot;objcPropertyDecl&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (propertyDecl) &#123;</span><br><span class="line">                string fileName = CI.<span class="built_in">getSourceManager</span>().<span class="built_in">getFilename</span>(propertyDecl-&gt;<span class="built_in">getSourceRange</span>().<span class="built_in">getBegin</span>()).<span class="built_in">str</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isUserSourceCode</span>(fileName)) &#123;</span><br><span class="line">                    string classTypeStr = propertyDecl-&gt;<span class="built_in">getType</span>().<span class="built_in">getAsString</span>();</span><br><span class="line">                    ObjCPropertyAttribute::Kind kind = propertyDecl-&gt;<span class="built_in">getPropertyAttributes</span>();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">shouldUseCopy</span>(classTypeStr) &amp;&amp; !(kind &amp; ObjCPropertyAttribute::Kind::kind_copy)) &#123;</span><br><span class="line">                        DiagnosticsEngine &amp;engine = CI.<span class="built_in">getDiagnostics</span>();</span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">int</span> diagID = engine.<span class="built_in">getCustomDiagID</span>(clang::DiagnosticsEngine::Warning, <span class="string">&quot;不可变对象的setter语义推荐使用copy修饰&quot;</span>);</span><br><span class="line">                        engine.<span class="built_in">Report</span>(propertyDecl-&gt;<span class="built_in">getBeginLoc</span>(), diagID);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">const</span> ObjCInterfaceDecl *objcInterfaceDecl = Result.Nodes.<span class="built_in">getNodeAs</span>&lt;ObjCInterfaceDecl&gt;(<span class="string">&quot;objcInterfaceDecl&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (objcInterfaceDecl) &#123;</span><br><span class="line">                string filename = CI.<span class="built_in">getSourceManager</span>().<span class="built_in">getFilename</span>(objcInterfaceDecl-&gt;<span class="built_in">getSourceRange</span>().<span class="built_in">getBegin</span>()).<span class="built_in">str</span>();</span><br><span class="line">                DiagnosticsEngine &amp;engine = CI.<span class="built_in">getDiagnostics</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isUserSourceCode</span>(filename)) &#123;</span><br><span class="line">                    StringRef name = objcInterfaceDecl-&gt;<span class="built_in">getName</span>();</span><br><span class="line">                    <span class="type">char</span> c = name[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isLowercase</span>(c)) &#123;</span><br><span class="line">                        <span class="type">unsigned</span> diagID = engine.<span class="built_in">getCustomDiagID</span>(DiagnosticsEngine::Warning, <span class="string">&quot;类名首字母不应该使用小写字母&quot;</span>);</span><br><span class="line">                        SourceLocation location = objcInterfaceDecl-&gt;<span class="built_in">getLocation</span>();</span><br><span class="line">                        std::string tempName = name.<span class="built_in">str</span>();</span><br><span class="line">                        tempName[<span class="number">0</span>] = <span class="built_in">toUppercase</span>(c);</span><br><span class="line">                        <span class="function">StringRef <span class="title">replacement</span><span class="params">(tempName)</span></span>;</span><br><span class="line">                        SourceLocation nameStart = objcInterfaceDecl-&gt;<span class="built_in">getLocation</span>();</span><br><span class="line">                        SourceLocation nameEnd = nameStart.<span class="built_in">getLocWithOffset</span>(name.<span class="built_in">size</span>());</span><br><span class="line">                        FixItHint fixItHint = FixItHint::<span class="built_in">CreateReplacement</span>(<span class="built_in">SourceRange</span>(nameStart, nameEnd), replacement);</span><br><span class="line">                        engine.<span class="built_in">Report</span>(location, diagID).<span class="built_in">AddFixItHint</span>(fixItHint);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">size_t</span> pos = objcInterfaceDecl-&gt;<span class="built_in">getName</span>().<span class="built_in">find</span>(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pos != StringRef::npos) &#123;</span><br><span class="line">                        std::string tempName = name.<span class="built_in">str</span>();</span><br><span class="line">                        std::string::iterator end_pos = std::<span class="built_in">remove</span>(tempName.<span class="built_in">begin</span>(), tempName.<span class="built_in">end</span>(), <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">                        tempName.<span class="built_in">erase</span>(end_pos, tempName.<span class="built_in">end</span>());</span><br><span class="line">                        <span class="function">StringRef <span class="title">replacement</span><span class="params">(tempName)</span></span>;</span><br><span class="line">                        SourceLocation nameStart = objcInterfaceDecl-&gt;<span class="built_in">getLocation</span>();</span><br><span class="line">                        SourceLocation nameEnd = nameStart.<span class="built_in">getLocWithOffset</span>(name.<span class="built_in">size</span>());</span><br><span class="line">                        FixItHint fixItHint = FixItHint::<span class="built_in">CreateReplacement</span>(<span class="built_in">SourceRange</span>(nameStart, nameEnd), replacement);</span><br><span class="line">                        SourceLocation loc = objcInterfaceDecl-&gt;<span class="built_in">getLocation</span>().<span class="built_in">getLocWithOffset</span>(pos);</span><br><span class="line">                        engine.<span class="built_in">Report</span>(loc, engine.<span class="built_in">getCustomDiagID</span>(clang::DiagnosticsEngine::Error, <span class="string">&quot;类名中不允许包含下划线_&quot;</span>)).<span class="built_in">AddFixItHint</span>(fixItHint);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承 ASTConsumer 实现自定义逻辑</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MKConsumer</span> : <span class="keyword">public</span> ASTConsumer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MatchFinder matchFinder;</span><br><span class="line">        MKMatchCallback callback;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MKConsumer</span>(CompilerInstance &amp;CI):<span class="built_in">callback</span>(CI) &#123;</span><br><span class="line">            matchFinder.<span class="built_in">addMatcher</span>(<span class="built_in">objcPropertyDecl</span>().<span class="built_in">bind</span>(<span class="string">&quot;objcPropertyDecl&quot;</span>), &amp;callback);<span class="comment">//属性声明</span></span><br><span class="line">            matchFinder.<span class="built_in">addMatcher</span>(<span class="built_in">objcInterfaceDecl</span>().<span class="built_in">bind</span>(<span class="string">&quot;objcInterfaceDecl&quot;</span>), &amp;callback);<span class="comment">//类声明</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(ASTContext &amp;Ctx)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            matchFinder.<span class="built_in">matchAST</span>(Ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承 PluginASTAction 实现自定义的逻辑</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MKASTAction</span> : <span class="keyword">public</span> PluginASTAction &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="type">const</span> CompilerInstance &amp;CI, <span class="type">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;ASTConsumer&gt; <span class="title">CreateASTConsumer</span><span class="params">(CompilerInstance &amp;CI, StringRef InFile)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;MKConsumer&gt;(<span class="keyword">new</span> <span class="built_in">MKConsumer</span>(CI));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册插件</span></span><br><span class="line"><span class="function"><span class="type">static</span> FrontendPluginRegistry::Add&lt;MKPlugin::MKASTAction&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;MKPlugin&quot;</span>, <span class="string">&quot;这里是插件的描述信息&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="集成到-Xcode-中"><a href="#集成到-Xcode-中" class="headerlink" title="集成到 Xcode 中"></a>集成到 Xcode 中</h2><p>插件代码编写完成之后，需要将插件编译成动态库，在 Xcode 中选择我们的 MKPlugin Scheme 进行编译，如下图</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/c821440d55df454aaa2738a5a50f9af2~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>Scheme 可能有很多需要往下翻很久才能找到我们的插件，这时候可以直接输入我们的插件名称进行快速定位，编译成功之后，可以在 Products 目录下看到对应的动态库文件 <code>MKPlugin.dylib</code>，如下图</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/13c74423407247969ceef471eb9486cc~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在集成到 Xcode 之前，可以先使用终端命令验证我们的 clang 和 MKPlugin.dylib 是否生效，此时需要一份 Objective-C 的源码进行编译，我们新建一个 Xcode 项目，编写一段简单的 Objective-C 代码。如下图：</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/24882acad98a4d539a32609d60f34258~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后使用终端进入工程目录下，输入以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/Users/Franky/llvm-project/build/bin/clang -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.4.sdk -Xclang -load -Xclang /Users/Franky/llvm-project/llvm_xcode/Debug/lib/MKPlugin.dylib -Xclang -add-plugin -Xclang MKPlugin -c mk_Person.m</span><br></pre></td></tr></table></figure>

<p>这个命令使用了我们之前编译好的 clang 和 MKPlugin.dylib 对 mk_Person.m 文件进行编译，结果如下图</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/aa2967e60ccd43d4b23af667225933b2~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>可以明显的看到，我们编写的插件代码生效了！下一步可以集成到 Xcode 中了，来到 testClang 工程的 build settings 中搜索 Other C Flags，输入刚刚的命令中的中间那一段</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Xclang -load -Xclang /Users/Franky/llvm-project/llvm_xcode/Debug/lib/MKPlugin.dylib -Xclang -add-plugin -Xclang MKPlugin</span><br></pre></td></tr></table></figure>

<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/5aa0d485536c4d019e409be89eac93ff~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>然后添加两个用户定义设置</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/423c93a4841c4909beecffad718bbaf6~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>输入刚刚的命令中的 clang 路径，clang++ 也在同级的目录下</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/7d6b4dfb16304e5cb76c8f0a888de025~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>最后将 enable index-while-building functionality 设置为 NO </p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/9b8a63d4532a41dfac0efb6ef7db58d1~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>编译之后就会看到以下结果了</p>
<img src="/2023/07/16/LLVM%E4%B9%8Bclang%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/a1d5a0b308cd4eccaf650cc097ffc2bf~tplv-k3u1fbpfcp-watermark-1.png" class="" alt="image.png">

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>了解了 LLVM 和 clang 的编译原理之后，我们能做的事情还有很多，可以用它来实现一门新的编程语言；可以用来分析语法树；可以进行语言的转换；可以开发 clang 插件；Pass 开发代码优化,代码混淆等等功能；借助 clang 来优化 APP 的启动速度；静态分析 C，C++，Objective-C 代码的一个开源工具 <a href="https://oclint.org/">OCLint</a> 也是基于 clang 抽象语法树（AST），觉得自己实现插件麻烦的，也可以使用 OCLint。</p>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH</title>
    <url>/2023/08/03/OpenSSH/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>平时在使用 Mac 的过程中，经常会使用终端输入命令来执行一些操作。在越狱开发的过程中，同样需要在 iOS 系统上输入一些命令来执行一些任务。那么如何才能在 iOS 系统上输入命令呢，在 iOS 上安装一个终端命令行工具，然后在 iPhone 那小小的屏幕上用触摸屏输入命令吗？虽然说理论上和实际上都是可行的，但是通过手指触摸屏幕来输入命令的方式效率比较低，也不是很方便。这里还是推荐在 Mac 上远程登录到 iOS 系统，这样就可以使用 Mac 的键盘输入命令到 iOS 上去执行，更加方便，快捷。</p>
<h1 id="SSL、openSSL、SSH、openSSH"><a href="#SSL、openSSL、SSH、openSSH" class="headerlink" title="SSL、openSSL、SSH、openSSH"></a>SSL、openSSL、SSH、openSSH</h1><p>SSL（Secure Sockets Layer）是一种用于在计算机网络上进行安全通信的协议。SSL 最初由 Netscape 开发，后来发展为 TLS（Transport Layer Security）。SSL&#x2F;TLS 用于在客户端和服务器之间建立安全的加密连接，以保护敏感数据的传输，例如在网页浏览器和服务器之间的数据传输。</p>
<p>OpenSSL 是一个强大的、商业级的、功能齐全的开源工具包，它提供了一组库和命令行工具，用于处理 SSL&#x2F;TLS 协议和加密算法，是 SSL 协议的一款开源实现工具。OpenSSL 可以用于创建和管理数字证书、实现安全传输和通信，以及进行加密和解密等操作。它不仅支持 SSL&#x2F;TLS 协议，还支持多种加密算法和密码学功能。</p>
<p>SSH（Secure Shell）是一种用于安全远程登录和数据传输的网络协议。它为计算机之间的通信提供了加密和身份验证，以确保通信的机密性和完整性。SSH 使用公钥密码体制进行身份验证，并使用加密算法来保护数据的传输。</p>
<p>OpenSSH 是一个开源的 SSH 实现，它提供了 SSH 客户端和服务器的功能，用于安全远程登录、命令执行和文件传输。它包括客户端 ssh 和服务器 sshd、文件传输实用程序 scp 和 sftp 以及密钥生成工具 (ssh-keygen)、运行时密钥存储 (ssh-agent) 和许多支持程序。它是 Linux 和其他类 Unix 系统中最常见的 SSH 实现，也支持其他操作系统。</p>
<p>SSL 最早出现于 1994 年，用于 Web 浏览器和服务器之间的安全通信。OpenSSL 和 SSH 都起源于 1995 年，OpenSSL 是一个加密工具包，而 SSH 是用于安全远程登录和数据传输的协议。OpenSSH 是 SSH 协议的开源实现，起源于 1999 年，为 SSH 提供了广泛使用的实现。</p>
<p>OpenSSH 通常依赖于 OpenSSL。OpenSSH 使用 OpenSSL 库来实现加密和安全功能，包括加密通信、密钥生成、数字证书处理等。OpenSSL 提供了各种加密算法和密码学功能，使 OpenSSH 能够建立安全的 SSH 连接，并保护通信数据的机密性和完整性。在大多数情况下，安装 OpenSSH 时，系统会自动安装或链接到已经安装的 OpenSSL 库。这样，OpenSSH 就能够使用 OpenSSL 的功能来实现加密和安全性，而不必重新实现这些复杂的加密算法和协议。</p>
<p>因此，可以说 OpenSSH 依赖于 OpenSSL，OpenSSL 提供了 OpenSSH 所需的加密和安全功能，使得 OpenSSH 成为一种安全、可靠的远程登录和数据传输工具。这些安全协议和工具对于保护通信和数据安全至关重要。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><blockquote>
<p>⚠️注意：这里作者使用的是 checkra1n 越狱的 iOS 12.5.7 iPhone5s。</p>
</blockquote>
<p>对以上名词概念有了基本的了解之后，我们可以进行实践操作。如果感觉还是迷迷糊糊也不要紧，实践起来就会感觉简单多了。主要是对 OpenSSH 这个开源库提供的常用命令的使用。Mac 系统自带了这个工具所以不需要进行配置，而 iOS 系统上默认是没有安装这个工具的，包括越狱之后的 iOS 也没有，所以需要先下载安装这个工具。</p>
<p>安装过程很简单，如下图所示，在 Cydia 上搜索 OpenSSH 下载并按照提示进行安装就好了。</p>
<img src="OpenSSH/32a8afae2fae413d8fa5984d89693e0f~tplv-k3u1fbpfcp-watermark.png" alt="IMG_0001.PNG" width="50%" />

<p>安装好之后，就可以在 Mac 上远程登录到越狱 iOS 了。iOS 系统默认提供了两个用户，一个是 root 用户，是 iOS 中最高权限的用户，我们在逆向开发过程中基本都是使用这个用户。还有一个是 mobile 用户，是普通权限用户，iOS 平时进行 APP 安装，卸载基本都是使用这个用户，但是我们在逆向开发中很少或者基本不会使用到这个用户，这里有个了解就够了。</p>
<p>Cydia 首页有 OpenSSH 访问教程，这个文档详细的记载了如何从 Mac 远程登录到 iOS 设备上，并且也提供了修改默认密码的方法。建议英文不错的同学直接阅读这篇文档，不想看的就看我后面的介绍也可以。文档位置如下图所示</p>
<img src="OpenSSH/41ffb7e4fae849d7846018c90bbbc177~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0002.PNG" width="50%" />

<h3 id="通过默认账号密码登录到-iPhone"><a href="#通过默认账号密码登录到-iPhone" class="headerlink" title="通过默认账号密码登录到 iPhone"></a>通过默认账号密码登录到 iPhone</h3><p>ssh 提供了两种登录到服务器的方式，第一种是使用账号和密码。第二种是免密码登录。下面先介绍第一种</p>
<ol>
<li>越狱 iPhone 在 Cydia 上安装 OpenSSH</li>
<li>确认 iPhone 和 Mac 电脑在同一个局域网下，在 Mac 打开终端，输入以下命令 <figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">ssh root@iPhone的IP地址</span><br></pre></td></tr></table></figure>
 第一次连接会出现 <code>Are you sure you want to continue connecting (yes/no/[fingerprint])?</code> 提示，输入 <code>yes</code> 确认进行连接</li>
<li>输入默认的初始密码 <code>alpine</code> ,这里终端为了安全并不会显示密码的明文</li>
<li>之后就会看到终端切换到了 <code>iPhone:~ root#</code> 用户，代表成功登录到远程 iPhone 手机的 root 用户上了。这个时候，你在 Mac 终端输入的指令都会被发送到 iPhone 上，如下图 <img src="/2023/08/03/OpenSSH/6b806498309a4589a7e39b35238b1616~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">
 如果你觉得还不过瘾，可以输入 <code>reboot</code> 命令，体会一下远程操纵手机的快乐（重启之后，你可能需要重新越狱一下 iPhone 了😶）</li>
<li>输入 <code>exit</code> 退出登录</li>
</ol>
<p>刚刚我们登录的是 <code>root</code> 用户。在 iOS 中，除了 <code>root</code> 用户，还有一个 <code>mobile</code> 用户。其中 <code>root</code> 用户是 iOS 中最高权限的用户。<code>mobile</code> 是普通权限用户，其实平时越狱调试过程中，很少会使用这个 <code>mobile</code> 用户，这里只是介绍一下。</p>
<p>能够成功登录 iPhone 之后，建议修改一下用户的默认密码，既然做逆向开发了，当然对安全也要注意一点。在登录 root 用户之后，</p>
<ul>
<li>输入 <code>passwd</code> 可以修改 root 用户的密码</li>
<li>输入 <code>passwd mobile</code> 可以修改 mobile 用户的密码。</li>
</ul>
<h3 id="通过免密码方式登录到-iPhone"><a href="#通过免密码方式登录到-iPhone" class="headerlink" title="通过免密码方式登录到 iPhone"></a>通过免密码方式登录到 iPhone</h3><p>OpenSSH 除了默认的账号密码登录的方式，还提供了免密码登录的方式。需要进一步完成一些配置才可以实现。服务器（在当前情况下，iPhone是服务器，Mac是客户端）的 ~&#x2F;.ssh 目录下需要添加一个 authorized_keys 文件，里面记录可以免密登录的设备的公钥信息。</p>
<p>当有客户端（Mac）登录的时候，服务器会查看 ~&#x2F;.ssh&#x2F;authorized_keys 文件中是否记录了当前登录的客户端的公钥信息，如果有就直接登录成功，没有就要求输入密码。所以我们要做的就是将 Mac 设备的公钥信息追加到 iPhone 的 authorized_keys 文件内容的最后面。追加是为了不影响其他的设备。完成这个操作需要先确保我们的 Mac 设备上已经有 ssh 生成的公钥文件。</p>
<p>打开 Mac 终端，输入 <code>ls ~/.ssh</code> 查看是否已经存在 <code>id_rsa.pub</code> 公钥文件，<code>.pub</code>就是公钥文件的后缀</p>
<img src="/2023/08/03/OpenSSH/7b97ca3f9eee41048514e786d0909eea~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>如果没有看到公钥文件，需要使用 <code>ssh-keygen</code> 命令生成该文件。按回车键接受默认选项，或者根据需要输入新的文件名和密码。这将生成一个公钥文件（id_rsa.pub）和一个私钥文件（id_rsa）。</p>
<p>使用 SSH 复制公钥到远程服务器。使用以下命令将本地计算机（Mac）上的公钥复制到远程服务器（iPhone）。请将<code>user</code>替换为您的远程服务器用户名，以及<code>remote_server</code>替换为服务器的域名或IP地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-copy-id user@remote_server</span><br></pre></td></tr></table></figure>

<img src="/2023/08/03/OpenSSH/72e2862e24124ebc9b8bc1d6122e7ff4~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>在远程服务器（iPhone）上设置正确的权限。确保远程服务器上的<code>~/.ssh</code>文件夹权限设置为 700，并将<code>~/.ssh/authorized_keys</code>文件的权限设置为 600。这样可以确保SSH可以正确识别公钥并允许免密码登录。如下图所示：</p>
<img src="/2023/08/03/OpenSSH/60c0d90bbd12440b9b15dea392525c10~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>.ssh 文件夹前面的 <code>drwx------</code> 是 Linux 和类 Unix 系统中表示文件或目录权限的一种格式。在这个格式中，每一组由10个字符组成，代表文件或目录的不同权限。让我们逐个解释这些字符的含义：</p>
<ol>
<li><p>第一个字符：文件类型</p>
<ul>
<li><code>d</code> 表示目录（directory）</li>
<li><code>-</code> 表示普通文件</li>
<li><code>l</code> 表示符号链接（symlink）</li>
<li><code>b</code> 表示块设备文件（block device）</li>
<li><code>c</code> 表示字符设备文件（character device）</li>
<li><code>s</code> 表示套接字（socket）</li>
<li><code>p</code> 表示命名管道（named pipe）</li>
</ul>
</li>
<li><p>接下来的三个字符：文件所有者的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
<li><p>接下来的三个字符：文件所有者所在组的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
<li><p>最后三个字符：其他用户的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
</ol>
<p>所以，<code>drwx------</code> 表示这是一个目录，并且具有以下权限：</p>
<ul>
<li>文件所有者具有读、写和执行权限。</li>
<li>文件所有者所在组没有任何权限。</li>
<li>其他用户没有任何权限。</li>
</ul>
<p>后面 9 个字符分为三组，每组从左至右如果有对应的权限就是<code>421</code>相加起来就是 7 后面都是0。所以 .ssh 文件夹的权限是正确的值 700，如果不是 700 的使用 <code>chmod 700 .ssh</code> 进行提权。authorized_keys 文件的权限是 <code>rw</code> 就是 <code>420</code> 相加起来就是 6 。后面都是 0，所以 authorized_keys 的权限也是正确的值 600。同样如果不是 600，使用 <code>chmod 600 authorized_keys</code> 命令修改权限。</p>
<p>配置完成后，您现在可以使用 SSH 免密码登录到远程服务器（iPhone）。在 Mac 上，使用以下命令连接到远程服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh root@10.10.20.155</span><br></pre></td></tr></table></figure>

<p>这将直接连接到远程服务器，而无需输入密码。</p>
<img src="/2023/08/03/OpenSSH/866ac19a922d485083538ac1d4fbff8c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h3 id="通过-USB-有线的方式登录到-iPhone"><a href="#通过-USB-有线的方式登录到-iPhone" class="headerlink" title="通过 USB 有线的方式登录到 iPhone"></a>通过 USB 有线的方式登录到 iPhone</h3><p>配置为免密码登录之后，还可以进一步使用 USB 有线连接的方式登录到手机。如果你经常使用 WiFi 这种方式远程登录调试就会发现偶尔会碰到指令输入，响应卡顿，反应慢的情况，这样的体验显然让人感到不爽。所以，在大部分情况下，更推荐使用 USB 有线连接登录到 iPhone 上，这样使用的过程中，就像在本地输入命令操作一样流畅。</p>
<p><code>iproxy</code> 是一个用于端口转发的命令行工具。它通常用于在 iOS 设备和计算机之间建立端口映射，从而将 iOS 设备上运行的服务暴露到计算机上。这对于开发者来说非常有用，因为可以通过本地计算机访问 iOS 设备上运行的服务，而无需将服务部署到公共网络上。</p>
<p><code>iproxy</code> 是 <code>usbmuxd</code> 的一部分，后者是一个用于连接和管理 iOS 设备的 USB 通信的守护进程。<code>usbmuxd</code> 允许通过 USB 连接与 iOS 设备进行通信，并且<code>iproxy</code> 则负责在本地计算机和iOS设备之间建立端口转发。</p>
<p>通常，您可以在命令行中使用 <code>iproxy</code> 命令来建立端口转发，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iproxy local_port device_port</span><br></pre></td></tr></table></figure>

<p>其中，<code>local_port</code> 是本地计算机上的端口号，<code>device_port</code> 是 iOS 设备上的端口号。执行此命令后，iOS 设备上的服务将通过 <code>device_port</code> 映射到本地计算机上的 <code>local_port</code>。</p>
<p>请注意，使用 <code>iproxy</code> 需要先安装 <code>libusbmuxd</code> 包。在 macOS 上，您可以使用 Homebrew 来安装 <code>libusbmuxd</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install libusbmuxd</span><br></pre></td></tr></table></figure>

<p>安装好之后，就可以使用 iproxy 命令了，使用 iproxy 将本机 10010 端口和 USB 设备的 22 端口进行映射的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iproxy 10010 22</span><br></pre></td></tr></table></figure>

<img src="/2023/08/03/OpenSSH/68273210a76642c5b692f47eadb5eeaa~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>这里本机的端口 10010 可以设置为你想要的其他端口，但是不能是系统保留的端口（系统保留的端口有哪些，可以看<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3/103505?fr=ge_ala">百度</a>的介绍）。端口转发设置完成之后，这个终端就不要关闭，也不要管它了，新建另一个终端窗口进行 ssh 登录。此时，需要给 ssh 加上指定端口参数，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -p 10010 root@localhost</span><br></pre></td></tr></table></figure>

<p>同样第一次使用这种方式建立连接会给出提示，输入 <code>yes</code> 确认</p>
<img src="/2023/08/03/OpenSSH/15c962453c7749b7bdb59c531c18f10e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>之后，在 iPhone 设备上输入命令调试时，再也不会遇到卡顿，慢，延迟的现象啦。玩得开心~</p>
<h1 id="ssh-常见问题"><a href="#ssh-常见问题" class="headerlink" title="ssh 常见问题"></a>ssh 常见问题</h1><p>有时候我们会对 iOS 设备重新越狱，重新越狱后的设备信息发生了变化，继续使用 ssh 登录是无法成功的。会给出如下信息：</p>
<img src="/2023/08/03/OpenSSH/Xnip2024-09-15_04-35-31.jpg" class="" alt="image.png">

<p>在这种情况下，我们知道并不是发生了中间人攻击，而是 IP 地址跟设备不匹配了。所以可以使用 <code>ssh-keygen -R IP地址</code> 移除指定 IP 的设备信息。</p>
<img src="/2023/08/03/OpenSSH/Xnip2024-09-15_04-39-25.jpg" class="" alt="image.jpg">

<p>再次使用 ssh 进行远程连接，就回到第一次远程登录那样了。</p>
<img src="/2023/08/03/OpenSSH/Xnip2024-09-15_04-41-23.jpg" class="" alt="image.jpg">

<h1 id="在-palera1n-越狱的-iOS16-7-10-iPhone8plus-上使用-OpenSSH-遇到的问题"><a href="#在-palera1n-越狱的-iOS16-7-10-iPhone8plus-上使用-OpenSSH-遇到的问题" class="headerlink" title="在 palera1n 越狱的 iOS16.7.10 iPhone8plus 上使用 OpenSSH 遇到的问题"></a>在 palera1n 越狱的 iOS16.7.10 iPhone8plus 上使用 OpenSSH 遇到的问题</h1><p>使用 palera1n 越狱的时候，在安装 Sileo 的时候会提示设置一个终端密码，意味着默认的密码不再是 alpine 了。安装好 Sileo 之后，默认的软件源中已经有 openssh 了，所以直接在搜索框中搜索就好了。如下图所示：</p>
<img src="OpenSSH/IMG_0005.PNG" alt="IMG_0003.PNG" width="50%" />

<p>原本以为安装好 openssh 之后，可以像 iOS 12.5.7 那样顺利的远程连接。实际发现无法使用 root 用户登录，即使密码输入的是正确的。如下图：</p>
<img src="/2023/08/03/OpenSSH/Xnip2024-09-15_05-02-16.jpg" class="">

<p>在 iOS 16 系统上，使用 palera1n 或者 dopamine 越狱成功之后，使用 ssh 的时候，默认的 root 用户出于安全考虑是禁用的，需要执行一次 <code>sudo passwd root</code> 修改 root 用户密码之后才可以使用，即使你修改的密码是一样的。 所以解决的方法有两种</p>
<ol>
<li>先用 mobile 用户登录，再执行 <code>sudo passwd root</code> 修改 root 密码之后，再次使用 root 用户登录。</li>
<li>在 iPhone 上下载终端应用程序，然后输入 <code>sudo passwd root</code> 修改 root 密码，之后再使用 root 用户登录。</li>
</ol>
<p>这里第一种方法我就不演示了，肯定没问题的。第 2 种方法需要用到 iOS 端的 Terminal App。我试过一些其他的终端程序无法成功运行。但是 <a href="https://mtac.app/repo/">MTAC’s Repo</a> 的 MTerminal 是可以成功在 iOS 16.7.10 上正常运行的。</p>
<p>在 iPhone 上运行 MTerminal 进行修改 root 用户密码操作如下图：</p>
<img src="OpenSSH/IMG_0006.PNG" alt="IMG_0003.PNG" width="80%" />

<p>修改成功后，再次使用 root 用户进行 ssh 远程连接到 iPhone 就和之前一模一样了，可以愉快的玩耍了。</p>
<img src="/2023/08/03/OpenSSH/Xnip2024-09-15_05-17-44.jpg" class="">

]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>openssl</tag>
        <tag>ssh</tag>
        <tag>openssh</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO</title>
    <url>/2025/02/23/KVO/</url>
    <content><![CDATA[<h1 id="KVO-的基本和高级使用"><a href="#KVO-的基本和高级使用" class="headerlink" title="KVO 的基本和高级使用"></a>KVO 的基本和高级使用</h1><ol>
<li>context 如果不需要使用，填 NULL。如果需要使用 context 推荐传递静态变量。官方文档中还提到，在父类和子类中同时监听某个属性时无法使用 keyPath 区分的情况下就可以使用 context 进行区分。</li>
<li>是否有必要移除观察者？当然有必要，该移除的时候就一定要移除</li>
<li><code>automaticallyNotifiesObserversForKey:</code> 的使用</li>
<li><code>keyPathsForValuesAffectingValueForKey:</code> 的使用</li>
<li>可变数组属性的 KVO 问题</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用于与 `-addObserver:forKeyPath:options:context:` 和 `-addObserver:toObjectsAtIndexes:forKeyPath:options:context:` 一起使用的选项。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSKeyValueObservingOptions</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知中发送的变更字典是否应分别包含 `NSKeyValueChangeNewKey` 和 `NSKeyValueChangeOldKey` 条目。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionNew</span> = <span class="number">0x01</span>,</span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionOld</span> = <span class="number">0x02</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否应在观察者注册方法返回之前立即向观察者发送通知。</span></span><br><span class="line"><span class="comment">    如果同时指定了 `NSKeyValueObservingOptionNew`，则通知中的变更字典将始终包含 `NSKeyValueChangeNewKey` 条目，但永远不会包含 `NSKeyValueChangeOldKey` 条目。（在初始通知中，被观察属性的当前值可能是旧的，但对观察者来说是新的。）</span></span><br><span class="line"><span class="comment">    你可以使用此选项，而不是在同一时间显式调用观察者的 `-observeValueForKeyPath:ofObject:change:context:` 方法也会调用的代码。</span></span><br><span class="line"><span class="comment">    当此选项与 `-addObserver:toObjectsAtIndexes:forKeyPath:options:context:` 一起使用时，将为每个被添加观察者的索引对象发送通知。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionInitial</span> API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">0x04</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否应在每次变更前后分别向观察者发送通知，而不是在变更后发送单一通知。</span></span><br><span class="line"><span class="comment">    在变更前发送的通知中的变更字典始终包含一个 `NSKeyValueChangeNotificationIsPriorKey` 条目，其值为 `[NSNumber numberWithBool:YES]`，但永远不会包含 `NSKeyValueChangeNewKey` 条目。</span></span><br><span class="line"><span class="comment">    当观察者自身的 KVO 合规性要求其为其自身属性之一调用 `-willChange...` 方法，并且该属性的值取决于被观察对象属性的值时，可以使用此选项。（在这种情况下，在接收到 `-observeValueForKeyPath:ofObject:change:context:` 消息后，已经太晚，无法轻松地正确调用 `-willChange...`。）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	当指定此选项时，变更后发送的通知中的变更字典将包含与未指定此选项时相同的条目，除了由 `NSOrderedSet` 表示的有序唯一对多关系。</span></span><br><span class="line"><span class="comment">	对于这些关系，对于 `NSKeyValueChangeInsertion` 和 `NSKeyValueChangeReplacement` 变更，will-change 通知的变更字典包含一个 `NSKeyValueChangeIndexesKey`（以及在 	`Replacement` 情况下，如果注册时指定了 `NSKeyValueObservingOptionOld` 选项，则还包含 `NSKeyValueChangeOldKey`），这些条目给出了可能被操作更改的索引（和对象）。</span></span><br><span class="line"><span class="comment">	第二个通知，即变更后的通知，包含报告实际发生变更的条目。</span></span><br><span class="line"><span class="comment">	对于 `NSKeyValueChangeRemoval` 变更，按索引的删除是精确的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionPrior</span> API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">0x08</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">NSKeyValueObserving</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 假设接收者已经注册为相对于某个对象的键路径的值的观察者，当该值发生变化时，接收者会收到通知。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">变更字典始终包含一个 `NSKeyValueChangeKindKey` 条目，其值是一个包装了 `NSKeyValueChange` 的 `NSNumber`（使用 `-[NSNumber unsignedIntegerValue]` 获取）。`NSKeyValueChange` 的含义取决于键路径所标识的属性的类型：</span></span><br><span class="line"><span class="comment">    - 对于任何类型的属性（属性、一对一关系、有序或无序的多对多关系），`NSKeyValueChangeSetting` 表示被观察对象收到了 `-setValue:forKey:` 消息，或者调用了符合键值编码的 set 方法，或者以其他方式调用了 `-willChangeValueForKey:/-didChangeValueForKey:` 对。</span></span><br><span class="line"><span class="comment">    - 对于**有序**的多对多关系，`NSKeyValueChangeInsertion`、`NSKeyValueChangeRemoval` 和 `NSKeyValueChangeReplacement` 表示向对象发送的 `-mutableArrayValueForKey:` 消息返回的数组，或向对象发送的 `-mutableOrderedSetValueForKey:` 消息返回的有序集合，被发送了修改消息，或者调用了符合键值编码的数组或有序集合的修改方法，或者以其他方式调用了 `-willChange:valuesAtIndexes:forKey:/-didChange:valuesAtIndexes:forKey:` 对。</span></span><br><span class="line"><span class="comment">    - 对于**无序**的多对多关系（在 Mac OS 10.4 中引入），`NSKeyValueChangeInsertion`、`NSKeyValueChangeRemoval` 和 `NSKeyValueChangeReplacement` 表示向对象发送的 `-mutableSetValueForKey:` 消息返回的集合被发送了修改消息，或者调用了符合键值编码的集合的修改方法，或者以其他方式调用了 `-willChangeValueForKey:withSetMutation:usingObjects:/-didChangeValueForKey:withSetMutation:usingObjects:` 对。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于任何类型的属性，如果在观察者注册时指定了 `NSKeyValueObservingOptionNew`，并且是正确类型的变更，且这不是一个“变更前”通知，则变更字典包含一个 `NSKeyValueChangeNewKey` 条目。如果在观察者注册时指定了 `NSKeyValueObservingOptionOld`，并且是正确类型的变更，则变更字典包含一个 `NSKeyValueChangeOldKey` 条目。关于这些条目的值可能是什么，请参阅 `NSKeyValueObserverNotification` 非正式协议方法的注释。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于**有序**的多对多关系，除非变更是 `NSKeyValueChangeSetting`，否则变更字典始终包含一个 `NSKeyValueChangeIndexesKey` 条目，其值是一个包含插入、删除或替换对象的索引的 `NSIndexSet`。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果在观察者注册时指定了 `NSKeyValueObservingOptionPrior`（在 Mac OS 10.5 中引入），并且此通知是由于变更前发送的通知，则变更字典包含一个 `NSKeyValueChangeNotificationIsPriorKey` 条目，其值是一个包装了 `YES` 的 `NSNumber`（使用 `-[NSNumber boolValue]` 获取）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">`context` 始终与观察者注册时传入的指针相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="type">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="type">void</span> *)context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<h1 id="KVO-的底层实现原理"><a href="#KVO-的底层实现原理" class="headerlink" title="KVO 的底层实现原理"></a>KVO 的底层实现原理</h1><p>isa-swizzling</p>
<h1 id="自己实现一个简单的-KVO"><a href="#自己实现一个简单的-KVO" class="headerlink" title="自己实现一个简单的 KVO"></a>自己实现一个简单的 KVO</h1><h1 id="查看-GNU-的-KVO-实现或逆向分析-Foundation-源码"><a href="#查看-GNU-的-KVO-实现或逆向分析-Foundation-源码" class="headerlink" title="查看 GNU 的 KVO 实现或逆向分析 Foundation 源码"></a>查看 GNU 的 KVO 实现或逆向分析 Foundation 源码</h1>]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>Reveal</title>
    <url>/2023/08/26/Reveal/</url>
    <content><![CDATA[<p>之前已经介绍过 Cycript 这个越狱动态分析的神器，Cycript 是纯命令式的分析工具，对于大多数人&#x2F;普通开发者来说，这种方式还是显得太极客了。还是图形化的界面更容易接受和使用，所以今天介绍的就是这样一款神器 Reveal 。很多 iOS 的正向开发人员会感觉到困惑，说我用 Xcode 的 view debugger 用的挺好的啊。还去了解这个 Reveal 干什么。。。我只能说跟我在没接触逆向开发之前的想法一模一样，Reveal 不仅可以分析你的 APP 界面，它还可以分析其他开发者的 APP 界面，甚至分析 iOS 系统自带的 APP 界面。而且对于 flutter 项目生成的 App 使用 view debugger 只能看到视图层级结构内容却只显示一片黑色，而 Reveal 却能看到其中的内容。而且 Reveal 在分析 APP 界面的时候同样不需要中断分析的 APP 进程。</p>
<p>Cycript 相比 Reveal 功能更加强大，除了可以查看 APP 的 UI 界面以外，还可以获取 APP 中更多的信息，比如对象的成员变量，属性，对象方法，类方法等等。。。虽然 Reveal 仅限 UI 界面分析修改 UI 属性等简单功能，但 Reveal 提供的图形界面对大多数人更加友好。分析界面时选择哪个取决于你的个人爱好，但想动态调试调用方法，获取更多的信息的话，可能 Cycript 会更合适。</p>
<h1 id="正向开发中使用-Reveal"><a href="#正向开发中使用-Reveal" class="headerlink" title="正向开发中使用 Reveal"></a>正向开发中使用 Reveal</h1><p>由于正向开发过程中使用 Reveal 的意义并不大（基本都是使用 Xcode 的 view debugger），而且就算要使用，集成过程也非常简单。在 <a href="https://revealapp.com/download/">官网</a> 下载好 Reveal 之后，打开 Reveal 找到 iOS Library，然后将它集成到 APP 中不需要添加一行代码就完事了。然后启动 APP 重新（可能也不需要？）打开 Reveal 就可以看到你的 APP 显示在 Reveal 界面。</p>
<p>找到 Reveal 的 iOS Library：</p>
<img src="/2023/08/26/Reveal/8bb982c6fbc34d6796ea0148ed8944b5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>呃，集成过程还是讲一下吧，不然可能会启动就崩溃。将 iOS Library 复制到项目的根目录下</p>
<p align=center><img src="Reveal/0e1be61793cb4351878b1a409ffe1be1~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="50%" /></p>

<p>然后找到你的 target -&gt; general -&gt; frameworks,libraries,and embedded content -&gt; RevealServer.framework 右侧选择 Embed &amp; sign 。</p>
<p align=center><img src="Reveal/d5d400c8a4cc42e388ade86725b6d773~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="70%" /></p>

<p>这样会将 RevealServer.framework 打包到 APP 包的 Frameworks 目录下。如下图：</p>
<p align=center><img src="Reveal/fd7cfc3a7c6445cbba679ef75a1b47b8~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="50%" /></p>

<p>只有这样，才不会启动崩溃，（这是在我的 Reveal 版本 21 上是这样的，如果你不是这个版本，可能不会有这样的问题）。Reveal 界面如下：</p>
<img src="/2023/08/26/Reveal/df19cf9fa34141f1a9d205f6669a4137~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h1 id="逆向开发中中使用-Reveal"><a href="#逆向开发中中使用-Reveal" class="headerlink" title="逆向开发中中使用 Reveal"></a>逆向开发中中使用 Reveal</h1><h2 id="未越狱环境使用"><a href="#未越狱环境使用" class="headerlink" title="未越狱环境使用"></a>未越狱环境使用</h2><p>同样还是推荐使用 <a href="https://github.com/AloneMonkey/MonkeyDev">AloneMonkey</a> 的 MonkeyApp 项目模板，项目模板默认就集成了 Reveal ，不过需要注意的是 AloneMonkey 自带的 RevealServer.framework 库版本十分古老了。所以需要将你的 Reveal 的 RevealServer.framework 替换过去。在 Reveal 的 help 中找到 iOS Library，替换 AloneMonkey 中的 RevealServer.framework，AloneMonkey 的 RevealServer.framework 路径如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/opt/MonkeyDev/Frameworks/RevealServer.framework</span><br></pre></td></tr></table></figure>

<h2 id="越狱环境使用"><a href="#越狱环境使用" class="headerlink" title="越狱环境使用"></a>越狱环境使用</h2><p>越狱环境的使用需要以下三个步骤</p>
<ol>
<li><p><del>从 Cydia&#x2F;Sileo 安装 Reveal2Loader</del></p>
 <img src="Reveal/b79de82dd10547e3bf78ddb102be1451~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0005.PNG" width="50%" />
 
<p> 在最新的越狱 iOS 设备上，无论是 rootless 还是 rootful 好像都无法正常使用了。作者进行了升级适配开源了 <a href="https://github.com/masterKing/RevealLoader2">RevealLoader2</a> 可以添加作者的软件源：<a href="https://masterking.github.io/sileorepo">https://masterking.github.io/sileorepo</a> 下载</p>
</li>
<li><p>将 Mac 上的 Reveal 的 iOS Library 中的 RevealServer.framework 复制到越狱设备的 <code>/Library/Frameworks/RevealServer.framework</code> 路径。可以使用 scp 命令，也可以使用 iFunBox 图形界面操作更直观。</p>
</li>
<li><p>在 iOS 设置 APP 中找到 Reveal -&gt; Enabled Applications 选择你想要调试的 APP 打开右侧的开关。</p>
</li>
</ol>
<p>执行上述步骤之后，打开 Mac 的 Reveal 就可以看到越狱 iPhone 上可以调试的 APP 了，可以看到系统的 APP 也可以。下面是系统 备忘录 APP 的界面结构：</p>
<img src="/2023/08/26/Reveal/44e624f4c78241dfa2da131cd91a5658~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>通过 Reveal 分析优秀的 APP 的 UI 界面简直是太棒了！当然这只是从 UI 层面的分析，这个时候可能很多人就会说了，光看一下 UI 界面有什么用啊，还不是不知道具体怎么实现的。</p>
<p>直接看到源码是不太可能的（除非你是苹果公司的工程师🙂），苹果并没有开源这些 APP 。但是想要查看和源码等价的伪代码也不是完全不可能，可以通过反汇编，反编译工具（<strong>hopper</strong>，<strong>ghidra</strong>，<strong>IDA Pro</strong>等工具）还原为高级代码，这些内容都会在后续的文章中更新。</p>
<p>还有很多 iOS 开发者经常在使用系统库的过程中，可能会遇到一些莫名其妙的问题，如 UIKit ，作者就曾经在子类化 <code>UIRefreshControl</code> 的时候遇到过奇怪的问题，很多时候都会在 <code>- (instancetype)initWithCoder:(NSCoder *)coder</code> 和 <code>- (instancetype)initWithFrame:(CGRect)frame</code> 方法内执行一些通用的公共的初始化方法，于是便实现了一个 <code>- (void)_commonInit</code> 方法完成这个目标。于是奇怪的现象发生了，代码并没有按照预期的那样运行。在作者百思不得其解的时候，想到了通过查看分析 UIRefreshControl 类的反编译伪代码发现，我自己的方法名 <code>_commonInit</code> 与该视图类的私有方法重名了，才导致出现莫名其妙的 bug 。</p>
<p>iOS 开发者们也许很好奇，经常使用 Xcode 跳到 UIKit 框架的头文件中阅读，然后还想尝试一下找到 UIKit.framework 所在的路径，通过 show in Finder 跳转到了指定的文件却始终找不到 UIKit 的二进制文件？那系统是如何知道 UIKit 的具体实现的？一般的 APP 在它的包内就能找到二进制文件（在 iOS 中也叫 MachO 文件），但是 iOS 系统库的二进制文件的确不太好找。关于如何找到系统库的二进制文件，如何查看它的反编译伪代码，这一切的答案都会在后续的文章更新中揭晓。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>Block</title>
    <url>/2025/04/29/Block/</url>
    <content><![CDATA[<!--

逻辑的 Block 从 22 节课的 01：33：58 开始。

介绍了要讲的东西：
1. block 的分类？
2. block 函数式 + 响应式
3. block 循环引用
4. 探索 block 
    4.1 为什么 %@ ？？？
    4.2 捕获自动变量
    4.3 block() ？？？
    4.4 __block 底层原理？
5. block 的 copy、release、dispose、assign
6. Hook block，在逆向中有这个需求。

根据 block 所在的内存分为三种类型，全局 block，栈 block，堆 block，底层还存在其他三种类型，但这里我表示怀疑！

block 作为返回值，block 作为参数。。。什么狗屁函数式 y=f(x) 讲的什么狗屁不通的东西，真尼玛的

01：50：36-02：21：00
讲循环引用了。上来就是一段代码案例：
结果案例讲着讲着不知道又飞到哪里去了。。。讲的什么狗屎啊，现在想明白了，原来是介绍循环引用？但是你这介绍的也太让人无语了，关键的底层结构你又不展示
居然说 __weak typeof(self) weakSelf = self; 之后的指向是这个样子？
weakSelf -> self(引用计数不处理) -- nil -> block -> weakSelf ？？？
weakSelf 的指向我不明白，不跟你争，这里明明是 block 捕获 weakSelf 的时候指针变为弱引用了，你居然说 self 持有的 block 引用计数不处理？？？
但是后续的这个场景倒是蛮重要的。这个场景简直太妙了。
就是在 Block 里面嵌套一个 dispatch_after 然后当前界面退出，after n 秒之后 weakSelf 变为 nil 的问题。


虽然答案是对的，但是讲的也是错的。
还听明白了吗？明白你妈逼个傻逼东西！！！
\_\_block 加手动置 nil 加一定调用也可以解决循环引用。
将 self 作为 Block 的参数传递也可以解决问题
讲了三种解决这种循环引用的方式

02：21：00 结束课程了，后面都是扯淡不需要看了

23 节课

开始-00：21：19
直接就是对一个 block.c 文件 Clang 也不说是在干什么。等于就是介绍 Clang rewrite 之后的结构体了。
乱七八糟的一顿乱讲

00：22：23-01：04：25
突然就找到了 libclouse 中的 Block_private.h。还尼玛在配置底层源码，原来早就有字节一个大哥开源十多年了。。。
讲解底层结构中的成员作用了，如 flags 中每一位的意义，descriptor 是什么
汇编调试底层能看到细节，但是没搞懂他想看到什么细节。。。
寄存器读来读去是干什么也不说明
不就是从全局 Block 变 栈 Block 再到 堆 Block 的演示么。。。
然后是调用 Block ？不知道在嗨什么啊？？？
Block 作为对象有签名吗？？？这是个什么意思啊？莫名其妙对象就都有签名吗？
Block 的类型编码是@？

01：13：37-01：21：46
找签名信息

01：22：30-01：30：30
。。。

01：31：14-01：11：11
字面量无法Clang？问题是为什么也不讲
forwarding 都指向堆区的 Block 

01：13：36-02：05：55
什么jb Block三层拷贝？

02：07：19-02：25：43
Block 的 hook ？应用场景？埋点
讲的什么几把狗屎玩意儿？
 
02：25：43-结束
还要我们反思一下？你这个废物东西讲的什么狗jb玩意儿？还要我们反省一下？？？
说自己在阿里的时候30多k，我们学完至少也得20多k。。。说尘舒没有25k去打死他。2020年3月6日。2025年05月08日16:14:04。过去5年了。。。

-->



<h1 id="Block-一些疑问"><a href="#Block-一些疑问" class="headerlink" title="Block 一些疑问"></a>Block 一些疑问</h1><blockquote>
<p>注意：本文章不是讲解 Block 基础的文章，需要读者有一定的 Block 编程基础。</p>
</blockquote>
<p>Block 在我们日常开发中经常会用到，但是它的本质是什么？</p>
<p>__block 是什么？有什么作用？有什么使用注意点？</p>
<p>Block 的属性应该使用什么修饰词？strong 还是 copy？为什么</p>
<p>Block 的代码块内部修改 NSMutableArray，需不需要添加 __block？</p>
<hr>
<h1 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h1><p>Block 的本质​​是一个封装了函数指针和上下文数据的 ​​Objective-C 对象​。它的底层实现是结构体，这和 Objective-C 对象的底层实现一样​。这个函数指针指向的就是 Block 的主体内的代码所封装出来的函数。而上下文数据就是块主体内用到的其定义范围内的局部变量，可以是自动变量 auto（就是栈上分配的局部变量），也可以是静态变量 static。如果代码块内部没有用到外部的变量就不会被捕获上下文数据到 Block 中去。</p>
<p>我们创建一个 macOS 上的 Command Line Tool 程序来学习 Block 的底层实现。在 main.m 文件中的 main 函数中实现一个最简单的 Block 。如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">void</span> (^aBlock)(<span class="type">void</span>);</span><br><span class="line">    aBlock = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i&#x27;m block&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个没有返回值，没有参数，也没有调用的 Block。</p>
<p>Clang 是 LLVM 编译器的编译器前端，用来编译 C，C++，Objective-C 等语言的源码，Xcode 也是使用 Clang 实现的编译能力。它提供了一个 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-rewrite-objc">-rewrite-objc</a> 的参数用来将 Objective-C 代码重写为等价的 C++ 代码，我们可以通过这种形式看到 Objective-C 源码的底层实现。打开终端并进入到 main.m 所在的目录，我们使用 Clang 将 main.m 文件重写为等价的 C++ 代码。如下图：</p>
<img src="/2025/04/29/Block/Snip20250505_1.png" class="">

<p>可以看到虽然给出了一些警告，但是并不影响最终成功生成 main.cpp 文件的结果。打开 main.cpp 文件之后，我们拉倒最底部可以看到我们 main 函数内部经过 Clang 重写之后的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Block 的通用基础结构（简化）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="type">void</span> *isa;			<span class="comment">// 指向 Block 的类信息（如 NSStackBlock、NSMallocBlock）</span></span><br><span class="line">  <span class="type">int</span> Flags;			<span class="comment">// 状态标记（是否被拷贝、是否有析构函数等）</span></span><br><span class="line">  <span class="type">int</span> Reserved;		<span class="comment">// 保留字段</span></span><br><span class="line">  <span class="type">void</span> *FuncPtr;		<span class="comment">// 函数指针，指向 Block 实际执行的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体 Block 的完整结构（包含捕获的变量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span>			<span class="comment">// 基础结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span>	<span class="comment">// 描述信息（大小、copy/dispose 函数）</span></span><br><span class="line">  <span class="comment">// 结构体的构造函数，函数名跟结构体一样</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block 的函数体封装成的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i&#x27;m block&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block 的描述信息</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">void</span> (*aBlock)(<span class="type">void</span>);</span><br><span class="line">    aBlock = ((<span class="type">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比 main 函数的代码之后，我们会发现原来的最简单的一个 Block 经过编译器重写之后多出了三个结构体和一个函数。</p>
<ul>
<li><strong>static void __main_block_func_0()</strong> 这个函数的内部就是 Block 的 {} 内的代码。</li>
<li><strong>struct __block_impl</strong> 这个结构体是所有 Block 的基础结构，第一个成员是 isa 指针，跟 NSObject 对象的第一个成员一模一样。有点所有具体 Block 类的抽象父类的意思。</li>
<li><strong>struct __main_block_impl_0</strong> 这个结构体就是我们 main 函数中最简单的 Block 的底层实现。第一个成员就是上面的 Block 的基础结构体，第二个成员是 <code>struct __main_block_desc_0* Desc</code> 结构体指针。</li>
<li><strong>static struct __main_block_desc_0</strong> 这个 Block 的描述信息</li>
</ul>
<blockquote>
<p>注意：需要明确的是这里我们通过 clang 的 -rewrite-objc 操作将 Objective-C 代码重写为 C++ 代码，但并不就意味着 Objective-C 的底层是由 C++ 实现的，Objective-C 的底层依旧是 C 实现的。Objective-C 的对外接口和 ABI 规范​​是纯 C 的，但其实现可能混合 C++ 和汇编优化。</p>
</blockquote>
<p><code>struct __block_impl</code> 的第一个成员变量是 isa，这就是 Objective-C 对象的底层表示。可能还是有很多人表示怀疑怎么就是 Objective-C 对象了，那么我可以贴上苹果文档中的原话。。。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxOverview.html">Although blocks are available to pure C and C++, a block is also always an Objective-C object.</a></p>
<p>在这个简单的 Block 的底层结构体 <code>struct __main_block_impl_0</code> 中，我们只看到它有一个函数指针 <code>void *FuncPtr</code>，指向了它的代码块内部封装成的函数。没有看到它封装的上下文数据，这是因为我们这个简单的 Block 体内并没有访问任何外部的变量，所以并不会将任何上下文数据捕获到 Block 内。</p>
<p>我们尝试将前面极其简单的 Block 进行一下升级，将在 Block 的内部访问外部一个基本数据类型 int a。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span> (^aBlock)(<span class="type">void</span>);</span><br><span class="line">    aBlock = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;a = %d&quot;</span>, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次在终端输入 <code>clang -rewrite-objc main.m</code> 之后，会重新生成 main.cpp 文件并覆盖原来的 main.cpp 文件。下拉到最底部可以看到以下生成的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="type">int</span> a;	<span class="comment">// 将局部变量 int a 捕获到了结构体内，</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _a, <span class="type">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="type">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_rt_zkm8hst55kv45x396jh95v3h0000gn_T_main_6474c8_mi_0, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span> (*aBlock)(<span class="type">void</span>);</span><br><span class="line">    aBlock = ((<span class="type">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次我们明显的看到 <code>struct __main_block_impl_0</code> 结构体中多了一个成员 int a，这就是 Block 对外部变量的捕获。</p>
<h1 id="Block-的几种类型"><a href="#Block-的几种类型" class="headerlink" title="Block 的几种类型"></a>Block 的几种类型</h1><p>我们已经知道 Block 就是一个 Objective-C 对象，那么可以通过 class 方法，或者 isa 指针查看 Block 的类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">	<span class="type">void</span> (^aBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;hello world&quot;</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [aBlock <span class="keyword">class</span>]);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [[aBlock <span class="keyword">class</span>] superclass]);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [[[aBlock <span class="keyword">class</span>] superclass] superclass]);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [[[[aBlock <span class="keyword">class</span>] superclass] superclass] superclass]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__NSGlobalBlock__</span><br><span class="line">NSBlock</span><br><span class="line">NSObject</span><br><span class="line">(null)</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>

<p>从打印的结果可以验证，Block 的祖先是 NSObject，那它当然是一个 Objective-C 对象，当然存在 isa 指针了。</p>
<p>其实在 Objective-C 中，Block 的类型主要根据其所在的内存分为三种，具体如下：</p>
<h2 id="NSGlobalBlock（全局Block）"><a href="#NSGlobalBlock（全局Block）" class="headerlink" title="NSGlobalBlock（全局Block）"></a>NSGlobalBlock（全局Block）</h2><ul>
<li>定义：没有捕获 auto 变量（也就是栈上的局部变量）的 Block。</li>
<li>内存位置：存储在程序的数据区（类似于全局变量），生命周期与程序一致。</li>
<li>示例：  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (^globalBlock)(<span class="type">void</span>) = ^&#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;This is a global block.&quot;</span>); &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="NSStackBlock（栈Block）"><a href="#NSStackBlock（栈Block）" class="headerlink" title="NSStackBlock（栈Block）"></a>NSStackBlock（栈Block）</h2><ul>
<li>定义：捕获了 auto 变量的 Block，且未被复制到堆中。</li>
<li>内存位置：存储在栈上，生命周期与当前函数栈帧一致，函数返回后可能被销毁。</li>
<li>注意：在 ARC 环境下，编译器会自动将栈 Block 复制到堆，因此通常不会直接看到栈 Block。</li>
<li>示例1（在 MRC 环境下）：  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> (^stackBlock)(<span class="type">void</span>) = ^&#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;Captured variable: %d&quot;</span>, a); &#125;;</span><br><span class="line"><span class="comment">// 未调用copy方法时，stackBlock为NSStackBlock。</span></span><br></pre></td></tr></table></figure></li>
<li>示例2（在 ARC 环境下）  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, a);</span><br><span class="line">&#125; <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>ARC 环境还是 MRC 环境可以在 Xcode 的 Build Settings 下的 Objective-C Automatic Reference Counting 设置。</p>
</blockquote>
<h2 id="NSMallocBlock（堆Block）​"><a href="#NSMallocBlock（堆Block）​" class="headerlink" title="NSMallocBlock（堆Block）​"></a>NSMallocBlock（堆Block）​</h2><ul>
<li>定义：栈 Block 被显式（MRC）或自动（ARC）复制到堆中后的形态。</li>
<li>内存位置​​：存储在堆中，由引用计数管理生命周期，可被多次使用或跨线程传递。</li>
<li>示例：  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> (^heapBlock)(<span class="type">void</span>) = [^&#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;Captured variable: %d&quot;</span>, a); &#125; <span class="keyword">copy</span>];</span><br><span class="line"><span class="comment">// 在MRC中需手动调用copy，ARC会自动处理。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关于-Block-类型数量的争议"><a href="#关于-Block-类型数量的争议" class="headerlink" title="关于 Block 类型数量的争议"></a>关于 Block 类型数量的争议</h2><p>在 Objective-C 的 ​​语言层面​​，Block 主要分为 <code>NSGlobalBlock</code>、<code>NSStackBlock</code> 和 <code>NSMallocBlock</code> 三种类型。如果深入研究 LLVM 编译器有关 <a href="https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/BlocksRuntime">Block</a> 的部分，或者 Block 的运行时库 <a href="https://github.com/apple-oss-distributions/libclosure/tree/main">libclosure</a>。就会看到还存在一些特殊的类型 <code>_NSConcreteFinalizingBlock </code>，<code>_NSConcreteAutoBlock </code>，<code>_NSConcreteWeakBlockVariable </code> 但是这些类型通常对开发者不可见，属于内部实现细节。</p>
<h1 id="变量捕获机制"><a href="#变量捕获机制" class="headerlink" title="变量捕获机制"></a>变量捕获机制</h1><p>在 Block 的代码块内部使用或者访问了全局变量，不论是普通的全局变量，还是静态的全局变量，所有全局变量均不会被 Block 捕获到结构体中​​，Block 直接通过地址访问它们。所以这种情况最简单也无需讨论了。</p>
<p>如果在 Block 的代码块内部访问或者使用了外部的局部变量，那么这些局部变量就会被捕获到 Block 的底层结构体中，这个就是 Block 的变量捕获机制。Block 的底层结构会根据捕获的变量类型和修饰符（如 __block）动态生成不同的结构体。其实更准确的说，Block 内部是一个函数栈，外部的局部变量也是一个函数栈，两个栈上的局部变量如果不进行特殊处理是无法互相访问和操作的，如果你的 Block 内部使用了外部的局部变量此时编译器会对 Block 内使用的外部变量进行特殊的处理。</p>
<p>那为啥 Block 的内部只捕获局部变量而不捕获全局变量呢？站在内存的角度来思考就很容易理解。局部变量的作用域结束后，其栈内存会被回收。Block 必须捕获其值或地址，以确保后续执行时仍能安全访问。</p>
<h2 id="自动变量（auto-变量）"><a href="#自动变量（auto-变量）" class="headerlink" title="自动变量（auto 变量）"></a>自动变量（auto 变量）</h2><h3 id="基本类型（如-int、float）"><a href="#基本类型（如-int、float）" class="headerlink" title="基本类型（如 int、float）"></a>基本类型（如 int、float）</h3><p>默认捕获变量的瞬时值，Block 内部不能修改。后续外部变量的修改不影响 Block 内的副本。</p>
<p>在 C 语言中，默认的局部变量就是 auto 变量，存储在栈上，由操作系统管理其内存。以下是 Block 捕获基本数据类型的 auto 变量的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">	<span class="type">void</span> (^aBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, age); <span class="comment">// 捕获 age 的值为 10</span></span><br><span class="line">	&#125;;</span><br><span class="line">	age = <span class="number">20</span>;</span><br><span class="line">	aBlock(); <span class="comment">// 输出 10 而非 20</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>clang -rewrite-objc main.m</code> 重新生成 <code>main.cpp</code> 文件之后查看生成的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _age, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">age</span>(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">	<span class="type">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">	<span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_rt_zkm8hst55kv45x396jh95v3h0000gn_T_main_6fec5e_mi_0, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// __main_block_impl_0 结构体中的 age 是通过值传递的方式捕获的</span></span><br><span class="line">    <span class="built_in">void</span> (*aBlock)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">    ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)aBlock)-&gt;FuncPtr)((__block_impl *)aBlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，在源码中 Block 的内部使用到了外部定义的局部变量 age，那么 Block 的底层结构中就会多出一个成员变量 <code>int age</code>。观察生成的 C++ 代码之后会发现，Block 的主体部分封装成的函数 <code>__main_block_func_0</code> 中的确使用到了 age。但是这个变量 age 是存放在 <code>struct __main_block_impl_0</code> 结构体中的，并在创建结构体实例的时候使用外部的变量 age 进行了初始化，这样虽然类型和名字和外部的变量一模一样，但是这显然不是同一个变量。所以在外部无论如何修改 age 的值，是完全不会改变 Block 对象内部的 age 变量值的。</p>
<h3 id="对象类型（如-NSObject）"><a href="#对象类型（如-NSObject）" class="headerlink" title="对象类型（如 NSObject）"></a>对象类型（如 NSObject）</h3><p>捕获指针的副本，并强引用对象。Block 内部访问的是原始对象，但无法修改指针的指向。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, str); </span><br><span class="line">&#125;;</span><br><span class="line">str = <span class="string">@&quot;World&quot;</span>;</span><br><span class="line">block(); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>想知道为什么会这样，同样可以查看 Clang 重写为 C++ 之后的底层实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  NSString *str;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, NSString *_str, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">str</span>(_str) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    NSString *str = __cself-&gt;str; <span class="comment">// bound by copy</span></span><br><span class="line">    <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_rt_zkm8hst55kv45x396jh95v3h0000gn_T_main_a30fa6_mi_1, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;str, (<span class="type">void</span>*)src-&gt;str, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="type">void</span>*)src-&gt;str, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    NSString *str = (NSString *)&amp;__NSConstantStringImpl__var_folders_rt_zkm8hst55kv45x396jh95v3h0000gn_T_main_a30fa6_mi_0;</span><br><span class="line">    <span class="built_in">void</span> (*block)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, str, <span class="number">570425344</span>));</span><br><span class="line">    str = (NSString *)&amp;__NSConstantStringImpl__var_folders_rt_zkm8hst55kv45x396jh95v3h0000gn_T_main_a30fa6_mi_2;</span><br><span class="line">    ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, str, 570425344));</code> 这句代码中是 Block 进行创建的时候，传入的参数是 str，而不是 &amp;str。所以这跟 static 修饰的变量并不完全一样。此时 Block 底层结构体内的成员 <code>NSString *str</code> 和外部的 str 指向了同一个对象。但是对外部 str 的重新赋值并不会影响内部 str 的指向。</p>
<h2 id="block-修饰的变量"><a href="#block-修饰的变量" class="headerlink" title="__block 修饰的变量"></a>__block 修饰的变量</h2><p>允许 Block 捕获变量的地址，支持在 Block 内外同步修改。变量会被移动到堆区以延长生命周期。至于 __block 的底层原理会在后面详细分析。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    a = <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">block();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, a); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<h2 id="static-修饰的变量"><a href="#static-修饰的变量" class="headerlink" title="static 修饰的变量"></a>static 修饰的变量</h2><p>对于全局的 static 变量来说直接访问内存地址，不会捕获到 Block 中去。但是对于局部的 static 变量来说同样是访问内存地址，但是会以指针形式被捕获到 Block 中去。Block 内外修改实时同步。以下演示的是局部 static 变量被捕获的底层实现。</p>
<p>修改源码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> height = <span class="number">50</span>;</span><br><span class="line">	<span class="type">void</span> (^aBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d, height is %d&quot;</span>, age, height);</span><br><span class="line">	&#125;;</span><br><span class="line">	age = <span class="number">20</span>;</span><br><span class="line">	height = <span class="number">100</span>;</span><br><span class="line">	aBlock();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>clang -rewrite-objc main.m</code> 重新生成 <code>main.cpp</code> 文件之后查看生成的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> *height;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _age, <span class="type">int</span> *_height, <span class="type">int</span> flags=<span class="number">0</span>) : age(_age), height(_height) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="type">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">    <span class="type">int</span> *height = __cself-&gt;height; <span class="comment">// bound by copy</span></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_rt_zkm8hst55kv45x396jh95v3h0000gn_T_main_25f577_mi_0, age, (*height));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> height = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 将 height 的地址传给了 Block</span></span><br><span class="line">    <span class="type">void</span> (*aBlock)(<span class="type">void</span>) = ((<span class="type">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height));</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">    height = <span class="number">100</span>;</span><br><span class="line">    ((<span class="type">void</span> (*)(__block_impl *))((__block_impl *)aBlock)-&gt;FuncPtr)((__block_impl *)aBlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察生成的 C++ 代码可知，static 变量也捕获到 Block 的内部去了。但是跟 auto 变量不同，Block 捕获了 static 变量的指针。在创建 Block 的时候将 height 的地址传入参数。这样不论在 Block 的内部还是外部，就都能实现读写这个变量。</p>
<h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p>通过隐式捕获 <strong>self</strong> 间接访问。Block 会强引用 <strong>self</strong>，可能导致循环引用（若 self 持有 Block）。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, <span class="keyword">self</span>.value); <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span>.value = <span class="number">20</span>;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 Objective-C 中，所有的方法，不论是对象方法还是类方法，在经过编译器处理之后都以 C 语言函数的形式存在底层，其中 C 函数的第一个参数就是 id self，第二个参数时 SEL _cmd 是方法名。如果 Objective-C 方法有参数，那么 C 函数的第三个参数就是方法的参数。在 C 语言中，参数也是局部变量，所以 Block 会捕获 self 到底层结构中。可以通过 Clang 进行验证。首先是源码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = <span class="number">10</span>;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, <span class="keyword">self</span>.value); <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span>.value = <span class="number">20</span>;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    MyClass *obj = [MyClass alloc];</span><br><span class="line">    [obj test];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Clang 重写为 C++ 代码之后，查看 Block 的底层结构体：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __MyClass__test_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __MyClass__test_block_desc_0* Desc;</span><br><span class="line">  MyClass *<span class="keyword">self</span>;</span><br><span class="line">  __MyClass__test_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __MyClass__test_block_desc_0 *desc, MyClass *_<span class="keyword">self</span>, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到 MyClass *self 被捕获到 Block 的底层结构中了。</p>
<h1 id="Block-的-copy"><a href="#Block-的-copy" class="headerlink" title="Block 的 copy"></a>Block 的 copy</h1><p>在讲 Block 的 copy 之前，先简单介绍一下 MRC 和 ARC</p>
<p>MRC 是手动引用计数的意思，对象的释放与否完全和引用计数关联，当对象的引用计数为 0 时，对象会被释放，内存被系统回收。通过调用 retain 方法会让对象的引用计数加 1，通过调用 release 方法会让对象的引用计数减 1。</p>
<p>而 ARC 是自动引用计数，这里自动的意思其实是编译器帮程序员完成了内存管理，本质依旧是基于 MRC 的引用计数的，编译器分析源码之后在合适的位置插入了 retain 和 release，从而让程序员不需要显示调用 retain 和 release 管理对象内存了。</p>
<p>所以说在 Objective-C 中，如果是使用了 ARC 的情况下，程序员是不需要管理对象内存的，只需要注意对象间可能循环引用导致无法释放的问题。</p>
<p>在 ARC 环境下，编译器会根据情况自动将栈上的 Block 拷贝到堆上，比如以下情况：</p>
<ul>
<li>Block 作为函数的返回值时</li>
<li>将 Block 赋值给 strong 指针时</li>
<li>Block 作为 Cocoa API 中方法名含有 usingBlock 的方法参数时</li>
<li>Block 作为 GCD API 的方法参数时</li>
</ul>
<p>在 MRC 环境中，Block 属性应该使用 copy 特性：<br>    <code>@property (nonatomic, copy) void (^block)(void);</code></p>
<p>在 ARC 环境中，Block 属性可以使用 strong 也可以使用 copy，即使使用 strong 在 ARC 下编译器依然会 copy。</p>
<h1 id="对象类型的-auto-变量释放的问题"><a href="#对象类型的-auto-变量释放的问题" class="headerlink" title="对象类型的 auto 变量释放的问题"></a>对象类型的 auto 变量释放的问题</h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景 1"></a>场景 1</h2><p>我们看一下这个场景：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person alloc];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        block = ^()&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, person.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        [person release];</span><br><span class="line">    &#125;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是 MRC 环境下的，在执行 block() 的时候会发生崩溃：<code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x796a6bda0068)</code></p>
<p>为什么会发生崩溃呢？其实 Person 的实例 person 在 {} 内创建，同时也在 {} 内释放。再执行到 block() 的时候，person 实例早已经被系统回收了，再去访问当然报糟糕的访问错误。那怎么解决这个问题呢？对 block 调用一次 copy 就可以了。block 调用 copy 时，它会同时对它持有的对象进行内存管理。这样就可以解决这个访问错误问题了。如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person alloc];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        block = [^()&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, person.age);</span><br><span class="line">        &#125; <span class="keyword">copy</span>];</span><br><span class="line">        [person release];</span><br><span class="line">    &#125;</span><br><span class="line">    block();</span><br><span class="line">    [block release];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也从侧面说明了，栈上的 Block 并不会对它持有的对象进行内存管理，所以在栈上的 Block 访问外部的对象类型局部变量的时候，是没有意义的，是一定会报错糟糕的访问的。所以到了 ARC 中，Block 内访问对象类型的 auto 变量的情况下编译器都会自动将 Block 拷贝到堆上。</p>
<h2 id="场景-2"><a href="#场景-2" class="headerlink" title="场景 2"></a>场景 2</h2><p>以下代码是在 ARC 环境下的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person alloc];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        block = ^()&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, person.age);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是没有问题的，能够按照预期执行的。Person 实例的释放是在 block 释放时发生的。如果我们在 block 内部访问 __weak 修饰的对象 auto 变量，会发生什么变化。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person alloc];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        __<span class="keyword">weak</span> Person *weakperson = person;</span><br><span class="line">        block = ^()&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, weakperson.age);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，观察程序的运行会发现，在 block() 调用之前，Person 的实例就早已经释放了，并且最终打印的结果也不是 10，而是 0。应该说这也是预期的结果吧，__weak 修饰的变量，即使 Block 被拷贝到堆中的时候，也不会对它持有的 Person *person 进行 retain 导致引用计数加 1。</p>
<p>可以使用以下命令重写为底层的 C++ 代码，可以查看到底层的 Block 结构体内的 person 实例也带上了 __weak 修饰符。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -<span class="built_in">arch</span> arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-5.0.0 main.m</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  Person *__<span class="keyword">weak</span> weakperson;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, Person *__<span class="keyword">weak</span> _weakperson, <span class="type">int</span> flags=<span class="number">0</span>) : weakperson(_weakperson) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="测验1"><a href="#测验1" class="headerlink" title="测验1"></a>测验1</h2><p>以下代码中，person 实例是什么时候释放？touchesBegan: 方法执行完成就释放，还是 2 秒之后释放？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    Person *person = [Person alloc];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, person);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>GCD 的 Block 编译器在编译时会自动调用 copy 方法将它拷贝到内存堆区中，那么 Block 就会对它持有的 Person *person 进行内存管理，使 person 实例的引用计数加 1。这样即使是 touchesBegan: 方法执行完了，person 实例也不会被立即释放，因为还有 Block 对它进行强引用，只有等 2 秒之后，Block 执行完成后被释放时，它会对持有的 person 实例进行一个 release 操作，如果此时 person 的引用计数也是 0 了，那么它也就被系统回收了。</p>
<h2 id="测验2"><a href="#测验2" class="headerlink" title="测验2"></a>测验2</h2><p>以下代码中，person 实例是什么时候释放？touchesBegan: 方法执行完成就释放，还是 2 秒之后释放？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    Person *person = [Person alloc];</span><br><span class="line">    __<span class="keyword">weak</span> Person *weakperson = person;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, weakperson);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>根据前面所讲的内容，这也很容易知道答案了，person 在 touchesBegan: 方法执行完之后立即被释放。2 秒后的打印是 null。</p>
<h2 id="测验3"><a href="#测验3" class="headerlink" title="测验3"></a>测验3</h2><p>person 实例是什么时候释放？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    Person *person = [Person alloc];</span><br><span class="line">    __<span class="keyword">weak</span> Person *weakperson = person;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1-------%@&quot;</span>, person);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;2------%@&quot;</span>, weakperson);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>1 秒后打印结果并释放，3 秒后打印 null。对于这种比较复杂的，有多层 Block 嵌套的情况，建议使用 Clang 重写为 C++ 代码之后，查看到底有几个 Block，每个 Block 究竟捕获了什么变量就能轻松的分析出打印的结果了。</p>
<h2 id="测验4"><a href="#测验4" class="headerlink" title="测验4"></a>测验4</h2><p>person 实例是什么时候释放？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    Person *person = [Person alloc];</span><br><span class="line">    __<span class="keyword">weak</span> Person *weakperson = person;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1-------%@&quot;</span>, weakperson);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;2------%@&quot;</span>, person);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>3 秒之后释放。</p>
<h1 id="block-修饰符"><a href="#block-修饰符" class="headerlink" title="__block 修饰符"></a>__block 修饰符</h1><p>在 Objective-C 中，<code>__block</code> 修饰符用于解决在 Block 内部修改外部变量的问题，并涉及到底层的内存管理机制。以下是详细解析：</p>
<h2 id="一、-block-的作用"><a href="#一、-block-的作用" class="headerlink" title="一、__block 的作用"></a>一、<code>__block</code> 的作用</h2><h3 id="1-允许-Block-修改外部变量"><a href="#1-允许-Block-修改外部变量" class="headerlink" title="1. 允许 Block 修改外部变量"></a>1. 允许 Block 修改外部变量</h3><p>默认情况下，Block 捕获的外部变量是只读的（按值捕获）。使用 <code>__block</code> 后，变量变为可在  Block 内修改，例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    a = <span class="number">20</span>; <span class="comment">// 允许修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-延长变量的生命周期"><a href="#2-延长变量的生命周期" class="headerlink" title="2.延长变量的生命周期"></a>2.延长变量的生命周期</h3><p><code>__block</code> 变量会随 Block 的拷贝（从栈到堆）而延长生命周期，确保在 Block 执行时变量依然有效。</p>
<h3 id="3-避免循环引用时的注意事项"><a href="#3-避免循环引用时的注意事项" class="headerlink" title="3.避免循环引用时的注意事项"></a>3.避免循环引用时的注意事项</h3><p>在 ARC 下，<code>__block</code> 变量会被 Block 强引用，可能导致循环引用。需配合 <code>__weak</code> 或手动置空解决：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block __<span class="keyword">weak</span> MyObject *weakObj = obj;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">__block MyObject *strongObj = obj;</span><br><span class="line">^&#123;</span><br><span class="line">    [strongObj doSomething];</span><br><span class="line">    strongObj = <span class="literal">nil</span>; <span class="comment">// 打破循环引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二、底层实现原理"><a href="#二、底层实现原理" class="headerlink" title="二、底层实现原理"></a>二、底层实现原理</h2><p>编译器会将 <code>__block</code> 修饰的变量包装在一个结构体中，处理内存管理和访问逻辑：</p>
<ol>
<li>结构体封装<br> 变量被包裹在类似以下的结构体中： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *__isa;                <span class="comment">// 类型指针</span></span><br><span class="line">    __Block_byref_a_0 *__forwarding; <span class="comment">// 指向当前实例的指针</span></span><br><span class="line">    <span class="type">int</span> __flags;</span><br><span class="line">    <span class="type">int</span> __size;</span><br><span class="line">    <span class="type">int</span> a;                      <span class="comment">// 原始变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 Block 内部通过指针持有该结构体</li>
<li>内存管理<ul>
<li><strong>栈到堆的拷贝</strong>：当 Block 被复制到堆时，<code>__block</code> 结构体也会被复制到堆，栈结构体的 <code>__forwarding</code> 指向堆上的新地址。</li>
<li><strong>统一的访问逻辑</strong>：无论结构体在栈还是堆，通过 <code>__forwarding-&gt;a</code> 访问变量，确保修改的是最终位置的值。</li>
</ul>
</li>
<li>ARC 与 MRC 的差异<ul>
<li>MRC 下：<code>__block</code> 变量不会被 Block retain，需手动管理内存。这点需要特别注意！如在前面的场景 1 中，如果给 <code>Person *person</code> 加上了 <code>__block</code> 即使 Block 被拷贝到堆，person 的引用计数并没有增加。执行 Block 时就会发生崩溃。</li>
<li>ARC 下：编译器自动处理结构体的内存，对象类型变量会被强引用，可能需用 <code>__weak</code> 避免循环引用。</li>
</ul>
</li>
</ol>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul>
<li>用途：允许 Block 内部修改外部变量，并管理其生命周期。</li>
<li>原理：通过结构体封装变量，利用 <code>__forwarding</code> 指针处理内存迁移，确保跨栈&#x2F;堆访问的一致性。</li>
<li>注意事项：在 ARC 中需警惕循环引用，合理使用 <code>__weak</code> 或手动断开强引用。</li>
</ul>
<p>通过 <code>__block</code>，Objective-C 实现了 Block 对外部变量的灵活操作，同时依赖编译器的底层支持确保内存安全。</p>
<hr>
<h1 id="Block-循环引用问题及解决方案"><a href="#Block-循环引用问题及解决方案" class="headerlink" title="Block 循环引用问题及解决方案"></a>Block 循环引用问题及解决方案</h1><h2 id="什么是循环引用？"><a href="#什么是循环引用？" class="headerlink" title="什么是循环引用？"></a>什么是循环引用？</h2><ul>
<li><strong>循环引用</strong> 发生在两个或多个对象之间<strong>互相强引用</strong>，导致对象无法正常释放，引发内存泄漏。</li>
<li>在 Block 中，如果 <strong>Block 捕获了持有它的对象</strong>（如 <code>self</code>），而该对象又 <strong>直接或间接强引用了 Block</strong>，就会形成循环引用。</li>
</ul>
<h2 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：ClassA 强持有 myBlock，myBlock 内部又隐式强持有了 self（ClassA）</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="type">void</span> (^myBlock)(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line">- (<span class="type">void</span>)setupBlock &#123;</span><br><span class="line">    <span class="keyword">self</span>.myBlock = ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> doSomething]; <span class="comment">// 隐式捕获 self（强引用）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>首先 ClassA 明显强持有 myBlock 这点从代码中可以清晰的看到，而 myBlock 的代码块中使用了 self 这个隐式参数，它是个局部变量，会被 Block 捕获到底层的结构体中，保持它原来的强弱性质。这里 self 作为隐式参数，默认就是强引用，所以就构成了循环引用。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-使用-weak-弱引用"><a href="#1-使用-weak-弱引用" class="headerlink" title="1. 使用 __weak 弱引用"></a>1. 使用 <code>__weak</code> 弱引用</h3><ul>
<li>通过弱引用打破循环链</li>
<li>代码示例：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setupBlock &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myBlock = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf; <span class="comment">// 避免 weakSelf 提前释放</span></span><br><span class="line">        [strongSelf doSomething];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Block 内使用强指针并不是必须得。仅在某些场景下必须使用 <code>strongSelf;</code> 如 Block 内部使用了 GCD 的延迟函数，并在延迟函数的 Block 中需要用到 self。</p>
</blockquote>
<p>如以下这种情况：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="type">void</span> (^block)(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">@&quot;masterking&quot;</span>;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakself) strongself = weakself;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, strongself.name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span>.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用 strongself，在点击 ViewController 的视图时，会执行 Block，Block 内延迟 3 秒打印 name。如果在这 3 秒内退出了当前视图控制器，控制器会立即释放，GCD 会在 3 秒之后打印一个 <code>null</code>。使用 strongself 之后，即使在延迟的 3 秒内退出当前视图控制器，视图控制器也不会立即释放，而是等待 3 秒后的 GCD Block 执行完代码，释放 Block 的时候，对 ViewController 进行一次 <code>release</code> 才会被释放。</p>
<p>其实这个问题使用 clang 重写为底层的 C++ 代码之后，查看到底生成了几个 Block，每个 Block 捕获的成员是怎样的就很好理解了。控制器强引用着它的 Block，但是 Block 内使用的 weakself，所以它并没有对控制器强引用，这里不构成循环引用。而 GCD 的 Block 里面使用了 strongself，对控制器形成强引用，在 GCD 的 Block 拷贝到堆区时，会对它捕获的控制器进行一次 <code>retain</code> 使其引用计数加 1，所以即使时视图控制器从当前视图层次结构中移除，即正常的页面退出流程，它也不会被释放，因为 GCD 的 Block 还强引用着这个控制器，只有等 GCD 的 Block 执行完成，GCD 释放 Block 的时候，Block 释放它的成员的时候，控制器的引用计数才变为 0，内存被释放。</p>
<h3 id="2-使用-block-修饰符"><a href="#2-使用-block-修饰符" class="headerlink" title="2.使用 __block 修饰符"></a>2.使用 <code>__block</code> 修饰符</h3><ul>
<li>使用 <code>__block</code> 修饰符，在 Block 执行后主动断开引用，需要保证 Block 一定被执行，且最后手动置 nil 中断引用。</li>
<li>代码示例：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setupBlock &#123;</span><br><span class="line">    __block <span class="type">id</span> blockSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myBlock = ^&#123;</span><br><span class="line">        [blockSelf doSomething];</span><br><span class="line">        blockSelf = <span class="literal">nil</span>; <span class="comment">// 中断强引用</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span>.myBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-避免直接捕获-self"><a href="#3-避免直接捕获-self" class="headerlink" title="3.避免直接捕获 self"></a>3.避免直接捕获 self</h3><ul>
<li>若 Block 无需访问对象属性、方法，改用局部变量。或作为 Block 的参数传递</li>
<li>代码示例1，改用局部变量：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setupBlock &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> value = <span class="keyword">self</span>.age;</span><br><span class="line">    <span class="keyword">self</span>.myBlock = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld&quot;</span>, (<span class="type">long</span>)value); <span class="comment">// 不涉及 self</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码示例2，将 self 作为 Block 参数传递：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setupBlock &#123;</span><br><span class="line">	<span class="keyword">self</span>.myBlock = ^(<span class="built_in">UIViewController</span> *vc) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, vc);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">self</span>.myBlock(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-unsafe-unretained-解决"><a href="#4-使用-unsafe-unretained-解决" class="headerlink" title="4.使用 __unsafe_unretained 解决"></a>4.使用 __unsafe_unretained 解决</h3><p><code>__unsafe_unretained</code> 与 <code>__weak</code> 的关系</p>
<h4 id="1-推出时间"><a href="#1-推出时间" class="headerlink" title="1.推出时间"></a>1.推出时间</h4><p><code>__unsafe_unretained</code> 和 <code>__weak</code> 是在同一时期推出的，两者都是伴随 ARC（自动引用计数） 的引入而出现的（2011 年 WWDC 发布）。它们的设计初衷都是为了解决循环引用问题，但实现方式和安全性有所不同。</p>
<h4 id="2-为什么需要-unsafe-unretained"><a href="#2-为什么需要-unsafe-unretained" class="headerlink" title="2.为什么需要 __unsafe_unretained"></a>2.为什么需要 __unsafe_unretained</h4><p>尽管 <code>__weak</code> 更安全，但 <code>__unsafe_unretained</code> 仍然存在的意义如下：</p>
<ol>
<li>兼容性<ul>
<li>旧系统支持：<code>__weak</code> 要求最低部署目标为 iOS 5 或 macOS 10.7，而 <code>__unsafe_unretained</code> 可以在更早的系统中使用。</li>
<li>非 Objective-C 对象：<code>__weak</code> 仅适用于 Objective-C 对象，而 <code>__unsafe_unretained</code> 可用于 Core Foundation 等非 Objective-C 对象。</li>
</ul>
</li>
<li>性能优化<ul>
<li>零开销：<code>__weak</code> 在对象释放时会将指针自动置为 nil，这一操作需要运行时支持，可能带来轻微的性能损耗。而 <code>__unsafe_unretained</code> 无额外操作，性能更高。</li>
<li>特定场景适用：在明确对象生命周期且能确保安全访问时（如短期局部变量），<code>__unsafe_unretained</code> 可避免 <code>__weak</code> 的开销</li>
</ul>
</li>
<li>避免强引用副作用<ul>
<li>避免 <code>nil</code> 化：某些场景需要指针在对象释放后仍保留原地址（例如调试内存问题），<code>__weak</code> 的自动 <code>nil</code> 化会掩盖问题，而 <code>__unsafe_unretained</code> 能暴露野指针。</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>优先使用 <code>__weak</code>：绝大多数场景应选择 <code>__weak</code>，避免野指针崩溃。</li>
<li>谨慎使用 <code>__unsafe_unretained</code>：仅在需要兼容旧系统、明确生命周期管理或性能敏感时使用，并确保不会访问已释放对象。</li>
</ul>
]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>Runloop</title>
    <url>/2025/05/09/Runloop/</url>
    <content><![CDATA[<!--

138：基本认识
开始讲的是之前的内容，方法交换的细节。
然后是介绍一些 Runloop 相关的面试题。
什么是 Runloop？以及应用

139：获取 RunLoop 对象
iOS 应用在 UIApplicationMain() 里面创建 Runloop 运行
iOS 中有两套 API 可以使用 Runloop，一个是 C 提供的 Core Foundation 框架，一个是 Objective-C 提供的 Foundation 框架。其中 Core Foundation 部分开源可以在其中找到 CFRunLoop.h，CFRunLoop.c 文件。

140：CFRunLoopModeRef
一个mode里面主要有 source0，source1，observer，timer 四种集合。

142：CFRunLoopObserverRef
自己创建 Observer，添加 Observer 到 RunLoop，实现对 RunLoop 的 activity 的观察。有一个检测卡顿的第三方应该就是基于 Observer 实现的。

143：答疑

144：
执行流程，就是源码里做的事情。

145：源码分析
146：调用细节
147：休眠的细节
这个和普通的循环不一样，是怎么不占用CPU资源的，应该是调用了CPU提供的能力。
只有内核层面的API提供的，应用层的API是用不了的。
148：NSTimer的失效
讲了 RunLoop 的实际应用场景
1.子线程保证存活
2.解决NSTimer在滑动时停止工作，这个很多年前就知道了，只是当时并不知道RunLoop
3.监控应用卡顿，应该是检测卡顿吧
4.性能优化？？？不就是上面检测卡顿吗
commonModes并不是一个真正单独的模式

149：线程保活


-->





<h1 id="引出-RunLoop"><a href="#引出-RunLoop" class="headerlink" title="引出 RunLoop"></a>引出 RunLoop</h1><p>在学习 C 语言的时候，一般的命令行程序运行之后会马上结束。如果想要让程序不直接退出，而是一直等待用户的输入，并根据用户的输入决定是否退出程序，那就得加一个循环实现了。如以下这个简单的 C 程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="type">int</span> running = <span class="number">1</span>; <span class="comment">// 控制循环的变量</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="comment">// 打印菜单</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n--- 请选择操作 ---\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1. 打印Hello\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2. 打印Goodbye\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0. 退出程序\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入数字选择操作: &quot;</span>);</span><br><span class="line">        <span class="comment">// 读取用户输入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 输入无效（非数字），清空输入缓冲区</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;错误：请输入有效数字！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据用户输入执行操作</span></span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Goodbye!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                running = <span class="number">0</span>; <span class="comment">// 终止循环</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;程序即将退出...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无效选项，请重新输入！\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样使用一个循环就实现了让一个命令行程序运行之后不立即结束，并根据用户的输入执行不同的操作。那么对于 iOS 的应用程序来说，它同样是 APP 启动之后不会立即结束，并一直等待用户的交互，是不是同样存在着一个循环来实现这个效果的？答案是肯定，让 iOS 应用程序启动之后不立即结束，并一直等待用户交互的东西就是今天要介绍的 RunLoop。只不过相较于命令行程序的简单循环，RunLoop 的实现更加复杂。它负责处理用户的触摸事件，手势，UIView 的绘制，管理定时器，等等</p>
<p>对于第一次接触或者听说 RunLoop 的开发者来说，可能会感觉很抽象。但其实它一点儿也不抽象，它是一个实实在在的 CF 实例对象。它的实现在 <code>CoreFoundation</code> 框架。本质就是一个名为 <code>__CFRunLoop</code> 的 C 结构体及相关的 API 函数。在 Objective-C 层面，虽然存在一个 <code>NSRunLoop</code> 的类（来自于 <code>Foundation</code> 框架），但这个类只是对 <code>CoreFoundation</code> 框架中的 <code>CFRunLoopRef</code> 的包装，<code>NSRunLoop</code> 有一个成员变量就是 <code>CFRunLoopRef</code>，而 <code>CFRunLoopRef</code> 就是指向 <code>__CFRunLoop</code> 的结构体指针。</p>
<p>我们都知道 APP 在启动时会在入口点 <code>main</code> 函数中调用 <code>UIApplicationMain()</code> 函数。而这个函数里面会调用 <code>CoreFoundation</code> 提供的 <code>CFRunLoopRunInMode()</code> 函数启动运行循环，第一个参数传的是 <code>kCFRunLoopDefaultMode</code>，第二个和第三个参数传入的都是 0。我们可以添加一个符号断点来验证这个说法。之后我们会深入 <code>CoreFoundation</code> 的源码，分析 <code>CFRunLoopRunInMode()</code> 的底层实现。最后是一些 RunLoop 的应用场景。</p>
<h2 id="关于符号和符号断点"><a href="#关于符号和符号断点" class="headerlink" title="关于符号和符号断点"></a>关于符号和符号断点</h2><p>符号（Symbols）和符号断点（Symbolic Breakpoints）是调试过程中的重要工具。以下是它们的详细解释和用法：</p>
<h3 id="符号（Symbols）"><a href="#符号（Symbols）" class="headerlink" title="符号（Symbols）"></a>符号（Symbols）</h3><p>定义：</p>
<ul>
<li>符号是编译器在构建过程中生成的标识符，用于在二进制文件中表示代码中的实体（如函数、方法、类、全局变量等）。</li>
<li>在调试时，符号将机器码的地址映射回可读的源代码名称，帮助开发者理解程序执行流程。</li>
</ul>
<p>作用：</p>
<ul>
<li>​​<strong>调试信息​​：</strong>符号允许调试器（如LLDB）将内存地址、汇编指令与源代码中的变量名、方法名关联。</li>
<li><strong>崩溃分析​​：</strong>符号化的崩溃日志（Symbolicated Crash Logs）能将堆栈跟踪中的地址转换为可读的类名和方法名。</li>
<li><strong>动态链接​​：</strong>在动态库或框架中，符号用于运行时解析函数调用。</li>
</ul>
<p>生成条件：</p>
<ul>
<li>通常，​​Debug 构建配置​​会默认包含完整的调试符号，而​​ Release 配置​​可能会通过优化（如剥离符号）减少二进制体积。</li>
</ul>
<h3 id="符号断点（Symbolic-Breakpoints）"><a href="#符号断点（Symbolic-Breakpoints）" class="headerlink" title="符号断点（Symbolic Breakpoints）"></a>符号断点（Symbolic Breakpoints）</h3><p>定义：</p>
<ul>
<li>符号断点是一种根据符号名称（而非具体代码行）触发的断点。当程序执行到与符号匹配的位置时，调试器会暂停。</li>
</ul>
<p>常见用途：</p>
<ol>
<li>​​跟踪系统方法调用​​（如 <code>viewDidLoad</code>、<code>dealloc</code>）。</li>
<li>​​监控属性访问​​（如 <code>setter</code> 方法 <code>-[MyClass setName:]</code>）。</li>
<li>调试第三方库或框架​​（无需源码即可设置断点）。正是这次演示的用途。</li>
<li>分析特定条件的行为​​（如内存释放、网络请求触发）。</li>
</ol>
<h2 id="添加符号断点"><a href="#添加符号断点" class="headerlink" title="添加符号断点"></a>添加符号断点</h2><p>打开一个 iOS 工程，在 Xcode 的左侧导航栏中选择断点导航栏，然后点击左下角的 + 号添加一个符号断点：</p>
<img src="/2025/05/09/Runloop/Snip20250511_4.png" class="">

<p>符号名就是 <code>CFRunLoopRunInMode </code></p>
<img src="/2025/05/09/Runloop/Snip20250511_5.png" class="">

<h2 id="命中符号断点"><a href="#命中符号断点" class="headerlink" title="命中符号断点"></a>命中符号断点</h2><p>断点设置好之后，调试启动 APP 就会命中断点，不过可能第一次命中断点的时候并不是主线程，而是一个子线程启动了它的 RunLoop，过掉这个断点就好了，下一个就是我们主线程的 RunLoop 启动的断点了。如下图：</p>
<img src="/2025/05/09/Runloop/Snip20250511_8.png" class="">

<p>在汇编层面，函数的参数依次存放在寄存器 x0，x1，x2 等等之中，根据参数的个数依次存放在后续的寄存器中。通过 <code>register read</code> LLDB 命令，我们可以查看到函数的参数，除了第一个参数传入了字符串 <code>kCFRunLoopDefaultMode</code>，其他参数都是 0。当然参数个数过多时并不会继续放在后续的寄存器中，但这属于汇编语言层面的知识不是我们需要关注的重点。</p>
<p>现在我们知道，也验证了 iOS APP 启动的流程中会执行到 <code>CoreFoundation</code> 的 <code>CFRunLoopRunInMode()</code> 函数里，那到底这个函数做了什么，是如何实现 iOS APP 的永不结束的？将在下一篇中详细分析。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>苹果开源了部分 <code>CoreFoundation</code> 框架的源码，我们可以在 <a href="https://github.com/orgs/apple-oss-distributions/repositories?type=all">https://github.com/orgs/apple-oss-distributions/repositories?type=all</a> 中找到。下载好之后打开发现没有 Xcode 工程，我们自己新建一个 FrameWork 工程，将这些源文件拖进工程就可以在 Xcode 中查看源码了。CFRunLoop.h 和 CFRunLoop.m 文件就是我们需要阅读的源码文件。</p>
<h2 id="RunLoop-的几个核心对象"><a href="#RunLoop-的几个核心对象" class="headerlink" title="RunLoop 的几个核心对象"></a>RunLoop 的几个核心对象</h2><p>通过打印 <code>[NSRunLoop currentRunLoop]</code> 对象，可以看到很多信息。就是需要调整一下打印信息的缩进才能清晰的看到这些对象间的关系。RunLoop 对象存在多个 Mode，每个 Mode 中存在着一堆输入源，观察者，定时器。RunLoop 在运行的过程中，就是在一直不断的处理，执行这三种事情。RunLoop 提供了输入源，观察者，定时器，以及相关的 API 函数，让开发者，系统底层库，可以调用相关的 API 创建输入源，观察者，定时器并添加到 RunLoop 中，然后 RunLoop 循环处理这三件事情，当没有事情可做的时候，会让 CPU 进入休眠，不占用一点 CPU 资源。</p>
<p>通过 CFRunLoop.h 头文件，我们可以知道，RunLoop 里面重要的几个对象。分别是 <code>CFRunLoopRef</code>，<code>CFRunLoopSourceRef</code>，<code>CFRunLoopObserverRef</code>，<code>CFRunLoopTimerRef</code>。然后从 CFRunLoop.m 文件中，可以看到每个对象的底层结构体，并理清它们之间的关系。以下是 <code>CFRunLoopRef</code> 的结构体组成，只保留了一些重要的成员。通过 <code>CFMutableSetRef _modes</code> 可以得知一个 RunLoop 实例存在多个模式。常见的模式都有：</p>
<ul>
<li>kCFRunLoopDefaultMode：默认模式，处理主线程常规任务。</li>
<li>UITrackingRunLoopMode：滑动模式，处理 UI 滚动事件（如 UIScrollView 滑动时）。</li>
<li>kCFRunLoopCommonModes：通用模式，包含多个模式的集合（如 Default + Tracking）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">pthread_t</span> _pthread;</span><br><span class="line">	<span class="type">uint32_t</span> _winthread;</span><br><span class="line">	CFMutableSetRef _commonModes;</span><br><span class="line">	CFMutableSetRef _commonModeItems;</span><br><span class="line">	CFRunLoopModeRef _currentMode;</span><br><span class="line">	CFMutableSetRef _modes;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再查看 <code>CFRunLoopModeRef</code> 的结构体组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Source（输入源）"><a href="#Source（输入源）" class="headerlink" title="Source（输入源）"></a>Source（输入源）</h3><p>其中，每个模式都有 _sources0，_sources1 两个集合，中文译为输入源。咋一听会觉得很抽象，其实这些源中 source1 是系统创建并添加到 RunLoop 的，而应用层开发者只可以创建 source0 并添加到 RunLoop，或者通过间接的方法创建 source1 添加到 RunLoop。</p>
<h4 id="Source0（非基于端口的-Source）"><a href="#Source0（非基于端口的-Source）" class="headerlink" title="Source0（非基于端口的 Source）"></a>Source0（非基于端口的 Source）</h4><ul>
<li>角色：处理应用内部手动触发的事件。</li>
<li>触发方法：需要开发者主动标记为待处理（CFRunLoopSourceSignal），才会被 RunLoop 处理。</li>
<li>示例场景：<ul>
<li>performSelector:onThread: 方法的回调。</li>
<li>自定义事件的分发（如手动触发的异步任务）</li>
</ul>
</li>
</ul>
<h4 id="Source1（基于端口的-Source）"><a href="#Source1（基于端口的-Source）" class="headerlink" title="Source1（基于端口的 Source）"></a>Source1（基于端口的 Source）</h4><ul>
<li>角色：接收系统事件（如硬件事件、内核事件），并唤醒 RunLoop。</li>
<li>触发方式：由系统底层（如 Mach 端口）直接触发，优先级高。</li>
<li>实例场景：<ul>
<li>用户触摸屏幕（硬件事件）。</li>
<li>摇晃设备。</li>
<li>系统推送（如 NSURLConnection 的回调）。</li>
</ul>
</li>
</ul>
<h4 id="触摸事件的完整处理流程"><a href="#触摸事件的完整处理流程" class="headerlink" title="触摸事件的完整处理流程"></a>触摸事件的完整处理流程</h4><p>触摸事件的处理是由 Source1 和 Source0 协作完成的，具体流程如下：</p>
<h5 id="步骤1：Source1-接收事件（唤醒-RunLoop）"><a href="#步骤1：Source1-接收事件（唤醒-RunLoop）" class="headerlink" title="步骤1：Source1 接收事件（唤醒 RunLoop）"></a>步骤1：Source1 接收事件（唤醒 RunLoop）</h5><ul>
<li>当用户触摸屏幕时，系统底层（IOKit）生成一个硬件事件（如 IOHIDEvent）。</li>
<li>该事件通过 Mach 端口（系统级的进程间通信机制）传递给 SpringBoard（iOS 的桌面进程）。</li>
<li>SpringBoard 将事件转发给前台 App 的 主线程 RunLoop，并触发 Source1（__IOHIDEventSystemClient 端口事件）。</li>
<li>Source1 的作用：唤醒主线程 RunLoop，使其进入活动状态。</li>
</ul>
<h5 id="步骤2：Source0-处理事件（分发到应用层）"><a href="#步骤2：Source0-处理事件（分发到应用层）" class="headerlink" title="步骤2：Source0 处理事件（分发到应用层）"></a>步骤2：Source0 处理事件（分发到应用层）</h5><ul>
<li>RunLoop 被唤醒后，会处理当前 Mode 下的所有事件。额，其实就是继续往下执行后续的代码。。。</li>
<li>Source1 事件触发后，被调用 __IOHIDEventSystemClientQueueCallback() 函数，将事件包装成 UIEvent 对象。</li>
<li>此时，系统会将事件标记为待处理，并生成一个 Source0 事件（如 _UIApplicationHandleEventQueue）。</li>
<li>Source0 的作用：将事件分发给应用内部的 UIWindow、UIView 等组件，触发 touchesBegan:withEvent: 等回调方法</li>
</ul>
<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><p>硬件事件 -&gt; Source1（唤醒 RunLoop）-&gt; 转换为 Source0 事件 -&gt; Source0（分发到应用层）</p>
<ul>
<li>开发者接触到的是 Source0：应用层代码（如 touchesBegan:）是由 Source0 触发的，因此很多人误以为触摸事件时纯 Source0 处理的。</li>
<li>底层依赖 Source1：实际的事件接收和唤醒 RunLoop 的过程由 Source1 完成，但这一部分对应用层开发来说是未知的。</li>
</ul>
<h3 id="Observer（观察者）"><a href="#Observer（观察者）" class="headerlink" title="Observer（观察者）"></a>Observer（观察者）</h3><p>其次是 _observers 观察者数组，乍一听也觉得很抽象，其实这个观察者是 RunLoop 内部实现的一个通知机制，RunLoop 会在不同的阶段去通知观察者此时 RunLoop 的状态是什么。开发者可以自己创建观察者并加入到 RunLoop，就能够在 RunLoop 的不同阶段执行一些逻辑。iOS 底层就利用了 RunLoop 的观察者机制优化主线程的内存，在 RunLoop 的关键阶段（进入、休眠、退出）隐式管理自动释放池，减少手动干预。</p>
<ol>
<li>核心作用<ul>
<li>监听 RunLoop 的状态变化：例如 RunLoop 即将处理事件、即将休眠、即将退出等状态。</li>
<li>被动回调：Observer 本身不处理事件，仅用于监控 RunLoop 的声明周期。</li>
</ul>
</li>
<li>监听的状态 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">	kCFRunLoopEntry,         <span class="comment">// 即将进入 RunLoop</span></span><br><span class="line">	kCFRunLoopBeforeTimers,  <span class="comment">// 即将处理 Timer</span></span><br><span class="line">	kCFRunLoopBeforeSources, <span class="comment">// 即将处理 Source</span></span><br><span class="line">	kCFRunLoopBeforeWaiting, <span class="comment">// 即将休眠</span></span><br><span class="line">	kCFRunLoopAfterWaiting,  <span class="comment">// 从休眠中唤醒</span></span><br><span class="line">	kCFRunLoopExit           <span class="comment">// 即将退出 RunLoop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>使用场景<ul>
<li>性能监控：统计 RunLoop 的卡顿情况。</li>
<li>资源管理：在 RunLoop 休眠时释放资源（如 AutoreleasePool 的创建和释放）</li>
</ul>
</li>
<li>代码示例 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Observer 监听 RunLoop 状态</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(</span><br><span class="line">    kCFAllocatorDefault,</span><br><span class="line">    kCFRunLoopAllActivities, <span class="comment">// 监听所有状态</span></span><br><span class="line">    <span class="literal">YES</span>, <span class="number">0</span>,</span><br><span class="line">    ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="comment">// 根据 activity 处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Timer（定时器）"><a href="#Timer（定时器）" class="headerlink" title="Timer（定时器）"></a>Timer（定时器）</h3><p>最后是 _timers 数组，这个大家应该就很熟悉了，NSTimer 就是基于 RunLoop 实现的，平时创建 NSTimer 定时器都会加入到 RunLoop 就是添加到这个地方。</p>
<ol>
<li>核心作用<ul>
<li>处理时间相关的任务：在指定时间或周期触发回调。</li>
<li>基于时间的触发：与 RunLoop 的当前模式和时间有关。</li>
</ul>
</li>
<li>特点<ul>
<li>依赖 RunLoop 的执行。<ul>
<li>定时器的触发精度受 RunLoop 当前任务影响，主线程卡顿时，定时器执行可能不会准时。此时可以考虑使用 GCD 的定时器，它不依赖 RunLoop。</li>
<li>需要添加到 RunLoop 的某个 Mode 中才会生效。</li>
</ul>
</li>
<li>常见类型：<ul>
<li>NSTimer：Foundation 框架的定时器。</li>
<li>CADisplayLink：与屏幕刷新率同步的定时器（用于动画）。</li>
</ul>
</li>
</ul>
</li>
<li>使用场景<ul>
<li>轮询任务，如倒计时。</li>
<li>周期性 UI 更新，如动画。</li>
</ul>
</li>
<li>代码示例： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Timer 并添加到 RunLoop</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(tick) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="CFRunLoopRunInMode-关键流程分析"><a href="#CFRunLoopRunInMode-关键流程分析" class="headerlink" title="CFRunLoopRunInMode() 关键流程分析"></a>CFRunLoopRunInMode() 关键流程分析</h2><p>查看 CFRunLoopRunInMode() 的实现会发现其实内部只有一句函数调用代码。就是 CFRunLoopRunSpecific()，这个函数也不是真正 RunLoop 运行的核心，而是它内部的 __CFRunLoopRun() 函数。不过当前函数内也开始处理观察者了，所以也可以从这里开始分析。</p>
<p>我将主要的流程代码保留，细枝末节的代码都删掉了方便查看整体流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SInt32 <span class="title function_">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">	<span class="comment">// 通知所有观察者，将要进入 RunLoop</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">	<span class="comment">// RunLoop 的核心函数</span></span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    	<span class="comment">// 通知所有观察者，将要退出 RunLoop</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 通知所有观察者，RunLoop 将要处理 Timers</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">// 通知所有观察者，RunLoop 将要处理 Sources</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        <span class="comment">// 处理 RunLoop 的 Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        <span class="comment">// RunLoop 处理 Sources0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// 处理 RunLoop 的 Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断有没有 Sources1</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果有 Sources1 就跳到 handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知所有观察者，RunLoop 将要休眠</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        <span class="comment">// 等待别的消息来唤醒当前线程</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">// 通知所有观察者，RunLoop 结束休眠</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="comment">// 判断是怎么被唤醒的</span></span><br><span class="line">        <span class="keyword">if</span> (是被 timer 唤醒) &#123;</span><br><span class="line">		<span class="comment">// RunLoop 处理 Sources0</span></span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (是被 GCD 唤醒) &#123;</span><br><span class="line">            <span class="comment">// RunLoop 处理 GCD 的主队列</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 被 source1 唤醒</span></span><br><span class="line">            <span class="comment">// 处理 RunLoop 的 source1</span></span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理 RunLoop 的 Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        <span class="comment">// 设置返回值</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们看到调用非常频繁的一个函数是 <code>__CFRunLoopDoBlocks()</code> 处理 RunLoop 的 Blocks。它的主要意义是将 <code>CFRunLoopPerformBlock()</code> 创建的 Block 任务提交到指定 RunLoop 的特定模式下，在 RunLoop 的下一个循环中适时执行​​。这种机制允许开发者在 RunLoop 的不同阶段灵活调度任务，确保代码在正确的线程和时机执行，同时避免阻塞其他事件源。</p>
<h1 id="与-RunLoop-相关的应用场景"><a href="#与-RunLoop-相关的应用场景" class="headerlink" title="与 RunLoop 相关的应用场景"></a>与 RunLoop 相关的应用场景</h1><h2 id="解决滑动冲突"><a href="#解决滑动冲突" class="headerlink" title="解决滑动冲突"></a>解决滑动冲突</h2><p>相信很多 iOS 开发者都遇到过这个情况，在 UIScrollView（或者其子类）滚动的时候，NSTimer 定时器不执行了。默认的情况下，你创建的 NSTimer 定时器是加入到 RunLoop 的 kCFRunLoopDefaultMode 模式。而在你滑动 UIScrollView 的时候，此时 RunLoop 切换到了 UITrackingRunLoopMode，所以定时器不执行。解决办法是将 NSTimer 定时器加入 kCFRunLoopCommonModes 模式。</p>
<p>kCFRunLoopCommonModes 并不是一个单独的模式，它是一个标记。对于每一个单独的模式，它都可以被添加到 RunLoop 的 _commonModes 中，这是一个集合。当 Timer 添加到 RunLoop 的 kCFRunLoopCommonModes 模式之后，意味着 Timer 在 RunLoop 的 _commonModes 下的每个模式下都可以运行。</p>
<h2 id="子线程保活"><a href="#子线程保活" class="headerlink" title="子线程保活"></a>子线程保活</h2><h2 id="监控应用卡顿"><a href="#监控应用卡顿" class="headerlink" title="监控应用卡顿"></a>监控应用卡顿</h2><p>LXDAppFluecyMonitor</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h1 id="与自动释放池的关系"><a href="#与自动释放池的关系" class="headerlink" title="与自动释放池的关系"></a>与自动释放池的关系</h1>]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>dyld</title>
    <url>/2021/07/03/dyld/</url>
    <content><![CDATA[<p>+load 和 main() 谁先调用？有经验的 iOSer 们会毫不犹豫的回答出来是 load 方法，但为什么是 load 方法呢？今天我们来探讨一下底层的原理</p>
<p>新建一个项目，在 AppDelegate 里添加 load 方法，打上一个断点就会看到如下图所示的调用堆栈，如果觉得左侧太长了看不全，可以在控制台输入 bt 指令查看调用堆栈</p>
<img src="/2021/07/03/dyld/1420fddf811349b9b60ddc9bd748fea6~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>从调用堆栈中我们可以看到，程序由 dyld 的 <code>_dyld_start</code> 函数开始，一步一步的层层调用，最终到了我们 Demo 程序的 <code>[AppDelegate load]</code> 方法中。看上去这个 dyld 也是一个程序，就是这个 dyld 程序在启动我们的 APP</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>dyld（the dynamic link editor）是苹果的动态链接器，是苹果操作系统一个重要组成部分，在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。而且它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式，了解系统加载动态库的细节。</p>
<p>WWDC 从 2016，2017 到 2019 都有 session 对 APP 启动的过程以及如何优化做过介绍，直到 WWDC2019（iOS 13）才把 Dyld3 开放给所有 APP，在 iOS 13 系统中，iOS 将全面采用新的 dyld 3 以替代之前版本的 dyld 2。 因为 dyld 3 完全兼容 dyld 2，API 接口是一样的，所以在大部分情况下，开发者不需要做额外的适配就能平滑过渡。</p>
<p>现在网上大多数关于 dyld 的文章介绍都是基于 dyld2 版本的，虽然现在已经是 dyld3 版本了，但 dyld3 也并非是对 dyld2 的完全重构，dyld2 里的主要流程在 dyld3 里面依然存在，所以我这篇文章也会先介绍一下 dyld2 中的 9 个主要流程，最后再简单介绍一下 dyld3 做了哪些优化</p>
<blockquote>
<p>dyld 下载地址: <a href="http://opensource.apple.com/tarballs/dyld">http://opensource.apple.com/tarballs/dyld</a></p>
</blockquote>
<h1 id="从调用堆栈跟踪"><a href="#从调用堆栈跟踪" class="headerlink" title="从调用堆栈跟踪"></a>从调用堆栈跟踪</h1><p>我们先跟着刚刚的调用堆栈来跟踪一遍，首先打开我们刚刚下载的 dyld 源码，搜索我们刚刚在调用堆栈里看到的最外层的调用 <code>_dyld_start</code></p>
<h2 id="dyld-start"><a href="#dyld-start" class="headerlink" title="_dyld_start"></a><code>_dyld_start</code></h2><img src="/2021/07/03/dyld/051e727ace414ff19064d85d70b3b10c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>从截图中可以看到，搜索结果的第一部分和第二部分，都不可能是我们想要找的东西，第一部分 .xcconfig 像是配置文件，第二部分都是注释。那么肯定只有第三部分了，其实一开始看到这个第三部分 dyldStartup.s 文件内心是崩溃的…作为非科班 iOSer，虽然学过 C，Objective-C，Swift 也了解过一点点 C++，但是这个 .s 文件真不认识。</p>
<p>点开这个 .s 文件后，看到一堆指令，猜测应该是汇编代码了，这下头更大了，不过好在是汇编，估计大家都挺难懂的，所以苹果的注释给的也很到位，根据搜索结果综合注释来看，找到 arm64 架构并且不是模拟器的这部分也还算简单，然后看到 bl 指令上面有一段注释，跟我们刚刚调用堆栈里面的第 8 帧是一模一样的就能猜到个大概了… dyld 程序由 _dyld_start 开始，执行到这个 bl 指令后开始调用 start 函数了，那么接下来就是搜索这个 start 函数在哪了</p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h2><p>这个 start 一开始还不好搜，直接搜 start 会发现有 3125 个结果在 363 个文件里…作者表示看到这个结果头很大，于是想了个办法，我要找的是个函数的声明，那么后面必定紧跟着一个 ( 符号，重新搜索一番后发现好了很多，只有 173 个结果在 118 个文件了。头虽然没那么大了，但是这 173 个结果要一个个去找去看，也还是蛮费时间的…</p>
<p>最后灵机一动，尝试在 start( 前面加一个空格，好家伙，这不就出现了么，结合一下注释，还有函数的参数和调用堆栈第 8 帧里一模一样的就确定了。如果是有 C++ 基础的同学应该就更加好找了 dyldbootstrap 是命名空间直接搜就会找到一份文件，再在该文件里搜 start( 很快就找到了</p>
<img src="/2021/07/03/dyld/f69304e2e88b4c6bbc838ffb2a608f7b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>函数的 return 的前面一行有一个 appsSlide 变量，这个变量是 <a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%8A%A0%E8%BD%BD/22785938?fromtitle=aslr&fromid=5779647&fr=aladdin">ASLR地址空间配置随机加载技术</a> 的应用，这是是一种防范内存损坏漏洞被利用的计算机安全技术</p>
<p>这个 start 函数里面的最后一行代码调用了 _main() 函数，这个比较舒服，不需要我们再去找了，直接按住 command 然后左键点击就可以跳转到对应的实现代码了</p>
<h2 id="main"><a href="#main" class="headerlink" title="_main"></a><code>_main</code></h2><p>这个 _main 函数就是启动我们 APP 的关键代码，从它的行数就可以看出来它的分量了，从 6455 行到 7303 一共 848 行，这里就不贴它的全部源码了。好家伙，还是头一回看到一个 C 函数写这么长的，本来是想吐槽一下的，但一想到这是苹果的工程师写的底层代码，咱还是老老实实看源码…这部分的代码就是今天重点中的重点，我们在下一部分重点讲这个函数，现在还是接着调用堆栈继续往后面走，后面的几个都挺好找的</p>
<img src="/2021/07/03/dyld/9a90f02335cd433ea34f376b99bd66d5~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="initializeMainExecutable"><a href="#initializeMainExecutable" class="headerlink" title="initializeMainExecutable"></a><code>initializeMainExecutable</code></h2><p>这个 <code>initializeMainExecutable</code> 函数在 <code>_main</code> 里面调用了两次，不过是分不同架构的，也是可以直接 command 加左键定位到函数实现的，从这个函数里的注释中可以看到，是先执行的所有插入的库的 initialzers 方法，再执行我们主程序的 initialzers 方法的，这也说明了我们写的 Framework 中的 load 方法会比我们主程序的 load 方法先执行。如果不认为 run initialzers 就是调用 load 方法，可以跟着调用堆栈流程走完，你就会知道到底是不是了</p>
<img src="/2021/07/03/dyld/7fc66470098d4d63b83d854943cea695~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="runInitializers"><a href="#runInitializers" class="headerlink" title="runInitializers"></a><code>runInitializers</code></h2><p>这个 <code>runInitializers</code> 函数也是在上面 <code>initializeMainExecutable</code> 函数里面调用了两次，从两次调用的注释来看，上面调用的是所有插入的动态库的初始化方法，而下面的才是我们主程序调用初始化方法，所以在 <code>[AppDelegate laod]</code> 方法中打的断点卡住的应该是下面的这段代码。这个函数也比较好找，直接搜 runInitializers( 只有 12 个结果在 5 个文件里，再结合它前面的 ImageLoader 作用域，函数的参数，很快就能找到它的实现</p>
<img src="/2021/07/03/dyld/adb2af8014704d869a6d19cc6c84dfaf~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="processInitializers"><a href="#processInitializers" class="headerlink" title="processInitializers"></a><code>processInitializers</code></h2><p>结合调用堆栈，找到 <code>runInitializers</code> 里面的 <code>processInitializers</code> 函数实现很容易，找到 <code>processInitializers</code> 函数的实现也很简单，可以直接 command 加左键点击就到了</p>
<img src="/2021/07/03/dyld/da2827f797624610bd4930ccea6f60ab~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="recursiveInitialization"><a href="#recursiveInitialization" class="headerlink" title="recursiveInitialization"></a><code>recursiveInitialization</code></h2><p>同样是在 ImageLoader.cpp 文件内，<code>processInitializers</code> 就能直接 command 加左键定位到实现代码，而 <code>recursiveInitialization</code> 却不可以，不知道为什么，不过也没什么大问题，<code>recursiveInitialization</code> 在当前文件一搜就找到实现了</p>
<img src="/2021/07/03/dyld/f6e7774217474a9d83ecd61b8e8afbc0~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这里有个小细节可以说一下，在第一次 content.notifySingle() 之后有一个 <code>doInitialization</code> 函数，这个函数里面又会有两个初始化函数</p>
<img src="/2021/07/03/dyld/67c86992c90846bea57c7f96ca77ea49~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p><code>doInitialization()</code> 内部首先调用 <code>doImageInit</code> 来执行镜像的初始化函数，也就是 LC_ROUTINES_COMMAND 中记录的函数。</p>
<p>再执行 <code>doModInitFunctions()</code> 方法来解析并执行 <code>_DATA_,__mod_init_func</code> 这个 section 中保存的函数。使用 <code>__attribute__((constructor))</code> 开头的 C 函数会保存在这里面，如图所示：</p>
<img src="/2021/07/03/dyld/c1a0573d34044b52a7d3c579dd038820~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="notifySingle"><a href="#notifySingle" class="headerlink" title="notifySingle"></a><code>notifySingle</code></h2><p><code>notifySingle</code> 的调用同样是在上一个函数 <code>recursiveInitialization</code> 的实现里面，但是 <code>notifySingle</code> 的实现结合调用堆栈它前面的作用域来看，不在 ImageLoader 里面，那就直接全局搜索 notifySingle( 也比较容易找</p>
<img src="/2021/07/03/dyld/f25e78d7b1754037aae4f5e1e7fc6464~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>接下来，由 <code>notifySingle</code> 到 <code>load_images</code> 会发现调用的地方已经不是在 dyld 了…那么如何实现代码的执行从一个程序跳到另一个程序呢？有很多种办法，通知，代理，block，函数指针，函数作为参数传递，我们仔细观察一下 <code>notifySingle</code> 里面有没有以上任何一种，会发现下面这里有一个不太一样的地方 <code>sNotifyObjCInit</code></p>
<img src="/2021/07/03/dyld/1115d0caecde4823af5b87bea6f178c4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>那接下来就看看这个 <code>sNotifyObjCInit</code> 变量是在哪里被赋值的，搜索一番后发现在这里被赋值了</p>
<img src="/2021/07/03/dyld/0293dbb581f249b19486b8d88591b612~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>紧接着搜一搜这个 <code>registerObjCNotifiers</code> 在哪里被调用了</p>
<img src="/2021/07/03/dyld/4df21bcb4168413499a5b81f87593576~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>搜索一番后发现这里是 dyld 提供的对外部的接口…那就说明我们在 dyld 里面应该是找不到这个调用的地方了，不过至少我们找到了这个对外的接口函数<code>_dyld_objc_notify_register</code>，这个时候，我们可以回到最开始新建的项目中去，下一个 <code>_dyld_objc_notify_register</code> 的符号断点</p>
<img src="/2021/07/03/dyld/78f0a0ea1d354c4da36e496c6c93693c~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>会发现是 libobjc.A.dylib 的 <code>_objc_init</code> 里面调用了我们的 <code>_dyld_objc_notify_register</code> 函数，这个 libobjc.A.dylib 我们不是头一回看到了，前面的调用堆栈第 1 帧也是在 libobjc.A.dylib 的 <code>load_images</code> 函数，那么这个 libobjc.A.dylib 到底是什么库呢？其实这个 libobjc.A.dylib 就是我们的 Objective-C 的运行时库，好消息是这个库苹果依旧开源了出来，可以免费供大家学习，我这里下载的是 objc4-818.2</p>
<blockquote>
<p>Objective-C 运行时库下载：<a href="https://opensource.apple.com/tarballs/objc4/">https://opensource.apple.com/tarballs/objc4/</a></p>
</blockquote>
<p>打开下载的 objc4 源码，找到 Products 目录，是不是可以看到一个非常眼熟的东西</p>
<img src="/2021/07/03/dyld/a2e91efa69344f76b6664f91237b83da~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这样看来我们真的找对地方了,那就直接全局搜索我们刚刚获取到的 <code>_dyld_objc_notify_register</code> 函数，看看是不是 <code>_objc_init</code> 里面调用了它</p>
<img src="/2021/07/03/dyld/a83f47bc48f747098fca1256107843ff~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>果然如此，看到这里，就会发现 dyld 里面的 <code>sNotifyObjCInit</code> 变量是被赋值了一个 <code>load_images</code> 的函数，到这里就完全能解释的通，从调用堆栈的第 2 帧到第 1 帧的执行了，这个 <code>load_images</code> 可以直接按住 command 点击定位到实现代码</p>
<h2 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a><code>load_images</code></h2><p>接下来就是看怎么从 libobjc.A.dylib 的 load_images 函数到我们的断点 <code>[AppDelegate load]</code> 方法的了</p>
<img src="/2021/07/03/dyld/51a2644170cb4f8e83ea396dac87c2e7~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>很明显，我们需要查看 <code>call_load_methods</code> 函数</p>
<img src="/2021/07/03/dyld/e57d017606c54302a327bff8079b824b~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在这个函数里，我们就可以明显的看到先是调用所有类的 load 方法，然后再调用所有分类中的 load 方法，查看 <code>call_class_loads</code> 的实现</p>
<img src="/2021/07/03/dyld/28ba5a526e7e43c7968768b14e3ad213~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>到这里，我们断点卡住的所有调用堆栈就全部跟踪完毕了</p>
<p>需要了解的是，这个时候我们依然还在 dyld 的 <code>_main</code> 函数里面，连 <code>_main</code> 里面的 <code>initializeMainExecutable</code> 都没有执行完…而我们主程序的 <code>main()</code> 是在什么时候调用的呢？</p>
<p>dyld 的 <code>_main</code> 函数的返回值 result 就是我们主程序的入口，<code>_main</code> 执行完毕之后，会把返回值返回到 <code>start</code> 函数，<code>start</code> 函数又会把返回值返回到我们的最初的入口 <code>_dyld_start</code> 里面的那条 <code>bl</code> 指令后，<code>x0</code> 就是返回的我们主程序入口，接下来一个 <code>mov x16,x0</code> 看注释也知道是将主程序入口地址保存到 <code>x16</code> 寄存器了，再搜索一下 <code>x16</code> 发现后面基本都是各种情况下的 <code>br</code> 或者 <code>braaz</code> 到 <code>x16</code>，就是跳转到我们的主程序了，所以我们 APP 的 main 函数远远晚于 load 方法的调用</p>
<h1 id="dyld-的-main"><a href="#dyld-的-main" class="headerlink" title="dyld 的 _main"></a>dyld 的 _main</h1><p>上面调用堆栈里这么多函数里面，最复杂最长的就是这个 <code>_main</code> 了，其实这个函数里面才是 dyld 启动我们 APP 的主要流程，但是这个函数实在太长了，我们将这个函数分成 9 个主要的部分，我向来讨厌在文章里面贴那种几页几页都翻不完的代码块的，所以下面的介绍都尽量精简</p>
<h2 id="1-获取当前程序架构-设置上下文信息"><a href="#1-获取当前程序架构-设置上下文信息" class="headerlink" title="1.获取当前程序架构,设置上下文信息"></a>1.获取当前程序架构,设置上下文信息</h2><p><code>getHostInfo()</code> 获取当前程序架构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getHostInfo</span>(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure>

<p>接着调用 <code>setContext()</code> 设置上下文信息，包括一些回调函数、参数、标志信息等。设置的回调函数都是 dyld 模块自身实现的，如 <code>loadLibrary()</code> 函数实际调用的是 <code>libraryLocator()</code>，负责加载动态库。代码片断如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setContext</span><span class="params">(<span class="type">const</span> macho_header* mainExecutableMH, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[], <span class="type">const</span> <span class="type">char</span>* envp[], <span class="type">const</span> <span class="type">char</span>* apple[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gLinkContext.loadLibrary			= &amp;libraryLocator;</span><br><span class="line">        gLinkContext.terminationRecorder	        = &amp;terminationRecorder;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>

<h2 id="2-配置进程是否受限，检查环境变量"><a href="#2-配置进程是否受限，检查环境变量" class="headerlink" title="2.配置进程是否受限，检查环境变量"></a>2.配置进程是否受限，检查环境变量</h2><p><code>configureProcessRestrictions()</code> 用来配置进程是否受限<br><br><code>checkEnvironmentVariables()</code> 检查环境变量<br></p>
<p>细心的读者可能会注意到，整个过程中有一些 <code>DYLD_PRINT_</code> 开头的环境变量，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">	<span class="built_in">printOptions</span>(argv);</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">	<span class="built_in">printEnvironmentVariables</span>(envp);</span><br></pre></td></tr></table></figure>

<p>如果在 Xcode 中配置了这些环境变量，就会在我们的控制台中打印相关的信息。<br>除了上面的两个外，我下面以另外一个打印启动时间的环境变量 <code>DYLD_PRINT_STATISTICS_DETAILS</code> 为例，这个应该可以作为优化启动时间的参考数据</p>
<img src="/2021/07/03/dyld/31abb20a080747f6b1569a288ab79cf4~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<img src="/2021/07/03/dyld/fc7223b2f1054db6ae04bb167b585b2d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="3-加载共享缓存"><a href="#3-加载共享缓存" class="headerlink" title="3.加载共享缓存"></a>3.加载共享缓存</h2><p>这里先说明一下，iOS 的共享缓存机制：在 iOS 系统中，每个程序依赖的动态库都需要通过 dyld 一个个加载到内存。然而，很多系统库基本上是每个程序都会用到的，比如 UIKit，Foundation。如果每个程序启动运行的时候都重复的去加载一次，势必会造成运行缓慢，不必要的内存消耗，为了优化启动速度和节约内存消耗，共享缓存机制就出现了。</p>
<p>这里还要说明一下，在 iOS 中，只有苹果内部或拥有特殊权限的开发者才有能力在系统级别创建和分发真正的动态库，普通 iOS 开发者并不能自由开发和分发真正意义上的动态库，动态框架（Framework）也只能在我们自己的 APP 中使用，无法在多个应用间共享。苹果通过严格的权限控制、沙盒机制和审核流程，确保 iOS 平台的安全和稳定性。</p>
<p>所有 iOS 系统的动态库被合并成一个大的缓存文件，放在 <code>/System/Library/Caches/com.apple.dyld/</code> 目录下，按不同的架构分别保存，想要分析某个系统库，可以从 dyld_shared_cache 里将原始的二进制文件提取出来。感兴趣的可以根据我的第一篇参考文章上的步骤去尝试一下</p>
<p>这一步先调用 <code>checkSharedRegionDisable()</code> 检查共享缓存是否禁用。该函数的 iOS 实现部分仅有一句注释，从注释我们可以推断 iOS 必须开启共享缓存才能正常工作，代码如下：</p>
<img src="/2021/07/03/dyld/0f1c451c693646829f42717b26f33367~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>接下来调用 <code>mapSharedCache()</code> 加载共享缓存，而 <code>mapSharedCache()</code> 里面实则是调用了 <code>loadDyldCache()</code>，从代码可以看出，共享缓存加载又分为三种情况：</p>
<ul>
<li>仅加载到当前进程，调用 <code>mapCachePrivate()</code>。</li>
<li>共享缓存已加载，不做任何处理。</li>
<li>当前进程首次加载共享缓存，调用 <code>mapCacheSystemWide()</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="type">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="comment">// simulator only supports mmap()ing cache privately into process</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mapCachePrivate</span>(options, results);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mapCachePrivate</span>(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fast path: when cache is already mapped into shared region</span></span><br><span class="line">        <span class="type">bool</span> hasError = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">reuseExistingCache</span>(options, results) ) &#123;</span><br><span class="line">            hasError = (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// slow path: this is first process to load cache</span></span><br><span class="line">            hasError = <span class="built_in">mapCacheSystemWide</span>(options, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasError;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapCachePrivate()</code>、<code>mapCacheSystemWide()</code> 里面就是具体的共享缓存解析逻辑，感兴趣的读者可以详细分析。</p>
<h2 id="4-为主程序实例化-ImageLoader"><a href="#4-为主程序实例化-ImageLoader" class="headerlink" title="4.为主程序实例化 ImageLoader"></a>4.为主程序实例化 ImageLoader</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sMainExecutable = <span class="built_in">instantiateFromLoadedImage</span>(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br></pre></td></tr></table></figure>

<p>分析一下函数的名称以及参数，从已加载的镜像实例化，因为传入的是我们的主程序的 MachO 头，主程序 Slide 和路径，所以实例化出来的就是我们的主程序，代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="type">const</span> macho_header* mh, <span class="type">uintptr_t</span> slide, <span class="type">const</span> <span class="type">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ImageLoader* image = ImageLoaderMachO::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class="line">	<span class="built_in">addImage</span>(image);</span><br><span class="line">	<span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageLoaderMachO::instantiateMainExecutable()</code> 函数里面首先会调用 <code>sniffLoadCommands()</code> 函数来获取一些数据，包括：</p>
<ul>
<li><code>compressed</code> 如果若 Mach-O 存在 LC_DYLD_INFO 和 LC_DYLD_INFO_ONLY 加载命令或 LC_DYLD_CHAINED_FIXUPS 加载命令，则说明是压缩类型的 Mach-O，代码片段如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> LC_DYLD_INFO:</span><br><span class="line">        <span class="keyword">case</span> LC_DYLD_INFO_ONLY:</span><br><span class="line">                <span class="keyword">if</span> ( cmd-&gt;cmdsize != <span class="built_in">sizeof</span>(dyld_info_command) )</span><br><span class="line">                        <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: LC_DYLD_INFO size wrong&quot;</span>;</span><br><span class="line">                dyldInfoCmd = (<span class="keyword">struct</span> dyld_info_command*)cmd;</span><br><span class="line">                *compressed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LC_DYLD_CHAINED_FIXUPS:</span><br><span class="line">                <span class="keyword">if</span> ( cmd-&gt;cmdsize != <span class="built_in">sizeof</span>(linkedit_data_command) )</span><br><span class="line">                        <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: LC_DYLD_CHAINED_FIXUPS size wrong&quot;</span>;</span><br><span class="line">                chainedFixupsCmd = (<span class="keyword">struct</span> linkedit_data_command*)cmd;</span><br><span class="line">                *compressed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>segCount</code> 根据 <code>LC_SEGMENT_COMMAND</code> 加载命令来统计段数量，这里抛出的错误日志也说明了段的数量是不能超过 255 个，代码片段如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *segCount &gt; <span class="number">255</span> )</span><br><span class="line">        dyld::<span class="built_in">throwf</span>(<span class="string">&quot;malformed mach-o image: more than 255 segments in %s&quot;</span>, path);</span><br></pre></td></tr></table></figure></li>
<li><code>libCount</code> 根据 <code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>、<code>LC_REEXPORT_DYLIB</code>、<code>LC_LOAD_UPWARD_DYLIB</code> 这几个加载命令来统计库的数量，库的数量不能超过 4095 个。代码片段如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LC_LOAD_DYLIB:</span><br><span class="line"><span class="keyword">case</span> LC_LOAD_WEAK_DYLIB:</span><br><span class="line"><span class="keyword">case</span> LC_REEXPORT_DYLIB:</span><br><span class="line"><span class="keyword">case</span> LC_LOAD_UPWARD_DYLIB:</span><br><span class="line">        *libCount += <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ( *libCount &gt; <span class="number">4095</span> )</span><br><span class="line">        dyld::<span class="built_in">throwf</span>(<span class="string">&quot;malformed mach-o image: more than 4095 dependent libraries in %s&quot;</span>, path);</span><br></pre></td></tr></table></figure></li>
<li><code>codeSigCmd</code> 通过解析 LC_CODE_SIGNATURE 来获取代码签名加载命令，代码片段如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">        <span class="keyword">if</span> ( cmd-&gt;cmdsize != <span class="built_in">sizeof</span>(linkedit_data_command) )</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: LC_CODE_SIGNATURE size wrong&quot;</span>;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/22799652&gt; only support one LC_CODE_SIGNATURE per image</span></span><br><span class="line">        <span class="keyword">if</span> ( *codeSigCmd != <span class="literal">NULL</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: multiple LC_CODE_SIGNATURE load commands&quot;</span>;</span><br><span class="line">        *codeSigCmd = (<span class="keyword">struct</span> linkedit_data_command*)cmd;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>encryptCmd</code> 通过 LC_ENCRYPTION_INFO 和 LC_ENCRYPTION_INFO_64 来获取段的加密信息，代码片段如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">        <span class="keyword">if</span> ( cmd-&gt;cmdsize != <span class="built_in">sizeof</span>(encryption_info_command) )</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: LC_ENCRYPTION_INFO size wrong&quot;</span>;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/22799652&gt; only support one LC_ENCRYPTION_INFO per image</span></span><br><span class="line">        <span class="keyword">if</span> ( *encryptCmd != <span class="literal">NULL</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: multiple LC_ENCRYPTION_INFO load commands&quot;</span>;</span><br><span class="line">        *encryptCmd = (encryption_info_command*)cmd;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">        <span class="keyword">if</span> ( cmd-&gt;cmdsize != <span class="built_in">sizeof</span>(encryption_info_command_64) )</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: LC_ENCRYPTION_INFO_64 size wrong&quot;</span>;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/22799652&gt; only support one LC_ENCRYPTION_INFO_64 per image</span></span><br><span class="line">        <span class="keyword">if</span> ( *encryptCmd != <span class="literal">NULL</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;malformed mach-o image: multiple LC_ENCRYPTION_INFO_64 load commands&quot;</span>;</span><br><span class="line">        *encryptCmd = (encryption_info_command*)cmd;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
  <code>ImageLoader</code> 是抽象类，其子类负责把 Mach-O 文件实例化为 image，当 <code>sniffLoadCommands()</code>解析完以后，根据 <code>compressed</code> 的值来决定调用哪个子类进行实例化，代码如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">ImageLoaderMachO::instantiateMainExecutable</span><span class="params">(<span class="type">const</span> macho_header* mh, <span class="type">uintptr_t</span> slide, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">bool</span> compressed;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> segCount;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> libCount;</span><br><span class="line">        <span class="type">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">        <span class="type">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">        <span class="built_in">sniffLoadCommands</span>(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line">        <span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line">        <span class="keyword">if</span> ( compressed ) </span><br><span class="line">                <span class="keyword">return</span> ImageLoaderMachOCompressed::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, segCount, libCount, context);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span></span><br><span class="line">                <span class="keyword">return</span> ImageLoaderMachOClassic::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;missing LC_DYLD_INFO load command&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在完成实例化之后，将返回的 image 加入到 sAllImages 加入到全局镜像列表，并将 image 映射到申请的内存中。至此，初始化主程序这一步就完成了</p>
<h2 id="5-加载所有插入的库"><a href="#5-加载所有插入的库" class="headerlink" title="5.加载所有插入的库"></a>5.加载所有插入的库</h2><p>这一步是加载环境变量 DYLD_INSERT_LIBRARIES 中配置的动态库，先判断环境变量 DYLD_INSERT_LIBRARIES 中是否存在要加载的动态库，如果存在则调用 <code>loadInsertedDylib()</code> 依次加载，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">                <span class="built_in">loadInsertedDylib</span>(*lib);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-链接主程序"><a href="#6-链接主程序" class="headerlink" title="6.链接主程序"></a>6.链接主程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>这一步调用 <code>link()</code> 函数将实例化后的主程序进行动态修正，让二进制变为可正常执行的状态。<code>link()</code> 函数内部调用了 <code>ImageLoader::link()</code> 函数，从源代码可以看到，这一步主要做了以下几个事情:</p>
<ul>
<li><code>recursiveLoadLibraries()</code> 根据 LC_LOAD_DYLIB 加载命令把所有依赖库加载进内存。</li>
<li><code>recursiveUpdateDepth()</code> 递归刷新依赖库的层级。</li>
<li><code>recursiveRebase()</code> 由于 ASLR 的存在，必须递归对主程序以及依赖库进行重定位操作。</li>
<li><code>recursiveBind()</code> 把主程序二进制和依赖进来的动态库全部执行符号表绑定。</li>
<li><code>weakBind()</code> 如果链接的不是主程序二进制的话，会在此时执行弱符号绑定，主程序二进制则在 <code>link()</code> 完后再执行弱符号绑定，后面会进行分析。</li>
<li><code>recursiveGetDOFSections()</code>、<code>context.registerDOFs()</code> 注册 DOF（DTrace Object Format）节。</li>
</ul>
<h2 id="7-链接所有插入的库"><a href="#7-链接所有插入的库" class="headerlink" title="7.链接所有插入的库"></a>7.链接所有插入的库</h2><p>这一步与链接主程序一样，将前面调用 <code>addImage()</code> 函数保存在 sAllImages 中的动态库列表循环取出并调用 link() 进行链接，需要注意的是，sAllImages 中保存的第一项是主程序的镜像，所以要从 i+1 的位置开始，取到的才是动态库的 ImageLoader：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">                ImageLoader* image = sAllImages[i<span class="number">+1</span>];</span><br><span class="line">                <span class="built_in">link</span>(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">                image-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( gLinkContext.allowInterposing ) &#123;</span><br><span class="line">                <span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">                <span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">                        ImageLoader* image = sAllImages[i<span class="number">+1</span>];</span><br><span class="line">                        image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-执行初始化方法initializeMainExecutable"><a href="#8-执行初始化方法initializeMainExecutable" class="headerlink" title="8.执行初始化方法initializeMainExecutable"></a>8.执行初始化方法<code>initializeMainExecutable</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">initializeMainExecutable</span>(); </span><br></pre></td></tr></table></figure>

<p>这个函数在我们刚刚的调用堆栈流程跟踪里面讲到过，我们 Objective-C 对象的 load 方法，库中的 load 方法，还有 C++ 的初始化方法都在这里面被执行了</p>
<h2 id="9-查找主程序入口并返回"><a href="#9-查找主程序入口并返回" class="headerlink" title="9.查找主程序入口并返回"></a>9.查找主程序入口并返回</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">result = (<span class="type">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br><span class="line"><span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span></span><br><span class="line">        <span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">                *startGlue = (<span class="type">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">halt</span>(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">        result = (<span class="type">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_UNIXTHREAD</span>();</span><br><span class="line">        *startGlue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>getEntryFromLC_MAIN()</code> 从 Load Command 读取 LC_MAIN 入口。如果没有 LC_MAIN 入口，就读取 LC_UNIXTHREAD()，然后返回给 <code>start</code> 函数，再返回到 <code>_dyld_start</code> 走完剩下的汇编代码，可以看到最后的汇编代码跳转到了我们程序的入口 <code>jump to the program&#39;s entry point</code></p>
<h1 id="dyld2-和-dyld3"><a href="#dyld2-和-dyld3" class="headerlink" title="dyld2 和 dyld3"></a>dyld2 和 dyld3</h1><p>在 iOS 13 之前，所有的第三方 App 都是通过 dyld 2 来启动 App 的，主要过程就是上面所讲的 9 大步骤</p>
<blockquote>
<p>上面的所有过程都发生在 App 启动时，包含了大量的计算和 I&#x2F;O，所以苹果开发团队为了加快启动速度，在 <a href="https://developer.apple.com/videos/play/wwdc2017/413/">WWDC2017 - 413 - App Startup Time: Past, Present, and Future</a>  上正式提出了 dyld3。</p>
</blockquote>
<p>dyld 3 并不是 WWDC19 推出来的新技术，早在 2017 年就被引入至 iOS 11，当时主要用来优化系统库。现在，在 iOS 13 中它也将用于启动第三方 APP。dyld 3 最大的特点就是部分是进程外的且有缓存的，在打开 APP 时，实际上已经有不少工作都完成了。</p>
<h2 id="dyld3-包含三个组件"><a href="#dyld3-包含三个组件" class="headerlink" title="dyld3 包含三个组件"></a>dyld3 包含三个组件</h2><h3 id="本-APP-进程外的-Mach-O-分析器-编译器；"><a href="#本-APP-进程外的-Mach-O-分析器-编译器；" class="headerlink" title="本 APP 进程外的 Mach-O 分析器&#x2F;编译器；"></a>本 APP 进程外的 Mach-O 分析器&#x2F;编译器；</h3><p>在 dyld2 的加载流程中，Parse mach-o headers 和 Find Dependencies 存在安全风险（可以通过修改 mach-o header 及添加非法 @rpath 进行攻击），而 Perform symbol lookups 会耗费较多的 CPU 时间，因为一个库文件不变时，符号将始终位于库中相同的偏移位置，这两部分在 dyld3 中将采用提前写入把结果数据缓存成文件的方式构成一个 “lauch closure“（可以理解为缓存文件）</p>
<p>它处理了所有可能影响启动速度的 search path，@rpaths 和环境变量。它解析 mach-o 二进制文件，分析其依赖的动态库，并且完成了所有符号查找的工作。最后它将这些工作的结果创建成了启动闭包，写入缓存，这样，在应用启动的时候，就可以直接从缓存中读取数据，加快加载速度。</p>
<p>这是一个普通的 daemon 进程，可以使用通常的测试架构。</p>
<p>out-of-process 是一个普通的后台守护程序，因为从各个 APP 进程抽离出来了，可以提高 dyld3 的可测试性。</p>
<h3 id="本进程内执行”lauch-closure“的引擎；"><a href="#本进程内执行”lauch-closure“的引擎；" class="headerlink" title="本进程内执行”lauch closure“的引擎；"></a>本进程内执行”lauch closure“的引擎；</h3><p>验证 ”lauch closures“ 是否正确，把 dylib 映射到 APP 进程的地址空间里，然后跳转到 main 函数。此时，它不再需要分析 mach-o header 和执行符号查找，节省了不少时间。</p>
<h3 id="”lauch-closure“的缓存："><a href="#”lauch-closure“的缓存：" class="headerlink" title="”lauch closure“的缓存："></a>”lauch closure“的缓存：</h3><p>iOS 操作系统内置 APP 的 ”lauch closure“ 直接内置在 shared cache 共享缓存中，我们甚至不需要打开一个单独的文件。而对于第三方 APP，将在 APP 安装或更新版本时（或者操作系统升级时？）生成 lauch closure 启动闭包，因为那时候的系统库已经发生更改。这样就能保证 ”lauch closure“ 总是在 APP 打开之前准备好。启动闭包会被写到到一个文件里，下次启动则直接读取和验证这个文件。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>dyld3 把很多耗时的查找、计算和 I&#x2F;O 的事前都预先处理好了，这使得启动速度有了很大的提升。dyld3 在 <code>_main</code> 函数里面和 dyld2 最大的不同之处在于，在 dyld2 的第三步和第四步之间，插入了使用 Closure 启动的逻辑。在最新的 dyld 源码里面可以看到，在第三步加载共享缓存之后，会判断 <code>sClosureMode</code> 模式，并尝试通过 Closure 的方式启动，如果启动成功了就直接 return 了，后面的代码就不执行了，当然 <code>launchWithClosure()</code> 里面会有 dyld3 的新处理逻辑，感兴趣的同学可以自行前往查看源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( sClosureMode == ClosureMode::Off ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( gLinkContext.verboseWarnings )</span><br><span class="line">                dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: not using closures\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// try using launch closure</span></span><br><span class="line">        <span class="keyword">if</span> ( mainClosure != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="type">bool</span> launched = <span class="built_in">launchWithClosure</span>(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH,</span><br><span class="line">                                                                              mainExecutableSlide, argc, argv, envp, apple, diag, &amp;result, startGlue, &amp;closureOutOfDate, &amp;recoverable);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ( launched ) &#123;</span><br><span class="line">            gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (sSkipMain)</span><br><span class="line">                    result = (<span class="type">uintptr_t</span>)&amp;fake_main;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，dyld3 把很多耗时的操作都提前处理好了，极大提升了启动速度。了解 dyld 对 APP 的启动过程有一个更全面的认识，对 APP 的安全防护，注入手段，启动速度的优化都需要对 dyld 有深入的理解。</p>
<p>这篇文章主要参考了以下几篇文章：</p>
<ul>
<li><a href="https://www.dllhook.com/post/238.html#toc_6">dyld详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/DOzUcmfKdwq9RL-u3uYczA">iOS 启动时间与Dyld3</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24875905">dylib动态库加载过程分析</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>dyld</tag>
        <tag>load</tag>
        <tag>initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O</title>
    <url>/2021/06/28/Mach-O/</url>
    <content><![CDATA[<h1 id="通用二进制-Universal-binary-文件"><a href="#通用二进制-Universal-binary-文件" class="headerlink" title="通用二进制(Universal binary)文件"></a>通用二进制(Universal binary)文件</h1><p>macOS 系统一路走来，支持的 CPU 及硬件平台都有了很大的变化，从早期的 PowerPC 平台，到后来的 x86，再到现在主流的 arm、x86-64 平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐的。</p>
<p>为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）。又称为胖二进制（Fat Binary），通用二进制文件中将多个支持不同 CPU 架构的二进制文件打包成一个文件，系统在加载运行该程序时，会根据通用二进制文件中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<p>有人或许会好奇，不是讲 Mach-O 文件吗?怎么开始讲通用二进制文件，不要着急，看下面 <code>file</code> 命令查看 dyld 的打印，universal binary 前面不就是 Mach-O 吗</p>
<p>苹果自家系统中存在着很多通用二进制文件。比如 &#x2F;usr&#x2F;lib&#x2F;dyld，在终端中执行 <code>file</code> 命令可以查看它的信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ file /usr/lib/dyld</span><br><span class="line">/usr/lib/dyld： Mach-O universal binary with 3 architectures： [i386：Mach-O dynamic linker i386] [x86_64：Mach-O 64-bit dynamic linker x86_64] [arm64e]</span><br><span class="line">/usr/lib/dyld (<span class="keyword">for</span> architecture i386)：	Mach-O dynamic linker i386</span><br><span class="line">/usr/lib/dyld (<span class="keyword">for</span> architecture x86_64)：	Mach-O 64-bit dynamic linker x86_64</span><br><span class="line">/usr/lib/dyld (<span class="keyword">for</span> architecture arm64e)：	Mach-O 64-bit dynamic linker arm64e</span><br></pre></td></tr></table></figure>

<p>我们创建一个名为 test 的 iOS 工程，然后在 Xcode 中通过设置 Build Settings 中的 Architectures 来生成兼容各种架构的 APP</p>
<img src="/2021/06/28/Mach-O/84375053987242bda5a6f2207abf73f7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>编译之后，使用 <code>file</code> 命令查看生成的 ipa 包里的可执行文件</p>
<img src="/2021/06/28/Mach-O/6d1f4577c2fb4a3fa7b2266f44a20a08~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h2 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a>lipo</h2><p>系统提供了一个命令行工具<code>lipo</code>来操作通用二进制文件。它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。</p>
<p>查看通用二进制文件信息： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo -info <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>提取 test 中 armv7 版本的二进制文件可以执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo <span class="built_in">test</span> -extract armv7 -output test_armv7</span><br></pre></td></tr></table></figure>

<p>提取 test 中 arm64 版本的二进制文件可以执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo <span class="built_in">test</span> -extract arm64 -output test_arm64</span><br></pre></td></tr></table></figure>

<p>合并 test_armv7 和 test_arm64：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo -create test_armv7 test_arm64 -output test0</span><br></pre></td></tr></table></figure>

<p>删除 test 中 armv7s 版本的二进制文件可以执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo <span class="built_in">test</span> -remove armv7s -output test1</span><br></pre></td></tr></table></figure>

<p>通用二进制的”通用”不止针对可以直接运行的可以执行文件，系统中的动态库 .dylib 文件，静态库 .a 文件以及 Framework 等都可以是通用二进制文件，对它们同样也可以使用 <code>lipo</code> 命令来进行管理</p>
<p>接下来打开我们的 Xcode，按 command + shift + o 输入 mach-o&#x2F;fat.h 就可以看到对通用二进制文件格式的声明，从文件的命名和声明来看，将通用二进制叫作胖二进制或许更合适。胖二进制的头部定义如下：</p>
<img src="/2021/06/28/Mach-O/4240093e2e8f4c94aeeb393d242744b3~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="Snip20210627_130.png">

<p><code>magic</code> 字段被定义为常量 FAT_MAGIC，它的取值根据架构是固定的，在 32 位架构上是 <strong>0xcafebabe</strong>，在 64 位架构上是 <strong>0xcafebabf</strong>，表示这是一个通用二进制文件。这里要说一下字节序，计算机硬件有两种储存数据的方式，分别为大端字节序，和小端字节序，大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。小端字节序：低位字节在前，高位字节在后，是大多数机器读取数据的方式。下图所示的是同一个数字 01234567 在大端和小端下的存储方式<br></p>
<img src="/2021/06/28/Mach-O/93163b5b30e94d20b9164059e60e8b47~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="bg2016112201.gif"><br>

<p><code>nfat_arch</code> 字段表示后面的 Mach-O 文件的数量<br></p>
<p>每个通用二进制架构信息都使用 fat_arch 结构体表示，在 fat_header 结构体之后，紧接着的是一个或多个连续的 fat_arch 结构体，它的定义如下：</p>
<img src="/2021/06/28/Mach-O/b58efccc561546129423509f485bdd24~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p><code>cputype</code>字段是 cpu 说明符，类型是<code>cpu_type_t</code>，定义在&lt;mach&#x2F;machine.h&gt;文件，使用同样的 command + shift + o 然后输入头文件的方法可以打开 &lt;mach&#x2F;machine.h&gt; 文件，在 macOS 上取值一般为 <code>CPU_TYPE_I386</code> 或 <code>CPU_TYPE_X86_64</code>，在 iOS 平台上一般是 <code>CPU_TYPE_ARM</code> 或 <code>CPU_TYPE_ARM64</code> <br></p>
<p><code>cpu_subtype</code> 字段是机器说明符，类型是 <code>cpu_subtype_t</code>，同样定义在 &lt;mach&#x2F;machine.h&gt; 文件，macOS 上一般是 <code>CPU_SUBTYPE_I386_ALL</code>，<code>CPU_SUBTYPE_X86_64_ALL</code>，在 iOS 上一般则是 <code>CPU_SUBTYPE_ARM64_ALL</code>，<code>CPU_SUBTYPE_ARM_V7</code><br></p>
<p><code>offset</code> 字段指明了当前 Mach-O 数据相对于当前文件开头的偏移值<br></p>
<p><code>size</code> 字段指明了数据的大小<br></p>
<p><code>align</code> 字段指明了数据的内存对齐边界，取值必须是 2 的 n 次方，它确保了当前 cpu 架构的目标文件加载到内存中时，数据是经过内存优化对齐的</p>
<p>使用 <a href="https://github.com/gdbinit/MachOView">MachOView</a> 可以十分清楚的看到这些信息</p>
<img src="/2021/06/28/Mach-O/b729551411874ad489f96eec9739a78d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>在 fat_arch 结构体往下就是具体的 Mach-O 格式文件了，它的内容复杂得多，将在下一小节进行讨论。</p>
<h1 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mach-O（Mach Object file format）是一种文件格式，用于在 macOS、iOS 以及其他基于 Mach 内核的操作系统上保存可执行文件、目标文件、动态库和内核转储。Mach-O 格式是这些系统上程序的核心组成部分，存储了程序运行所需的所有信息，比如代码、数据、符号表、调试信息等。</p>
<p>熟悉 Mach-O 文件格式，有助于了解苹果软件底层运行机制，更好的掌握 dyld 加载 Mach-O 的步骤，为自己动手开发 Mach-O 相关的加解密工具打下基础</p>
<ol>
<li>MacOS 上的可执行文件是一种 Mach-O 文件(比如 ruby，phtyon…)，但不是所有可执行文件都是 Mach-O 文件</li>
<li>库文件是一种 Mach-O 文件，动态库 .dylib，静态库 .a，还有 Framework 都是一种 Mach-O 文件</li>
<li>.o 文件(clang 编译 c 源文件得到的)也叫目标文件夹，是一种 Mach-O 文件</li>
<li>.dsym 文件(符号表)也是一种 Mach-O 文件</li>
<li>dyld 是可执行文件，自然也是一种 Mach-O 文件</li>
</ol>
<p>以上这些都属于 Mach-O 文件，当然除了以上这五种，还有其他类型的 Mach-O 文件，只是这五种比较常见…其他还有八种，其他八种会在下面对 Mach-O 文件结构的介绍中提到</p>
<p>从上面 MachOView 的截图中可以看到，test 文件内有 4 种不同架构的文件，每种架构的文件都可以称它为一个 Mach-O 文件，而刚刚所讲的通用二进制文件就是一个文件如果包含了 1 种以上的 Mach-O 文件，那么他就是通用二进制文件</p>
<p>我们知道了 Mach-O 文件就是一堆有着特定结构的二进制数据，那么我们如何从这一堆的二进制里获取我们所需要的数据?如果做过股票行情 APP，IM 通讯底层 SDK 或者说使用过 socket 长连接对二进制数据进行过处理，发送，接收的同学，一定会知道对一堆的二进制如何有效的处理，提取我们想要的数据的。以我曾经做过的一款股票行情软件为例，里面就定义了大量的结构体类型，用结构体来对二进制数据进行解析，得到我们想要的数据，那么这个 Mach-O 文件的解析有没有对应的结构体呢?</p>
<p>当然有，在 Xcode 中使用 command + shift + o 搜索 mach-o&#x2F;loader.h 就会发现一堆的结构体，这些结构体都是系统用来解析 Mach-O 文件的，我们也能从中获取到不少的信息</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>一个典型的 Mach-O 文件结构如下图所示：</p>
<img src="/2021/06/28/Mach-O/62725ae27df140d393ceba29767885ec~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="v2-35f7008ce676b29129f9ec8bed3c464f_r.png">

<p>从图中可以了解到一个 Mach-O 文件的结构包括 Header，Load commands 和 Data</p>
<ul>
<li><strong>Header</strong>：描述了 Mach-O 的 cpu 架构、文件类型以及加载命令等信息。</li>
<li><strong>Load commands</strong>：指定文件的逻辑结构和文件在虚拟内存中的布局。</li>
<li><strong>Data</strong>：原始段数据。每个段 Segment 都有一个或多个 Section，它们存放了具体的数据。</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>可以使用 <code>otool</code> 命令来查看 Mach-O 文件的头部信息</p>
<img src="/2021/06/28/Mach-O/b862cd3818584c92b5905e930bd73acb~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>这个部分的定义，可以通过在 Xcode 中，按 command + shift + o 输入 mach-o&#x2F;loader.h 的方式找到</p>
<img src="/2021/06/28/Mach-O/332dbf14f8484f068963603e06ed1417~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<ul>
<li><strong><code>magic</code></strong> 在截图中都能看到的宏定义，对 32 位架构的程序来说，它的值就是 <strong>0xfeedface</strong>，可以使用 <strong>MH_MAGIC</strong> 宏代替。对 64 位架构的程序来说，它的值就是 <strong>0xfeedfacf</strong>，对应的宏  <strong>MH_MAGIC_64</strong></li>
<li><strong><code>cputype</code></strong> 和上一节中所讲的 fat_header 结构体的含义完全相同</li>
<li><strong><code>cpusubtype</code></strong> 同上</li>
<li><strong><code>filetype</code></strong> 表示 Mach-O 文件的具体类型，值有下图所示的12种，常见的有 MH_EXECUTE(可执行文件)，MH_DYLIB(动态库)，MH_DYLINKER(动态连接器)，MH_DSYM(符号表文件)<img src="/2021/06/28/Mach-O/55f1fff26073490d9d7309002b2ba726~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png"></li>
<li><strong><code>ncmds</code></strong> load commands 的数量</li>
<li><strong><code>sizeofcmds</code></strong> 所有 load commands 的占的字节数</li>
<li><strong><code>flags</code></strong> 标记，值比较多，最好去头文件中查看详细说明</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	MH_NOUNDEFS	0x1		<span class="comment">/* the object file has no undefined</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   references */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MH_INCRLINK	0x2		<span class="comment">/* the object file is the output of an</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   incremental link against a base file</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   and can&#x27;t be link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MH_DYLDLINK	0x4		<span class="comment">/* the object file is input for the</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   dynamic linker and can&#x27;t be staticly</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MH_BINDATLOAD	0x8		<span class="comment">/* the object file&#x27;s undefined</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   references are bound by the dynamic</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   linker when loaded. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MH_PREBOUND	0x10		<span class="comment">/* the file has its dynamic undefined</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   references prebound. */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>reserved</code></strong> 这个字段只在 64 位架构的 Mach-O 文件中才有，目前它的取值系统保留</li>
</ul>
<p>使用 MachOView 查看 Header 的信息</p>
<img src="/2021/06/28/Mach-O/0ed044569438410193a72cb6d98e4728~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h3 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h3><p>Load Commands 描述的是文件的加载信息，加载信息有很多，加载的段、符号表、动态库信息等都在 Load Commands 中取到。这个部分信息还是比较有用的，我们可以从这里获取到符号表和字符串表的偏移量，下文中会有详细的解释。</p>
<p>Load Commands 加载命令紧跟在 Header 之后，所有加载命令的前两个字段必须是 cmd 和 cmdsize，cmd 字段用该命令类型的常量填充，头文件中定义了许多的宏用于该字段，每个命令类型都有一个特定的结构。cmdsize 字段是以字节为单位的特定加载命令结构的大小，再加上它后面作为加载命令一部分的任何内容（即节结构、字符串等）要前进到下一个加载命令，可以将 cmdsize 加上当前加载命令的偏移量</p>
<img src="/2021/06/28/Mach-O/b99f9142f65a44e1845403893446cba0~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>cmd 字段的取值有目前有 50 多种，太多了就不全部粘贴出来了…</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LC_REQ_DYLD 0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constants for the cmd field of all load commands， the type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SEGMENT	0x1	<span class="comment">/* segment of this file to be mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SYMTAB	0x2	<span class="comment">/* link-edit stab symbol table info */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SYMSEG	0x3	<span class="comment">/* link-edit gdb symbol table info (obsolete) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_THREAD	0x4	<span class="comment">/* thread */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_UNIXTHREAD	0x5	<span class="comment">/* unix thread (includes a stack) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_LOADFVMLIB	0x6	<span class="comment">/* load a specified fixed VM shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_IDFVMLIB	0x7	<span class="comment">/* fixed VM shared library identification */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_IDENT	0x8	<span class="comment">/* object identification info (obsolete) */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。其中几个常见的加载命令有<code>LC_LOAD_DYLIB</code>、<code>LC_SEGMENT</code>、<code>LC_MAIN</code>、<code>LC_CODE_SIGNATURE</code>、<code>LC_ENCRYPTION_INFO</code>等，下面介绍其中的几个</p>
<h4 id="LC-LOAD-DYLIB"><a href="#LC-LOAD-DYLIB" class="headerlink" title="LC_LOAD_DYLIB"></a>LC_LOAD_DYLIB</h4><p><code>LC_LOAD_DYLIB</code>：表示这是一个需要动态加载的链接库。它使用 dylib_command 结构体表示。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd。		<span class="comment">/* LC_ID_DYLIB， LC_LOAD_&#123;，WEAK_&#125;DYLIB，</span></span><br><span class="line"><span class="comment">					   LC_REEXPORT_DYLIB */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize。	<span class="comment">/* includes pathname string */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dylib</span>	<span class="title">dylib</span>。		/* <span class="title">the</span> <span class="title">library</span> <span class="title">identification</span> */</span></span><br><span class="line"><span class="class">&#125;。</span></span><br></pre></td></tr></table></figure>

<p>当 cmd 类型是<code>LC_ID_DYLIB</code>，<code>LC_LOAD_DYLIB</code>，<code>LC_LOAD_WEAK_DYLIB</code>，<code>LC_REEXPORT_DYLIB</code>时，都使用 dylib_command 结构体表示。其中 dylib 结构体存储要加载的动态库的具体信息如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>  <span class="title">name</span>。			/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">path</span> <span class="title">name</span> */</span></span><br><span class="line"><span class="class">    <span class="title">uint32_t</span> <span class="title">timestamp</span>。			/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">build</span> <span class="title">time</span> <span class="title">stamp</span> */</span></span><br><span class="line"><span class="class">    <span class="title">uint32_t</span> <span class="title">current_version</span>。		/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">current</span> <span class="title">version</span> <span class="title">number</span> */</span></span><br><span class="line"><span class="class">    <span class="title">uint32_t</span> <span class="title">compatibility_version</span>。	/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">compatibility</span> <span class="title">vers</span> <span class="title">number</span>*/</span></span><br><span class="line"><span class="class">&#125;。</span></span><br></pre></td></tr></table></figure>

<p><code>name</code> 字段是链接库的完整路径，动态链接器在加载库时，通用此路径来进行加载它。<br><br><code>timestamp</code>字段描述了库构建时的时间戳<br><br><code>current_version</code>与<code>compatibility_version</code>指明了前当版本与兼容的版本号<br></p>
<p>如果你看了我的上一篇文章 <a href="https://juejin.cn/post/6977384497000448030">代码注入</a> 里面提到了 <code>yololib</code>，这个工具的原理基本就是利用这条 <code>LC_LOAD_DYLIB</code> 加载命令的相关信息实现的</p>
<h4 id="LC-MAIN"><a href="#LC-MAIN" class="headerlink" title="LC_MAIN"></a>LC_MAIN</h4><p><code>LC_MAIN</code>：此加载命令记录了可执行文件的主函数 main() 的位置。它使用 entry_point_command 结构体表示。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_point_command</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>  cmd。	<span class="comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span></span><br><span class="line">    <span class="type">uint32_t</span>  cmdsize。	<span class="comment">/* 24 */</span></span><br><span class="line">    <span class="type">uint64_t</span>  entryoff。	<span class="comment">/* file (__TEXT) offset of main() */</span></span><br><span class="line">    <span class="type">uint64_t</span>  stacksize。<span class="comment">/* if not zero， initial stack size */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>entryoff 字段中就指定了 main() 函数的文件偏移。stacksize 指定了初始的堆栈大小。</p>
<h4 id="LC-SEGMENT-LC-SEGMENT-64"><a href="#LC-SEGMENT-LC-SEGMENT-64" class="headerlink" title="LC_SEGMENT&#x2F;LC_SEGMENT_64"></a>LC_SEGMENT&#x2F;LC_SEGMENT_64</h4><p><code>LC_SEGMENT/LC_SEGMENT_64</code>：段加载命令，描述了 32 位或 64 位 Mach-O 文件的段的信息，常见的段有 <code>__PAGEZERO</code>，<code>__TEXT</code>，<code>__DATA</code>，<code>__LINKEDIT</code>。</p>
<p><code>__PAGEZERO</code> 是一个空段，它位于文件起始段的位置</p>
<p><code>__TEXT</code> 和 <code>__DATA</code> 分别是文本段和数据段，分别存储了代码信息和数据信息</p>
<p><code>__LINKEDIT</code> 是链接信息段。段(segment)又可以细分为section，每个段(segment)可以包含多个section</p>
<p>段使用 segment_command 结构体来表示，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd。		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize。	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="type">char</span>		segname[<span class="number">16</span>]。	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="type">uint32_t</span>	vmaddr。		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	vmsize。		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	fileoff。	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	filesize。	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	maxprot。	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	initprot。	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nsects。		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags。		<span class="comment">/* flags */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>segname</code> 字段是一个 16 字节大小的空间，用来存储段的名称，比如__TEXT…<br></p>
<p><code>vmaddr</code> 字段指明了段要加载的虚拟内存地址<br></p>
<p><code>vmsize</code> 字段指明了段所占的虚拟内存的大小<br></p>
<p><code>fileoff</code> 字段指明了段数据所在文件中偏移地址<br></p>
<p><code>filesize</code> 字段指明了段数据实际的大小<br></p>
<p><code>maxprot</code> 字段指明了页面所需要的最高内存保护<br></p>
<p><code>initprot</code> 字段指明了页面初始的内存保护<br></p>
<p><code>nsects</code> 字段指明了段所包含的节区（section）<br></p>
<p><code>flags</code> 字段指明了段的标志信息<br></p>
<p>还有很多 Load Commands 加载命令，这里就不一一介绍了…贴一张图大概了解下</p>
<img src="/2021/06/28/Mach-O/f3f71180aa9843feb445011970d67772~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>使用 MachOView 查看 Load Commands 的内容</p>
<img src="/2021/06/28/Mach-O/38e722b0733e401a8945d2a834f32ae8~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>数据区，除了 Header 和 Load Commands 外所有的原始数据。Load Commands 是对数据的汇总概括，而数据区则是真实的数据。Load Commands 与数据区的关系就像书的目录与章节的关系，如图所示，Segment 为 __TEXT 的段里，显示有 8 个 section，每个 section 具体的内容就在 Data 区里了</p>
<img src="/2021/06/28/Mach-O/dddae1f46a564c6c9158b4fcd32635dc~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>接下里介绍几个比较重要的 section</p>
<h4 id="TEXT，-text"><a href="#TEXT，-text" class="headerlink" title="(__TEXT，__text)"></a>(<code>__TEXT</code>，<code>__text</code>)</h4><p>这里存放的是汇编后的代码，当我们进行编译时，每个 .m 文件会经过预编译-&gt;编译-&gt;汇编形成 .o 文件，称之为目标文件。汇编后，所有的代码会形成汇编指令存储在 .o 文件的 (<code>__TEXT，__text</code>) 区（（<code>__DATA，__data</code>）也是类似）。</p>
<p>链接后，所有的 .o 文件会合并成一个文件，所有 .o 文件的 (<code>__TEXT，__text</code>) 数据都会按链接顺序存放到应用文件的 (<code>__TEXT，__text</code>) 中。</p>
<img src="/2021/06/28/Mach-O/570ed1a3f60c4e93a1daabd21ffedbea~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h4 id="TEXT，-objc-methname"><a href="#TEXT，-objc-methname" class="headerlink" title="(__TEXT，__objc_methname)"></a>(<code>__TEXT，__objc_methname</code>)</h4><p>这里存放了项目里，所有我们用 Objective-C 写的方法名</p>
<img src="/2021/06/28/Mach-O/2057b7ec64464ce3837bc7f885881527~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h4 id="TEXT，-objc-classname"><a href="#TEXT，-objc-classname" class="headerlink" title="(__TEXT，__objc_classname)"></a>(<code>__TEXT，__objc_classname</code>)</h4><p>这里存放了项目里所有 Objective-C 类的名字</p>
<img src="/2021/06/28/Mach-O/9ab7d736e345420ab2cdd8076c08057d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>class-dump 工具能够解析出每个类的方法，属性，成员变量，应该就是来自上面两个 section 的数据了，当然这只是我的猜测，具体怎么实现的就要去看 class-dump 的源码了</p>
<h4 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h4><p>符号表，这个是重点中的重点，符号表是将地址和符号联系起来的桥梁。符号表并不能直接存储符号，而是存储符号位于字符串表的位置。</p>
<img src="/2021/06/28/Mach-O/2721f7baa7b941e6be63421636ef4764~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h4 id="String-Table"><a href="#String-Table" class="headerlink" title="String Table"></a>String Table</h4><p>字符串表所有的变量名、函数名等，都以字符串的形式存储在字符串表中。</p>
<img src="/2021/06/28/Mach-O/47a85d63ea9a43c29531012586a964c2~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<h4 id="Dynamic-Symbol-Table"><a href="#Dynamic-Symbol-Table" class="headerlink" title="Dynamic Symbol Table"></a>Dynamic Symbol Table</h4><p>动态符号表存储的是动态库函数位于符号表的偏移信息。(<code>__DATA</code>，<code>__la_symbol_ptr</code>) section 可以从动态符号表中获取到该 section 位于符号表的索引数组。动态符号表并不存储符号信息，而是存储其位于符号表的偏移信息。Fishhook 源码看起来比较复杂主要是因为 hook 的是动态链接的函数，索引和链接关系比较绕。但是我们自己编写的 C 函数不是动态链接的，而是在编译链接后代码指令就存储在文件内部的函数，因此不会用到动态符号表也就无法 hook。</p>
<img src="/2021/06/28/Mach-O/322f3e1e56ed40309400dc4a483e79d5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class="" alt="image.png">

<p>当然，关于 Mach-O 文件的知识远不止这么点，但是要完全讲清楚里面的所有内容，那估计不是这么一篇文章能够讲的清楚的，至少也得是一本书了，我也只是网上收集到的一些资料，自己写了篇总结而已<br></p>
<h1 id="Mach-O-的应用"><a href="#Mach-O-的应用" class="headerlink" title="Mach-O 的应用"></a>Mach-O 的应用</h1><ul>
<li><p><a href="https://github.com/KJCracks/yololib"><strong>yololib</strong></a> 这个工具将我们的库文件路径写入 Mach-O 文件的 Load Command 中，从而实现让别人的进程依赖我们的库</p>
</li>
<li><p><a href="https://github.com/nygard/class-dump"><strong>class-dump</strong></a> 这个工具就是通过对 Mach-O 文件的解析得到的结果。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>SDWebimage设置图片时URL不变，但图片改变的解决办法</title>
    <url>/2018/07/17/SDWebimage%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E6%97%B6URL%E4%B8%8D%E5%8F%98%EF%BC%8C%E4%BD%86%E5%9B%BE%E7%89%87%E6%94%B9%E5%8F%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>本篇文章转载自<a href="https://blog.csdn.net/xumugui007/article/details/51605546">SDWebImage支持URL不变时更新图片内容</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImage在iOS项目中是一个很常用的开源库，而且众所周知的是，它是基于URL作为Key来实现图片缓存机制的。在90%左右的情况下，</span><br><span class="line">图片与URL是一一对应的，即使服务器修改了图片也会相应的变更URL。但是在少数情况下，服务器修改了图片后不会变更相应的URL，也就是</span><br><span class="line">说图片本身的内容变了然而它的URL没有变化，那么按照对SDWebImage的常规使用方法的话，客户端肯定更新不到同一URL对应到服务器已变</span><br><span class="line">更的图片内容。</span><br></pre></td></tr></table></figure>

<p>基于这一现象，我们来进行分析。</p>
<p>客户端第一次请求图片时，Charles抓包得知response header里有一个名为Last-Modified、数据是时间戳的键值对。</p>
<p>客户端第二次及以后请求图片时，通过Charles抓包发现，服务器返回304 not modified状态，说明服务器在接收客户端请求后通过某种判断逻辑得出结论：“客户端已缓存的图片与服务器图片都是最新的”，那么服务器如何判断的呢？</p>
<p>通过查阅HTTP协议相关的资料得知，与服务器返回的Last-Modified相对应的request header里可以加一个名为If-Modified-Since的key，value即是服务器回传的服务端图片最后被修改的时间，第一次图片请求时If-Modified-Since的值为空，第二次及以后的客户端请求会把服务器回传的Last-Modified值作为If-Modified-Since的值传给服务器，这样服务器每次接收到图片请求时就将If-Modified-Since与Last-Modified进行比较，如果客户端图片已陈旧那么返回状态码200、Last-Modified、图片内容，客户端存储Last-Modified和图片；如果客户端图片是最新的那么返回304 Not Modified、不会返回Last-Modified、图片内容。</p>
<p>关于服务器的比较逻辑，需要强调一下。</p>
<p>经查资料得知，Apache比较时是看If-Modified-Since之后有没有更新图片，Nginx比较时是看If-Modified-Since与Last-Modified是否相等，所以对于Apache服务器环境客户端每次都要严格的存储服务器回传的Last-Modified以便下次请求时作为If-Modified-Since的值传给服务器，对于Nginx服务器环境客户端不必存储服务器回传的Last-Modified，每次请求时只需将图片自身的fileModificationDate作为If-Modified-Since的值传服务器即可。在实际开发中，如果遇到明明传了If-Modified-Since、服务器图片也变更了、但是客户端却请求不到最新的图片的情况时，那么就需要查看一下服务器对这两个时间戳的比较逻辑。</p>
<p>那么，现在我们可以回到SDWebImage上来了。通过查看SDWebImageDownloader的源码得知，它开放了一个headersFilter的block，意在让开发者可以对所有图片请求追加一些额外的header，这正合我意。那么我们就可以在诸如AppDelegate didFinishLaunching的地方追加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;</span><br><span class="line">imgDownloader.headersFilter  = ^NSDictionary *(NSURL *url, NSDictionary *headers) &#123;</span><br><span class="line"> </span><br><span class="line">    NSFileManager *fm = [[NSFileManager alloc] init];</span><br><span class="line">    NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];</span><br><span class="line">    NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];</span><br><span class="line">    NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil];</span><br><span class="line"> </span><br><span class="line">    NSMutableDictionary *mutableHeaders = [headers mutableCopy];</span><br><span class="line"> </span><br><span class="line">    NSDate *lastModifiedDate = nil;</span><br><span class="line"> </span><br><span class="line">    if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">        if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">            lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">    formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;GMT&quot;];</span><br><span class="line">    formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];</span><br><span class="line">    formatter.dateFormat = @&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;;</span><br><span class="line"> </span><br><span class="line">    NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];</span><br><span class="line">    lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @&quot;&quot;;</span><br><span class="line">    [mutableHeaders setValue:lastModifiedStr forKey:@&quot;If-Modified-Since&quot;];</span><br><span class="line"> </span><br><span class="line">    return mutableHeaders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，加载图片的地方以前怎么写还是怎么写，但别忘了Option是SDWebImageRefreshCached</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSURL *imgURL = [NSURL URLWithString:@&quot;http://handy-img-storage.b0.upaiyun.com/3.jpg&quot;];</span><br><span class="line">[[self imageView] sd_setImageWithURL:imgURL</span><br><span class="line">                    placeholderImage:nil</span><br><span class="line">                             options:SDWebImageRefreshCached];</span><br></pre></td></tr></table></figure>

<p>经测试，服务器只修改图片不变更URL的时候，客户端也可以更新到最新的图片。</p>
<p>从以上第一段代码内容可以看出我采用的是与ngix服务器比较逻辑对应的代码，BTW:我测试的服务器是又拍云，说明又拍云的比较逻辑是等与不等的关系判断，不是大小关系的判断。</p>
<p>这里顺便说一下，如果服务器的环境是类似于Apache的比较逻辑时，客户端可以把Last-Modified存放在图片的名称上(这需要修改SDWebImage源码，不建议)，或者用一个plist文件存放图片key名称与时间的对应关系(这个不用修改源码)。</p>
<p>OK，到此这次的主题已得到完美解决。</p>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 应用砸壳</title>
    <url>/2024/10/27/iOS-%E5%BA%94%E7%94%A8%E7%A0%B8%E5%A3%B3/</url>
    <content><![CDATA[<h1 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h1><p>在软件保护和安全领域，“壳”指的是利用特殊的算法对应用程序的二进制文件进行加密或包装的保护层，通常被称为 “加壳”。壳的作用是保护应用程序的代码，防止未经授权的访问、篡改和逆向工程。壳通常会在应用程序启动时将其解密到内存中，以便正常运行。</p>
<p>苹果会在应用发布到 App Store 时，对应用程序进行 DRM（数字版权管理）保护，这种保护即一种壳，目的是防止非法分发。所以从 App Store 下载的应用程序，我们无法使用 hopper，ghidra，ida 等逆向工具进行静态分析，也无法使用 class-dump 这样的工具导出头文件。需要对其进行解密也就是砸壳，也有人喜欢称脱壳之后，才能进行逆向分析。</p>
<p>iOS 应用加壳只有苹果公司内部自己能处理，所以我们只讨论砸壳的方式：</p>
<h1 id="砸壳的方式"><a href="#砸壳的方式" class="headerlink" title="砸壳的方式"></a>砸壳的方式</h1><ol>
<li><p><strong>静态砸壳或硬砸壳：</strong>就是在已经掌握和了解壳的加密算法和逻辑之后在不运行应用程序的情况下将应用程序的壳进行解密处理。静态砸壳的方法难度大，而且加密方发现应用被破解之后就可能会该用更高级和复杂的加密技术。</p>
</li>
<li><p><strong>动态砸壳：</strong>动态砸壳就是从运行在进程内存空间中的可执行文件镜像入手，将内存中的内容进行转储（dump）处理实现脱壳。这种方式实现起来相对简单且不必关心使用的是什么加密技术。</p>
</li>
</ol>
<p>iOS 砸壳大多采用动态砸壳的方式。</p>
<h1 id="查看-iOS-应用的壳状态"><a href="#查看-iOS-应用的壳状态" class="headerlink" title="查看 iOS 应用的壳状态"></a>查看 iOS 应用的壳状态</h1><p><code>LC_ENCRYPTION_INFO_64</code> 是 Mach-O 文件格式中的一个加载命令（load command），用于描述 64 位 Mach-O 文件的加密信息。该加载命令常见于 macOS 和 iOS 应用程序的可执行文件中，主要包含应用程序是否加密及其相关的加密信息。</p>
<h2 id="主要字段"><a href="#主要字段" class="headerlink" title="主要字段"></a>主要字段</h2><ul>
<li><strong>cryptoff</strong>：加密数据的偏移量，表示从文件的哪个位置开始加密数据。</li>
<li><strong>cryptsize</strong>：加密数据的大小，以字节为单位，指示被加密的范围。</li>
<li><strong>cryptid</strong>：加密标识符，用于表明数据是否被加密。值为 0 表示数据未加密；其他值表示数据已加密。</li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>在 iOS 应用中，<code>LC_ENCRYPTION_INFO_64</code> 常用于 <strong>FairPlay</strong> DRM（数字版权管理）保护。iOS 应用在上传到 App Store 时，苹果会对其进行加密保护，以防止未经授权的访问或修改。通过检查 <code>LC_ENCRYPTION_INFO_64</code> 的字段值，可以判断应用是否经过 DRM 加密保护。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>查看 <code>LC_ENCRYPTION_INFO_64</code> 信息有以下两种方式：</p>
<ol>
<li><strong>图形化工具：</strong>MachOView</li>
<li><strong>命令行工具：</strong>otool</li>
</ol>
<h3 id="MachOView"><a href="#MachOView" class="headerlink" title="MachOView"></a><a href="https://github.com/gdbinit/MachOView">MachOView</a></h3><p><strong>MachOView</strong> 是一款用于 macOS 的图形化工具，专门设计用于分析和查看 Mach-O 文件格式。Mach-O（Mach Object）是 macOS 和 iOS 操作系统使用的可执行文件格式，包含了二进制可执行文件、库文件、内核扩展等。</p>
<p>MachOView 提供了一个直观的界面，可以帮助开发者和逆向工程人员深入分析 Mach-O 文件的结构和内容。它展示了文件头、加载命令、段（segments）、节（sections）、符号表（symbol table）、动态符号、字符串表等各种信息。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul>
<li><strong>查看文件头</strong>：展示 Mach-O 文件的文件头信息，例如文件类型、CPU 架构等。</li>
<li><strong>加载命令</strong>：列出所有的加载命令，包括动态库依赖、入口点、数据段等。</li>
<li><strong>段和节</strong>：显示所有的段和节信息，并可以查看它们的详细内容。</li>
<li><strong>符号表</strong>：解析并显示符号表和动态符号，包括全局符号和本地符号。</li>
<li><strong>反汇编</strong>：支持代码段的反汇编，以查看可执行代码的汇编指令。</li>
<li><strong>导出功能</strong>：可以将分析结果导出为文本格式，以供进一步分析。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>MachOView 是 macOS 和 iOS 逆向工程、应用开发及安全研究的重要工具。它使得用户可以深入了解 Mach-O 文件的内部结构，适合用于以下场景：</p>
<ul>
<li><strong>应用逆向工程</strong>：了解应用内部的函数、符号等信息。</li>
<li><strong>安全研究</strong>：分析应用是否进行了加密保护，研究其安全机制。</li>
<li><strong>调试和开发</strong>：查看动态库依赖、文件结构等信息，以帮助调试和优化。</li>
</ul>
<h4 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h4><p>MachOView 可以通过项目的 GitHub 页面进行下载，支持 macOS 平台。使用者可以直接下载预编译的二进制文件，或通过源码自行编译安装。</p>
<p>使用 MachOView 查看可执行文件的 <code>LC_ENCRYPTION_INFO_64</code> 信息</p>
<img src="/2024/10/27/iOS-%E5%BA%94%E7%94%A8%E7%A0%B8%E5%A3%B3/Xnip2024-10-14_16-56-13.jpg" class="">

<h3 id="otool"><a href="#otool" class="headerlink" title="otool"></a>otool</h3><p><code>otool</code> 是 macOS 上的一个命令行工具，用于显示可执行文件、动态库和目标文件的各种低级信息。它是开发者用来分析、调试和检查 Mach-O 文件结构的重要工具。Mach-O（Mach Object）文件格式是 macOS 和 iOS 使用的可执行文件格式，包括应用程序、动态库和内核扩展等。对于从事 macOS 或 iOS 应用开发及逆向工程的人员，<code>otool</code> 是一个非常有用的工具。</p>
<p><code>otool</code> 并非 macOS 系统自带的，而是随 <strong>Xcode Command Line Tools</strong> 一起提供的。因此，默认情况下 macOS 并不包含 <code>otool</code>。要使用 <code>otool</code>，需要先安装 <strong>Xcode Command Line Tools</strong>。幸运的是，不需要安装完整的 Xcode 应用，只需安装命令行工具即可获取 otool。</p>
<p>可以通过以下命令快速安装 Xcode Command Line Tools：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>假设我们有一个 Mach-O 文件 <code>example</code>，可以用以下命令查看其是壳的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ~/ otool -l MachO文件 | grep crypt</span><br><span class="line">     cryptoff 16384</span><br><span class="line">    cryptsize 265289728</span><br><span class="line">      cryptid 0</span><br></pre></td></tr></table></figure>

<p>显示 <code>cryptid 0</code> 表示壳已经被解密。</p>
<h1 id="iOS-应用砸壳工具"><a href="#iOS-应用砸壳工具" class="headerlink" title="iOS 应用砸壳工具"></a>iOS 应用砸壳工具</h1><p>以下这些砸壳工具是目前为止作者本人知道并动手实践过的，鉴于作者知识储备有限，可能并不是 iOS 平台全部的砸壳工具。某些工具作者没有亲自动手实践过的就不列举了，如 xia0LLDB …</p>
<h2 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a><a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a></h2><p>是一个动态库，利用 DYLD 的环境变量，将自己插入需要砸壳的进程中，但是很多年没有维护更新了。。。</p>
<h2 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a><a href="https://github.com/KJCracks/Clutch">Clutch</a></h2><p>是一个 iOS 上命令行程序，也是很多年没有维护更新了。下载编译后在 iOS12.5.7 上，能砸壳一些简单的 app，但是像微信，支付宝这样的 app 会失败。</p>
<h2 id="frida-ios-dump"><a href="#frida-ios-dump" class="headerlink" title="frida-ios-dump"></a><a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a></h2><p>是一个基于 frida 的 python 脚本，目前最强的 iOS 砸壳脚本，支持最新版本微信，支付宝等。但是需要注意版本的问题，一是 Mac 上安装的 frida 版本需要和 iPhone 上安装的 frida 版本一致。其次需要注意 frida 版本并不是越新越好，我以前明明可以成功砸壳的，结果更新 frida 版本之后反而无法成功砸壳了。记录一下 2025年06月19日 前后使用的越狱手机是 iPhone8Plus iOS16.7.10 使用的 palera1n 的 rootful 越狱，运行 frida 的 16.2.0 是可以砸壳成功的。前后某几个版本我都试过了砸壳不成功，但不代表都不成功，因为前后版本太多了我并没有精力一个个版本尝试。</p>
<h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>Xcode 自带的调试器，使用 lldb 命令手动实现砸壳。</p>
<h2 id="AppDump2"><a href="#AppDump2" class="headerlink" title="AppDump2"></a>AppDump2</h2><p>是一个 iOS App，不需要越狱设备，但是设备需要安装巨魔才能安装 AppDump2 实现砸壳。。。而巨魔又有 iOS 系统的限制，所以仅作为参考吧。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 应用签名原理</title>
    <url>/2021/06/18/iOS-%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>要看懂这篇文章的前提条件：</p>
<p>对密码学有一个大概的了解，了解对称加密算法，非对称加密算法，哈希算法等知识。。。</p>
<p>这里简单介绍一下，也可以看作者之前发布的文章 <a href="https://masterking.github.io/2021/06/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/">密码学概述</a>：</p>
<ul>
<li><p>对称加密算法的加密和解密使用同一个密钥，速度快，效率高，适合处理大规模的数据。</p>
</li>
<li><p>非对称加密算法有一对公私钥，公钥加密的数据私钥可以解密，私钥加密的数据公钥可以解密。此算法速度慢，效率低，但安全性没得说，适合小规模的数据。</p>
</li>
<li><p>哈希算法，对原始数据进行哈希运算得到一个固定长度的数据这个数据类似于身份证具有唯一性。哈希算法存在哈希碰撞的可能，也就是不同的原始数据经过哈希算法得到了相同的结果，这是不可完全避免的。加密哈希函数（如 SHA-256）通常具有更强的抗碰撞性，但计算代价较高，适用于需要更高安全性的场景（如密码存储、数据完整性验证等）。</p>
</li>
</ul>
<h1 id="iOS-应用签名"><a href="#iOS-应用签名" class="headerlink" title="iOS 应用签名"></a>iOS 应用签名</h1><p>在 iOS 系统出来之前，主流的操作系统（Mac 或者 Windows）软件随便从哪里下载都能安装，运行，系统安全存在隐患，盗版软件，病毒入侵，静默安装等等问题，苹果希望 iOS 的系统上不会出现这样的问题，就要保证每一个安装到 iOS 系统上的 APP 都是经过苹果官方允许的，那么苹果是如何做到的呢？</p>
<p>那就是签名</p>
<h2 id="什么是签名？"><a href="#什么是签名？" class="headerlink" title="什么是签名？"></a>什么是签名？</h2><ul>
<li>使用私钥对数据加密的这个动作就叫签名。</li>
<li>使用公钥对数据解密，解密之后和原始数据比对是否是一样的，这个动作就叫验证签名。</li>
</ul>
<p>在实际情况中，原始数据的数据量往往比较大，而公钥私钥这种非对称加密算法如 RSA 算法的时间复杂度很高，意味着计算会很耗时。所以通常都会使用原始数据的 hash 值代替原始数据进行加密。</p>
<p>那么签名的过程就变成了，使用私钥对原始数据的 hash 值进行加密。发送数据的时候将原始数据和加密后的 hash 值一起发送出去。接收方收到这堆数据后，使用公钥对加密后的 hash 值解密得到明文 hash 值，有了这个 hash 值再和原始数据的 hash 值进行比对，如果是相同的就表示原始数据没有被他人篡改过，是可以信任的。在一些复杂的场景中，发送的数据中不仅仅只有原始数据和加密后的 hash 值。</p>
<p>上传到 App Store 的应用，苹果会对其进行加壳处理，再用它的私钥 Apple 对应用签名，这里使用 Apple 表示一对苹果的公私钥，应用下载到 iPhone 上之后，iOS 系统使用自带的公钥 Apple 验证签名，只有验证通过了才能进行安装，这样就保证了所有安装到 iPhone 上的应用都是经过苹果公司允许的。这种简单的情况可能只存在最初 iOS 系统刚刚诞生的时候，且 App Store 还没对外开放给大众的时候。</p>
<p>因为自 2008 年发布的 iOS 2.0 苹果正式开放 App Store 之后，这个版本首次允许第三方开发者将应用提交到 App Store，使得普通人也可以开发并发布自己的应用。那么普通人在开发 App 的时候肯定要调试 App，调试时候肯定不可能上传到 App Store 了，那这种情况苹果又如何保证即使是调试的 App 也要经过苹果的允许呢？还有苹果在 2011 年推出了苹果开发者的企业级账号，旨在满足大型企业的需求，企业级账号开发的应用不适合也不需要上传到 App Store 但依旧需要下发到 iOS 设备上使用。这种情况下又如何保证下发的应用是经过苹果允许的呢？</p>
<h2 id="多层签名"><a href="#多层签名" class="headerlink" title="多层签名"></a>多层签名</h2><p>开发者通过向苹果发送一个 CSR (Certificate Signing Request,证书签名请求) 文件申请开发或分发证书 (Development Certificate &#x2F; Distribution Certificate)，苹果验证开发者身份后签发证书。这个过程中，开发者的电脑上生成了一对公私钥，这里用公钥 Mac 和私钥 Mac 表示。发送的 CSR 文件里面主要的内容就是公钥 Mac。所以苹果签发的证书里面其实主要内容也就是经过私钥 Apple 签名的公钥 Mac。所以可以理解成，证书就是经过 CA 机构签名的公钥，最简单的理解是证书就是公钥（这种说法肯定不完全正确，但是易于理解）。</p>
<p>有了这个证书之后：</p>
<p>开发者在使用 Xcode 编译打包 App 的时候，Xcode 会使用刚刚生成 CSR 文件时产生的私钥 Mac 对 App 进行签名。同时会将刚刚获取的证书放入 App 包内。</p>
<p>当这个 App 在 iOS 设备上安装的时候，iOS 系统会先验证 App 包内证书的签名。使用系统自带的公钥 Apple 可以验证由私钥 Apple 签名的证书确保证书没有被篡改，也就是公钥 Mac 可以信任使用。</p>
<p>然后，使用证书里面的公钥 Mac 对 App 进行验证，确保 App 在 Xcode 编译签名之后没有被篡改，可以安装。</p>
<p>以上只是最简单的双层签名，苹果为了控制更多的细节，如可以安装 app 的设备，app 的权限控制等等。新增了一个描述配置文件（Provisioning Profile），配置文件包含了 App ID，证书，应用授权信息和设备授权列表等信息。配置文件同样经过私钥 Apple 签名，所以里面的 App ID 信息，App 授权信息，证书，设备授权列表都是无法修改的。即使修改了也无法通过签名验证。到这里至少存在 3 层签名。</p>
<p>描述配置文件预览：</p>
<img src="/2021/06/18/iOS-%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/Xnip2024-11-03_14-14-45.jpg" class="">

<p>配置文件可以在 Mac 电脑上的以下路径找到： ~&#x2F;Library&#x2F;MobileDevice&#x2F;Provisioning Profiles</p>
<p>这种为了实现更多的需求，将证书包了一层的做法在软件开发过程中经常使用。</p>
<p>此时，iOS 应用签名的完整流程就清晰了。</p>
<ol>
<li>对于上传到 App Store 的 App，使用私钥 Apple 签名就足够了。用户下载安装后通过 iOS 系统上私钥 Apple 验证签名。</li>
<li>对于调试阶段的 App。使用证书和配置文件控制。</li>
</ol>
<h1 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h1><ul>
<li>p12 文件是什么？<br>  p12 文件就是私钥 Mac 的拷贝，让除了证书申请的那台电脑以外的电脑也能够对 App 签名真机调试。</li>
</ul>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 应用重签名</title>
    <url>/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<p>上一篇文章作者讲解了 iOS 应用签名的原理。理解了签名的流程之后，我们知道签名保证的是自签名之后原始数据没有被其他人篡改，我们的 App 在调试过程中每次安装到设备上都会签名，假设我们使用自己的配置文件和证书对他人的 App 进行签名，是不是就能冒充是我们自己开发的 APP 了？</p>
<p>是的。</p>
<p>如果你足够细心的话，在 Xcode 每次编译源码的时候，最后的几个步骤中就会看到签名过程：</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/Xnip2024-11-05_00-54-43.jpg" class="">

<p>由图中可以看到，Xcode 是利用 codesign 命令行工具进行签名的。。。所以我们也可以利用 codesign 手动签名。</p>
<h1 id="重签名的前提"><a href="#重签名的前提" class="headerlink" title="重签名的前提"></a>重签名的前提</h1><p>重签名要使用未加壳或者成功砸壳过的 App，为什么重签名一定要用砸壳过的 App 包呢？</p>
<ul>
<li>经过实践证明，未砸壳的 App 即使重签名成功，安装也成功，但打开会闪退…</li>
</ul>
<p>从 App Store 下载的应用都是加壳的，需要先砸壳。如果是开发调试阶段的 App 一般都是没有加壳的，可以直接重签名。</p>
<h1 id="重签名的目的"><a href="#重签名的目的" class="headerlink" title="重签名的目的"></a>重签名的目的</h1><ol>
<li>调试他人的 App；这种情况对于我们逆向开发很方便如 MonkeyDev 的原理，本文会重点讲解。</li>
<li>在未越狱设备上安装调整过的 App。这个内容会在学了 Theos 开发 tweak 之后讲解。</li>
<li>更换 App 的拥有者（例如外包公司提供了 ipa 包，但没有给源码的情况）。这种情况可以使用一些成熟的工具，如 <a href="https://github.com/DanTheMan827/ios-app-signer">iOS App Signer</a>，<a href="https://github.com/maciekish/iReSign">iReSign</a> 这些工具就不多说了，自行下载安装使用就好了。对于我们的情况，就算使用砸壳过后的 ipa 包使用它进行重签名肯定也无法正常安装使用的。</li>
</ol>
<h1 id="重签名过程中常用的命令"><a href="#重签名过程中常用的命令" class="headerlink" title="重签名过程中常用的命令"></a>重签名过程中常用的命令</h1><p>查看签名信息的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">codesign -vv -d Mach-O</span><br></pre></td></tr></table></figure>

<p>查看当前电脑上的证书信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">security find-identity -v -p codesigning</span><br></pre></td></tr></table></figure>

<p>提取 mobileprovision 文件中的 entitlements 信息生成 plist 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">security cms -D -i embedded.mobileprovision | plutil -extract Entitlements xml1 - -o ent.plist</span><br></pre></td></tr></table></figure>

<p>对库和 extension 签名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">codesign -f -s 证书ID xxx.dylib</span><br></pre></td></tr></table></figure>

<p>对 app 包进行签名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">codesign -f -s 证书ID --entitlements entitlements.plist path/to/xxx.app</span><br></pre></td></tr></table></figure>


<h1 id="MonkeyDev-的原理"><a href="#MonkeyDev-的原理" class="headerlink" title="MonkeyDev 的原理"></a>MonkeyDev 的原理</h1><p>我们一步一步探索 MonkeyDev 的原理</p>
<h2 id="手动签名"><a href="#手动签名" class="headerlink" title="手动签名"></a>手动签名</h2><p>我们以微信为例子来进行重签名，以下演示的是微信的老版本，但已在更新本文章时的最新微信版本 8.0.53 测试过，在拿到已经砸壳过的微信 ipa 包（可以自己动手砸壳，或者在网上搜索下载）之后，用归档实用工具解压</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/bcfa27bc5dab4bc392ada8c2f0f1f68d~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210617_1.png">

<p>我们只需要 Payload 里面的 .app 包</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/1d432d85ed26447aab059e68cbb1fa0b~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210617_2.png">

<p>右键 .app 包显示包内容后，开始下面的步骤</p>
<h3 id="删除插件-PlugIns，Watch，com-apple-WatchPlaceholder-文件夹"><a href="#删除插件-PlugIns，Watch，com-apple-WatchPlaceholder-文件夹" class="headerlink" title="删除插件 PlugIns，Watch，com.apple.WatchPlaceholder 文件夹"></a>删除插件 PlugIns，Watch，com.apple.WatchPlaceholder 文件夹</h3><p>删除的原因是我们使用的是免费的苹果开发者账号，一次性最多申请的 App ID 数量只有 10 个。但是微信这个包里面，包括 PlugIns，Watch，com.apple.WatchPlaceholder 文件夹里里外外的扩展，插件都重签名的话就会因为免费开发者账号的限制导致失败。但是删除这些文件夹并不影响使用主要的功能。</p>
<p>com.apple.WatchPlaceholder 文件夹是较新版本的微信中新增的，老版本中没有</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/a6af7ae975c24a37aa6090aaa040b655~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210617_4.png">

<p><strong>需要特别注意的是</strong>，SC_Info 文件夹中还存在 PlugIns 相关的配置，所以还需要删除 Manifest.plist 文件中的以下相关配置，否则会出现第一次安装成功，以后安装都失败的问题。</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/Xnip2024-11-05_19-34-11.jpg" class="">

<h3 id="对-Frameworks-里面的库进行重签名"><a href="#对-Frameworks-里面的库进行重签名" class="headerlink" title="对 Frameworks 里面的库进行重签名"></a><del>对 Frameworks 里面的库进行重签名</del></h3><p>这一步经过实践发现不是必须的。</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/2a8d812f33624ff68be72006fda1bbbf~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210617_5.png">

<h3 id="给-APP-二进制文件加执行权限"><a href="#给-APP-二进制文件加执行权限" class="headerlink" title="给 APP 二进制文件加执行权限"></a>给 APP 二进制文件加执行权限</h3><p>没有权限的二进制文件是白色的</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/f4406668b2574c0a915cdad5bcbc3aed~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>提升权限之后变成黑色的</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/485c5116646347fdb026f798d8a13ee9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="往真机添加描述文件"><a href="#往真机添加描述文件" class="headerlink" title="往真机添加描述文件"></a>往真机添加描述文件</h3><p>新建一个工程，在真机上运行一次</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/f79bc32e30894d29840a5d51cf4a3e61~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>再将新建 Demo 的描述文件，复制到 WeChat.app 内</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/45ed5ab6dcc94e9d82b36a1525a2f20f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="替换-BundleID"><a href="#替换-BundleID" class="headerlink" title="替换 BundleID"></a>替换 BundleID</h3><p>把 WeChat.app 里面的 info.plist 的 BundleID 改为新建的 Demo 的 BundleID</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/2fd799b83c0e44758100b86f312e8b18~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h3 id="使用-Entilements-权限信息重签-app-包"><a href="#使用-Entilements-权限信息重签-app-包" class="headerlink" title="使用 Entilements 权限信息重签 app 包"></a>使用 Entilements 权限信息重签 app 包</h3><p>权限信息在描述文件里面,输入<code>security cms -Di embedded.mobileprovision</code>可以查看描述文件具体信息。</p>
<p>可以使用以下组合命令提取 embedded.mobileprovision 中的 Entitlements 的值并生成一个 plist 文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">security cms -D -i embedded.mobileprovision | plutil -extract Entitlements xml1 - -o ent.plist</span><br></pre></td></tr></table></figure>

<p>再把这个 plist 文件,放到和 WeChat.app 同目录下,准备重签</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/c1e91e6786394efb881934c1123f4d25~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>打开终端,输入以下命令进行重签:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">codesign --force --sign <span class="string">&quot;你的证书名或证书的SHA-1&quot;</span> --entitlements=ent.plist WeChat.app</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>codesign -vv -d WeChat.app</code> 命令查看我们是否成功重签了,变成你的证书和 BundleID 就代表成功了</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/c24aee162b184bf980cecf5bafcafe3a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>到此,这个 WeChat 就被我们重签成功了!!!此时,我们可以使用 Xcode 将这个 WeChat 安装到我们的手机上，打开 Xcode 的 Devices and Simulators 点击 + 号选择刚刚重签的 app 包安装。</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/4ef8aea82a0d4b409f1f4414219eabe9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>如果你的手机上本来有一个官方正版微信，你现在会发现手机上出现了两个微信。接下来你可以打开刚刚新建的 WeChatDemo 项目，选择 Debug -&gt; Attach to Process -&gt; WeChat，如果有两个 WeChat 可以把正版的 WeChat 从后台划掉，或者选择后面数字较大的那个 WeChat（最后打开的进程 id 数字越大），你会发现微信就这样被我们的 WeChatDemo 项目连接起来了…可以对微信像调试我们自己 APP 一样 viewDebug 了</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/f081890dadc84ebe9f0a27e28f1a0a30~tplv-k3u1fbpfcp-watermark.png" class="" alt="Snip20210617_30.png">

<h2 id="使用-Xcode-签名"><a href="#使用-Xcode-签名" class="headerlink" title="使用 Xcode 签名"></a>使用 Xcode 签名</h2><p>通过使用 codesign 手动重签过程后，发现其实上述过程并不难，只是过程有些复杂和繁琐，Xcode 可以帮我们简化一些复杂繁琐的过程，那么现在我们借助 Xcode 来重签。</p>
<h3 id="新建与重签-APP-同名的工程并在真机上运行一次"><a href="#新建与重签-APP-同名的工程并在真机上运行一次" class="headerlink" title="新建与重签 APP 同名的工程并在真机上运行一次"></a>新建与重签 APP 同名的工程并在真机上运行一次</h3><p>这一步和之前任何时候创建新的 iOS 项目没有什么区别。</p>
<h3 id="删除插件-PlugIns，Watch，com-apple-WatchPlaceholder-文件夹-1"><a href="#删除插件-PlugIns，Watch，com-apple-WatchPlaceholder-文件夹-1" class="headerlink" title="删除插件 PlugIns，Watch，com.apple.WatchPlaceholder 文件夹"></a>删除插件 PlugIns，Watch，com.apple.WatchPlaceholder 文件夹</h3><p>这一步跟上面刚刚手动重签名的步骤一样。</p>
<h3 id="给-APP-二进制文件加执行权限-1"><a href="#给-APP-二进制文件加执行权限-1" class="headerlink" title="给 APP 二进制文件加执行权限"></a>给 APP 二进制文件加执行权限</h3><p>这一步同上。</p>
<h3 id="替换-BundleID-1"><a href="#替换-BundleID-1" class="headerlink" title="替换 BundleID"></a>替换 BundleID</h3><p>这一步同上。</p>
<h3 id="将上面步骤修改后的-app-包放到工程根目录下"><a href="#将上面步骤修改后的-app-包放到工程根目录下" class="headerlink" title="将上面步骤修改后的 app 包放到工程根目录下"></a>将上面步骤修改后的 app 包放到工程根目录下</h3><p>如下图所示：</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/Xnip2024-11-05_22-35-07.jpg" class="">

<h3 id="修改工程的一些配置"><a href="#修改工程的一些配置" class="headerlink" title="修改工程的一些配置"></a>修改工程的一些配置</h3><p>将 User Script Sandboxing 设置为 NO。如下图：</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/Xnip2024-11-05_22-38-39.jpg" class="">

<p>添加 Xcode 编译阶段的自定义脚本，如下图：</p>
<img src="/2021/06/20/iOS-%E5%BA%94%E7%94%A8%E9%87%8D%E7%AD%BE%E5%90%8D/Xnip2024-11-05_22-40-57.jpg" class="">

<p>这段脚本代码的作用很简单，就是将我们刚刚放在工程根目录下的 app 包在编译的最后阶段，在 Xcode 签名 app 包之前替换编译生成的 app 包。这样 Xcode 就自动替我们完成签名的工作了。</p>
<p>接下来使用 command + R 运行工程就会看到启动我们重签名的微信了。在这一步里，我们只是用了最简单的一句拷贝脚本来替换 Xcode 编译生成的 app 包，然后 Xcode 继续完成签名安装的动作。那么前面的那些，删除文件夹的动作，替换 BundleID 的动作是否也能通过脚本完成呢？当然可以，这就是接下来的完善签名脚本</p>
<h2 id="完善重签名脚本"><a href="#完善重签名脚本" class="headerlink" title="完善重签名脚本"></a>完善重签名脚本</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Type a script or drag a script file from your workspace to insert its path.</span></span><br><span class="line"><span class="comment">#exit 0</span></span><br><span class="line">SOURCE_APP_PATH=$(<span class="built_in">set</span> -- <span class="string">&quot;<span class="variable">$&#123;SRCROOT&#125;</span>/&quot;</span>*.app;<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="string">&quot;<span class="variable">$SOURCE_APP_PATH</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SOURCE_APP_PATH</span> 不存在，结束脚本...&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 源app存在，将编译好的app包中的mobileprovision暂时保存起来</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/embedded.mobileprovision&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/embedded.mobileprovision&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制前先清空编译包路径中的内容</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app&quot;</span> || <span class="literal">true</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app&quot;</span> || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源app包的内容复制到Xcode编译好的包路径中去</span></span><br><span class="line"><span class="built_in">cp</span> -rf <span class="string">&quot;<span class="variable">$SOURCE_APP_PATH</span>/&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 PlugIns Watch com.apple.WatchPlaceholder 文件夹及其内容</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/PlugIns&quot;</span> || <span class="literal">true</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/Watch&quot;</span> || <span class="literal">true</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/com.apple.WatchPlaceholder&quot;</span> || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 SC_Info 文件夹中 Manifest.plist 中与 PlugIns 相关的字符串。。。这样删除太麻烦，干脆直接干掉整个文件夹</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/SC_Info&quot;</span> || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 CFBundleIdentifier</span></span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">&quot;Set :CFBundleIdentifier <span class="variable">$PRODUCT_BUNDLE_IDENTIFIER</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/Info.plist&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 MachO 文件上执行权限</span></span><br><span class="line">APP_BINARY=`plutil -convert xml1 -o - $(<span class="built_in">pwd</span>)/<span class="variable">$&#123;WRAPPER_NAME&#125;</span>/Info.plist | grep -A1 Exec | <span class="built_in">tail</span> -n1 | <span class="built_in">cut</span> -f2 -d\&gt; | <span class="built_in">cut</span> -f1 -d\&lt;`</span><br><span class="line"><span class="built_in">chmod</span> +x <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/<span class="variable">$&#123;APP_BINARY&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将暂存的 mobileprovision 放回包中</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/embedded.mobileprovision&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/embedded.mobileprovision&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新图标，这一步不是必须的</span></span><br><span class="line">APPICON=$(find <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/&quot;</span> -<span class="built_in">type</span> f -name <span class="string">&quot;AppIcon*&quot;</span> | <span class="built_in">head</span> -n 1 | xargs -I &#123;&#125; <span class="built_in">basename</span> &#123;&#125;)</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">&quot;Delete :CFBundleIcons&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/Info.plist&quot;</span></span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">&quot;Add :CFBundleIconFiles array&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/Info.plist&quot;</span></span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">&quot;Add :CFBundleIconFiles: string <span class="variable">$APPICON</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/Info.plist&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 Frameworks 注入</span></span><br><span class="line"><span class="comment"># 确保目标目录存在</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/Frameworks&quot;</span></span><br><span class="line"><span class="comment"># 复制所有 .framework 文件夹到目标目录</span></span><br><span class="line"><span class="keyword">for</span> framework <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>&quot;</span>/*.framework; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> -R <span class="string">&quot;<span class="variable">$framework</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/Frameworks/&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>使用脚本完成上面的所有操作步骤，以后我们就只需要将砸壳后的 app 包放入工程的根目录下就可以实现以上这些步骤完成重签名进行调试了。</p>
<p>微信作为社交聊天类数一数二的 App，它自然会对 App 进行重签名等一些其他的检测，所以如果你没有办法绕过它的检测的话，还是不建议使用这种方式登录账号的，被检测到后会被封号，当然是可以通过申诉的方式找回的。作者也在下一篇文章代码注入中提供了一段反检测代码，不保证长期有效，但至少目前是没有问题的。</p>
<p>这段脚本只是最简单的重签名，像 MonkeyApp 这样的工具的原理就是利用 Xcode 的编译脚本实现的。它的实现更加复杂，也增加的更多的功能，如注入动态库等功能。</p>
<p>对于某些安全性更高的 App，即使你使用这种方法重签名了，依旧无法调试，那是因为做了反调试保护。如抖音，支付宝，小红书之类的。不过有反调试也会有反反调试，这些内容作者也会在后续的文章中讲解。</p>
<p>那我们讲解这种重签名的目的是什么？当然是探索 MonkeyDev 的实现原理，同时也为了后面的代码注入内容做准备。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 底层知识入门</title>
    <url>/2025/04/24/iOS-%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="iOS-底层知识入门"><a href="#iOS-底层知识入门" class="headerlink" title="iOS 底层知识入门"></a>iOS 底层知识入门</h1><p>很多讲 iOS 底层知识的课程，视频，文章，讲师上来就是一个  <code>struct objc_object &#123;...&#125;</code> 结构体或者是 <code>struct objc_class : objc_object &#123;...&#125;</code> 的结构体，我不知道其他人是怎么想的，但是对于我本人来说，第一次接触的感觉是一脸懵逼，这两个结构体是干什么的？平时开发过程中从来没有接触和使用过它们啊？</p>
<p>还有很多讲师为了卖自己的课程，宣称学习 iOS 底层知识完全不需要 C++ 语言知识。跟着他的课程就能掌握。。。我作为一个过来人，真的是想骂人，如果你是个完全没有任何一点 C++ 基础的 iOS 开发者想要深入学习 iOS 的底层知识，我的建议还是先将 C++ 的一些基础知识过一遍再说吧。对于一个有开发经验的程序员来说，学习一门编程语言的基础语法真的不算一件难事。。。何况即使是有 C++ 基础的人也依旧看不明白系统的底层源码，为什么？因为不仅仅需要 C++ 语言的基础知识，还需要掌握 dyld，MachO，动态库共享缓存等底层相关的知识和概念，你才能真正看明白底层代码到底在做些什么。</p>
<p>要回答第一个问题，就不得不提到 Objective-C 语言的基石 –&gt; <code>libobjc.A.dylib</code> 库，也叫 Objective-C 的运行时库，主要由 Objective-C，Objective-C++，C++ 编写，一小部分由汇编，C，Perl 等其他语言编写。可以这么说，如果没有 <code>libobjc.A.dylib</code> 库，就没有 Objective-C 语言。Objective-C 语言无法离开 <code>libobjc.A.dylib</code> 库。当一个 Objective-C 程序启动时，dyld 会先加载 <code>libobjc.A.dylib</code>，并执行其初始化代码，然后才能开始执行程序的 <code>main</code> 函数，没有 <code>libobjc.A.dylib</code> 库 Objective-C 代码无法运行。因为在 Objective-C 中，类的加载、分类的加载、<code>+load</code> 方法等都需要运行时库的支持，这些都是在程序的 main 函数之前就完成的。还有在程序运行过程中的对象内存管理，关联对象，消息发送，消息转发等重要又基础的功能都是由该库完成的。</p>
<p><code>libobjc.A.dylib</code> 是 Objective-C 语言的核心运行时库，也是 iOS&#x2F;macOS 生态中所有 Objective-C 和 Swift 应用的底层基石（少了它不行）。它的作用远不止“支持语法”，而是构建了整个动态对象模型和消息传递机制。<code>struct objc_object &#123;...&#125;</code> 和 <code>struct objc_class : objc_object &#123;...&#125;</code> 两个结构体都是在这个库里面声明和实现的 C++ 结构体。在 Objective-C 1.0 时，它们完全用 C 实现，在后续的 Objective-C 2.0 中使用 C++ 重构以提升性能和添加新的功能。</p>
<p>NSObject 类的实现代码也是在该库里面，苹果开源了这个库的部分实现，你可以在 <a href="https://github.com/apple-oss-distributions/objc4/tags">objc4</a> 下载到源码工程，objc4 工程的编译产物就是 <code>libobjc.A.dylib</code> 库。不过苹果开源的这个工程的是无法正常运行起来的，需要通过一些步骤的配置才能成功运行起来，好在有一个开源的 <a href="https://github.com/RetVal/objc-runtime">项目</a> 帮我们解决了配置 objc4 源码项目的繁琐的步骤，这样就可以在这个源码项目中运行调试底层了。查看 <code>NSObject</code> 的实现代码就会发现，大部分的实现都是调用了 <code>struct objc_object &#123;...&#125;</code> 的方法或者 <code>struct objc_class : objc_object &#123;...&#125;</code> 的方法，是的 C++ 中的结构体和类一样，可以有成员变量可以有对象方法，类方法。也就是说 <code>struct objc_object &#123;...&#125;</code> 是所有的 Objective-C 实例对象的底层结构，<code>struct objc_class : objc_object &#123;...&#125;</code> 是所有的 Objective-C 类对象的底层结构。</p>
<h2 id="libobjc-A-dylib-的完整作用介绍"><a href="#libobjc-A-dylib-的完整作用介绍" class="headerlink" title="libobjc.A.dylib 的完整作用介绍"></a><code>libobjc.A.dylib</code> 的完整作用介绍</h2><h3 id="一、​​对象生命周期管理"><a href="#一、​​对象生命周期管理" class="headerlink" title="一、​​对象生命周期管理"></a>一、​​对象生命周期管理</h3><ol>
<li>对象内存分配与释放<ul>
<li>通过 <code>objc_allocateClassPair</code> 和 <code>class_createInstance</code> 动态创建类和对象。</li>
<li>管理对象的引用计数（Retain&#x2F;Release），包括自动引用计数（ARC）的底层实现。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id obj = class_createInstance([NSObject class], <span class="number">0</span>); <span class="comment">// 创建实例</span></span><br><span class="line">objc_retain(obj); <span class="comment">// 增加引用计数</span></span><br><span class="line">objc_release(obj); <span class="comment">// 释放对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>类与元类（Metaclass）系统<ul>
<li>维护 <code>Class</code> 和 <code>Meta Class</code> 的继承链，确保方法查找的层级正确性。</li>
<li>每个类的 <code>isa</code> 指针指向其元类，元类的 <code>isa</code> 指向根元类（Root Metaclass）。</li>
</ul>
</li>
</ol>
<h3 id="二、​​消息传递机制（Messaging）​"><a href="#二、​​消息传递机制（Messaging）​" class="headerlink" title="二、​​消息传递机制（Messaging）​"></a>二、​​消息传递机制（Messaging）​</h3><ol>
<li>动态方法调用<ul>
<li>实现 <code>objc_msgSend</code> 函数（汇编优化），负责方法查找、缓存和跳转。</li>
<li>方法缓存（Method Cache）加速高频调用的方法。</li>
</ul>
</li>
<li>消息转发（Message Forwarding）<ul>
<li>处理未实现方法的动态解析（<code>resolveInstanceMethod:</code>）、备用接收者（<code>forwardingTargetForSelector:</code>）和完整转发（<code>forwardInvocation:</code>）。</li>
<li>支持 <code>@dynamic</code> 属性的延迟绑定（如 Core Data 模型）。</li>
</ul>
</li>
</ol>
<h3 id="三、运行时类型系统-（Runtime-Type-System）"><a href="#三、运行时类型系统-（Runtime-Type-System）" class="headerlink" title="三、运行时类型系统 （Runtime Type System）"></a>三、运行时类型系统 （Runtime Type System）</h3><ol>
<li>类型信息注册与查询<ul>
<li>管理类的属性（<code>class_copyPropertyList</code>）、方法（<code>class_copyMethodList</code>）、协议（<code>class_copyProtocolList</code>）和成员变量（<code>class_copyIvarList</code>）。</li>
<li>支持运行时动态创建&#x2F;修改类（<code>objc_registerClassPair</code>）。</li>
</ul>
</li>
<li>类型编码（Type Encoding）<ul>
<li>将 Objective-C 类型转换为 C 字符串编码（如 <code>@encode(NSInteger)</code> → <code>&quot;q&quot;</code>），用于序列化和反射。</li>
<li>实现 <code>NSMethodSignature</code> 的方法签名解析。</li>
</ul>
</li>
</ol>
<h3 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h3><ol>
<li>自动释放池（Autorelease Pool）<ul>
<li>通过 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 管理延迟释放的对象。</li>
<li>每个线程的自动释放池栈由 <code>libobjc</code> 维护。</li>
</ul>
</li>
<li>弱引用（Weak References）<ul>
<li>管理弱引用表（Weak Table），实现 <code>__weak</code> 变量的自动置 <code>nil</code>。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">id __weak weakObj = strongObj; <span class="comment">// 弱引用表插入记录</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>关联对象（Associated Objects）<ul>
<li>通过 <code>objc_setAssociatedObject</code> 动态绑定键值对到对象（类似“扩展属性”）。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">objc_setAssociatedObject(obj, key, value, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="五、协议与分类（Protocol-Category）​"><a href="#五、协议与分类（Protocol-Category）​" class="headerlink" title="五、协议与分类（Protocol &amp; Category）​"></a>五、协议与分类（Protocol &amp; Category）​</h3><ol>
<li>协议动态注册<ul>
<li>支持运行时添加协议方法（<code>protocol_addMethodDescription</code>）。</li>
</ul>
</li>
<li>分类（<code>Category</code>）合并<ul>
<li>在 <code>attachCategories</code> 函数中，将分类的方法、属性和协议合并到主类。</li>
<li>分类的方法会覆盖主类的同名方法。</li>
</ul>
</li>
</ol>
<h3 id="六、异常处理"><a href="#六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h3><ol>
<li>Objective-C 异常模型<ul>
<li>实现 <code>@try/@catch/@finally</code> 的异常捕获机制。</li>
<li>与 C++ 异常交互（通过 <code>OBJC_USE_OBJC_EXCEPTIONS </code> 配置）。</li>
</ul>
</li>
<li>错误处理桥接<ul>
<li>将 <code>NSError</code> 的 <code>errorWithDomain:code:userInfo:</code> 映射到底层异常。</li>
</ul>
</li>
</ol>
<h3 id="七、底层性能优化"><a href="#七、底层性能优化" class="headerlink" title="七、底层性能优化"></a>七、底层性能优化</h3><ol>
<li>方法缓存（Method Cache）<ul>
<li>每个类维护一个哈希表缓存已查找的方法（<code>objc_cache</code>）。</li>
</ul>
</li>
<li>Tagged Pointer 优化<ul>
<li>将小对象（如 <code>NSNumber</code>、<code>NSDate</code>）直接编码到指针中，避免堆内存分配。</li>
</ul>
</li>
<li>非脆弱实例变量（Non-Fragile IVars）<ul>
<li>允许子类安全扩展父类的实例变量，避免二进制兼容性问题。</li>
</ul>
</li>
</ol>
<h3 id="八、​​与-Swift-的交互"><a href="#八、​​与-Swift-的交互" class="headerlink" title="八、​​与 Swift 的交互"></a>八、​​与 Swift 的交互</h3><ol>
<li>Swift 类的 Objective-C 兼容性<ul>
<li>为 <code>@objc</code> 修饰的 Swift 类生成 Objective-C 元数据（如 <code>_TtC</code> 前缀的类名）。</li>
</ul>
</li>
<li>动态特性支持<ul>
<li>实现 Swift 的 <code>dynamic</code> 方法调用（通过 <code>objc_msgSend</code>）。</li>
</ul>
</li>
<li>内存模型桥接<ul>
<li>Swift 引用计数与 Objective-C ARC 共享同一套底层计数器。</li>
</ul>
</li>
</ol>
<h3 id="九、​​调试与内省（Introspection）​"><a href="#九、​​调试与内省（Introspection）​" class="headerlink" title="九、​​调试与内省（Introspection）​"></a>九、​​调试与内省（Introspection）​</h3><ol>
<li>动态调试工具支持<ul>
<li>提供 <code>class_getName</code>、<code>method_getImplementation</code> 等函数供 LLDB 使用。</li>
</ul>
</li>
<li>运行时环境变量<ul>
<li>通过 <code>OBJC_PRINT_LOAD_METHODS</code> 等环境变量输出运行时日志。</li>
</ul>
</li>
<li>逆向工程基础<ul>
<li><code>class-dump</code> 等工具依赖 <code>libobjc</code> 的类信息导出功能。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>libobjc.A.dylib</code> 是 Objective-C 动态特性的实现核心，其作用覆盖：</p>
<ul>
<li><strong>对象模型</strong>​​：从内存分配到消息传递的完整生命周期管理</li>
<li><strong>动态性</strong>​​：方法转发、关联对象、分类合并等运行时魔法</li>
<li><strong>性能</strong>​​：方法缓存、Tagged Pointer、非脆弱 IVars 等底层优化</li>
<li><strong>跨语言</strong>​​：为 Swift 提供动态能力与内存模型兼容性</li>
</ul>
<p>即使 Apple 推动 Swift 取代 Objective-C，<code>libobjc</code> 在可预见的未来仍不可替代。它如同操作系统的“神经系统”，将高级语言代码翻译为可执行的动态行为。理解其原理，是掌握 iOS&#x2F;macOS 开发生态的关键。</p>
<h1 id="关于运行时"><a href="#关于运行时" class="headerlink" title="关于运行时"></a>关于运行时</h1><p><strong>运行时（Runtime）</strong>​​ 是程序在运行时所依赖的环境和机制，负责管理内存、方法调用、类型检查、异常处理、动态行为等底层操作。它的核心作用是在程序执行期间提供动态支持，而不仅仅是编译时静态确定的逻辑。</p>
<h2 id="为什么-Objective-C-需要运行时？​"><a href="#为什么-Objective-C-需要运行时？​" class="headerlink" title="为什么 Objective-C 需要运行时？​"></a>为什么 Objective-C 需要运行时？​</h2><p>Objective-C 是一种​​动态语言​​，它的许多特性依赖运行时实现：</p>
<ol>
<li>动态消息分发​​：<br> Objective-C 的方法调用（如 <code>[obj doSomething]</code>）本质是通过运行时调用发送消息函数（<code>objc_msgSend</code>）。运行时在程序执行期间动态查找方法实现（甚至允许动态添加&#x2F;替换方法），而非编译时绑定。ß∑</li>
<li>​​运行时类型检查和反射​​：<br> 支持通过 <code>NSClassFromString</code> 动态加载类、<code>isKindOfClass</code> 检查类型、<code>respondsToSelector</code> 判断方法是否存在。</li>
<li>​​方法交换（Method Swizzling）​​：<br> 允许在运行时交换两个方法的实现（常用于调试或 AOP 编程）。</li>
<li>动态协议和类扩展​​：<br> 通过运行时 API（如 <code>class_addMethod</code>）动态添加方法或属性到已有类。</li>
</ol>
<h2 id="所有语言都需要一个运行时吗？​"><a href="#所有语言都需要一个运行时吗？​" class="headerlink" title="所有语言都需要一个运行时吗？​"></a>所有语言都需要一个运行时吗？​</h2><p>是的，但运行时的形式和复杂度差异极大：</p>
<ol>
<li>低级语言（如 C）​​：<br> 运行时极简，通常仅包含标准库（如 <code>libc</code>），负责内存分配（<code>malloc</code>）、文件操作等基础功能。动态行为（如多态）需手动实现。</li>
<li>静态编译语言（如 C++、Rust）​​：<br> 运行时主要处理异常、虚函数表（vtable）等，大部分逻辑在编译时确定，性能高但灵活性较低。</li>
<li>​​动态语言（如 Python、JavaScript）​​：<br> 运行时复杂，负责解释执行、垃圾回收、动态类型检查等。例如 Python 的 <code>sys</code> 模块、JS 引擎（如 V8）都是运行时的核心。</li>
<li>虚拟机语言（如 Java、C#）​​：<br> 依赖虚拟机（JVM、CLR）作为运行时环境，提供跨平台执行、即时编译（JIT）、垃圾回收等高级功能。</li>
<li>特殊场景语言（如 Go）​​：<br> Go 的运行时管理协程（goroutine）、垃圾回收和网络轮询器，但最终编译为静态二进制文件。</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>​​<strong>运行时存在的必要性​​</strong>：所有语言都需要运行时支持，只是其职责和复杂度因语言设计目标而异。</li>
<li><strong>Objective-C 的特殊性</strong>​​：其动态特性（如消息传递、反射）高度依赖运行时，而类似 C++ 的静态语言则在编译时完成更多工作。</li>
<li><strong>性能与灵活性的权衡</strong>​​：运行时越复杂（如动态语言），开发效率越高，但可能牺牲性能；反之，运行时越简单（如 C），性能更高但灵活性受限。</li>
</ul>
<h1 id="Clang-是如何处理-Objective-C-源码的"><a href="#Clang-是如何处理-Objective-C-源码的" class="headerlink" title="Clang 是如何处理 Objective-C 源码的"></a>Clang 是如何处理 Objective-C 源码的</h1><p>Clang 是 LLVM 项目的一部分，主要用于 C、C++ 和 Objective-C 的编译。Objective-C 的类和对象在经过 Clang 编译后确实会被转换为 C 语言的结构体和函数，但这种转换并不是简单的“一对一映射”，而是通过 ​​Objective-C Runtime（运行时机制）​​ 的复杂设计实现的。以下是具体细节：</p>
<ol>
<li>​​对象和类的本质：C 结构体​<br> 所有 Objective-C 对象和类的底层实现都基于 C 结构体：<ul>
<li><strong>实例</strong>：本质是 <code>objc_object</code> 结构体，核心成员是 isa 指针（指向所属的类）。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">	Class isa; <span class="comment">// 指向所属的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>类（Class）</strong>：本质是 <code>objc_class</code> 结构体，继承自 <code>objc_object</code>，因此类本身也是一个对象（称为“类对象”）。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    Class superclass;              <span class="comment">// 父类指针</span></span><br><span class="line">    <span class="type">cache_t</span> cache;                 <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;        <span class="comment">// 存储方法列表、属性列表等</span></span><br><span class="line">    <span class="comment">// ...方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>​​成员变量（ivar）和属性的处理​<ul>
<li><strong>成员变量</strong>​​：直接存储在对象的结构体中。<br>  例如，定义一个 <code>Person</code> 类：  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">	<span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
  编译后，成员变量 <code>_name</code> 和属性自动合成的 <code>_age</code> 会被合并到 <code>Person</code> 对象的结构体中：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person_IMPL</span> &#123;</span></span><br><span class="line">    Class isa;         <span class="comment">// 继承自 objc_object</span></span><br><span class="line">    NSString *_name;   <span class="comment">// 成员变量</span></span><br><span class="line">    NSInteger _age;    <span class="comment">// 属性合成的成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>属性</strong>​​：编译器会自动生成 ​​<strong>getter&#x2F;setter</strong> 方法​​，并转换为 C 函数。例如：   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动生成的 getter 和 setter 函数</span></span><br><span class="line">NSInteger <span class="title function_">Person_getAge</span><span class="params">(Person *self, SEL _cmd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Person_setAge</span><span class="params">(Person *self, SEL _cmd, NSInteger age)</span> &#123;</span><br><span class="line">    self-&gt;_age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>​​对象方法和类方法的处理​<ul>
<li><strong>对象方法</strong>​​：被编译为 C 函数，并存储在类的方法列表中（<code>class_data_bits_t</code> 中的 <code>method_list_t</code>）。<br>  例如，一个 <code>Person</code> 类的方法：  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">\- (<span class="type">void</span>)sayHello &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  会被编译为：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Person_sayHello</span><span class="params">(Person *self, SEL _cmd)</span> &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  该方法会被添加到 <code>Person</code> 类的 <code>method_list_t</code> 中。</li>
<li><strong>类方法</strong>：一样被编译为 C 函数，但存储在 <code>元类（Meta Class）</code> 的方法列表中。<br>  元类是类对象的类，其结构体与 <code>objc_class</code> 一致，但方法列表存储的是类方法。</li>
</ul>
</li>
<li>​​消息发送（方法调用）的底层实现<br> Objective-C 的方法调用（如 <code>[obj method]</code>）会被编译器转换为 <code>objc_msgSend</code> 函数： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码中的方法调用</span></span><br><span class="line">[person sayHello];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后转换为：</span></span><br><span class="line">objc_msgSend(person, @selector(sayHello));</span><br></pre></td></tr></table></figure>
 <code>objc_msgSend</code> 的底层逻辑是动态查找方法实现，以下只是个精简版本的大概步骤：<ol>
<li>通过 <code>isa</code> 指针找到对象的类</li>
<li>在类的方法缓存中查找 <code>sayHello</code> 方法</li>
<li>在类的方法列表中查找 <code>sayHello</code> 方法</li>
<li>若未找到，沿着继承链向父类查找</li>
<li>后续处理…</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 逆向与安全导航</title>
    <url>/2025/02/21/iOS-%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<h1 id="制作中。。。"><a href="#制作中。。。" class="headerlink" title="制作中。。。"></a>制作中。。。</h1>]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iPhoneX上pop回到根控制器上漂移的bug</title>
    <url>/2018/04/28/iPhoneX%E4%B8%8Apop%E5%9B%9E%E5%88%B0%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E6%BC%82%E7%A7%BB%E7%9A%84bug/</url>
    <content><![CDATA[<p>记录一个在 iPhone X 上发生的诡异的 bug…语言怎么描述都太苍白,那么直接看图</p>
<img src="/2018/04/28/iPhoneX%E4%B8%8Apop%E5%9B%9E%E5%88%B0%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E6%BC%82%E7%A7%BB%E7%9A%84bug/BrowserPreview_tmp201804281808.gif" class="">

<p>只有在滑动到最底部的时候,push 到下一个页面,然后在 pop 回来就会出现 contentOffset.y 值自动偏移的现象…</p>
<p>视图的层次结构如图:</p>
<img src="/2018/04/28/iPhoneX%E4%B8%8Apop%E5%9B%9E%E5%88%B0%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E6%BC%82%E7%A7%BB%E7%9A%84bug/Snip20180428_1.png" class="">

<p>选中的视图控制器就是 TabBarController 的第二个子控制器,控制器的 view 就是一个 UICollectionView;我是很懵逼的…同事说可能是 iPhone X 上的安全距离的原因(但我还是很懵逼)…于是我对视图层次结构做了下修改;</p>
<ul>
<li>取消修改控制器的 view 为 UICollectionView</li>
<li>将 UICollectionView 作为控制器的 view 的子视图</li>
<li>设置 collectionView 的约束为,上左右等于控制器的 view,下等于控制器的 view 的下面,但是偏移一个 -34 的高度(仅在 iPhone X 上)</li>
</ul>
<p>修改之后的视图层次结构如下:</p>
<img src="/2018/04/28/iPhoneX%E4%B8%8Apop%E5%9B%9E%E5%88%B0%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E6%BC%82%E7%A7%BB%E7%9A%84bug/Snip20180428_2.png" class="">

<p>这样,collectionView 不再漂移了…对上述偏移的值进行修改测试可以发现,当这个值小于等于 -34 的时候就不会发生漂移,大于 -34 时就会发生漂移…换一句话的意思就是,如果 collectionView 距离底部的距离小于 34 的那么就会漂移,大于等于 34 不会发生漂移…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS反调试与反反调试</title>
    <url>/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="反调试原理"><a href="#反调试原理" class="headerlink" title="反调试原理"></a>反调试原理</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>​​ptrace (Process Trace)​​ 是 Linux（以及其他一些类 Unix 系统，如 macOS）提供的一个极其强大且底层的​​系统调用​​。它的核心功能是​​允许一个进程（称为 tracer）观察和控制另一个进程（称为 tracee）的执行，并能检查和修改该进程的内存和寄存器。​​</p>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ol>
<li>追踪器的介入 (Tracer&#x2F;Tracee):<ul>
<li>一个进程（如 gdb, strace）调用 ptrace 并指定 PTRACE_ATTACH 或 PTRACE_TRACEME 来开始追踪另一个目标进程。</li>
<li>被追踪的进程 (tracee) 就进入了特殊的状态。每当发生特定事件（尤其是系统调用或信号传递）时，内核会暂停 (SIGSTOP) tracee 的执行，并通知 tracer。</li>
</ul>
</li>
<li>​​观察和控制执行:<ul>
<li>​​单步执行 (Stepping):​​ Tracer 可以让 tracee 执行一条机器指令 (PTRACE_SINGLESTEP, PTRACE_STEP)，然后再次暂停，让 tracer 有机会检查状态。</li>
<li>​​设置断点:​​ Tracer 可以修改 tracee 的代码（在内存中），通常是通过替换目标地址的指令为一个特殊的陷阱指令（如 int 3）。当 tracee 执行到此处时，会触发一个信号并暂停，交给 tracer 处理。之后 tracer 恢复原指令，并可能继续执行或单步。</li>
<li>​​拦截系统调用:​​<ul>
<li>Tracer 可以要求在 tracee 即将进入系统调用 (PTRACE_SYSCALL) 或刚从系统调用返回时暂停。</li>
<li>strace 工具就是利用这点来打印出 tracee 进行了哪些系统调用以及参数、返回值。</li>
<li>Tracer 甚至可以修改进入系统调用时的寄存器参数（从而改变系统调用行为）或者修改系统调用的返回值。</li>
</ul>
</li>
</ul>
</li>
<li>​​检查和修改内存和寄存器:​​<ul>
<li>Tracer 可以读写 tracee 的内存 (PTRACE_PEEKDATA, PTRACE_POKEDATA)，包括代码段和数据段。</li>
<li>Tracer 可以读写 tracee 的 CPU 寄存器 (PTRACE_GETREGS, PTRACE_SETREGS, PTRACE_GETFPREGS, PTRACE_SETFPREGS)。</li>
</ul>
</li>
<li>处理信号:​<ul>
<li>当有信号要发送给 tracee 时，内核会先暂停 tracee，并通过 wait() 通知 tracer。</li>
<li>​​Tracer 有决定权:​​<ul>
<li>忽略这个信号：不让它传递给 tracee。</li>
<li>将信号传递给 tracee，让它处理。</li>
<li>注入一个自定义的信号给 tracee。</li>
<li>在这个过程中修改信号的行为。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="主要应用场景"><a href="#主要应用场景" class="headerlink" title="主要应用场景"></a>主要应用场景</h3><ol>
<li>​​调试器 (Debuggers):​​ 这是最经典的用途。像 gdb 就是利用 ptrace 来实现设置断点、单步执行、检查变量（内存）、查看寄存器值等核心调试功能。</li>
<li>​​系统调用追踪器 (System Call Tracers):​​ strace 和 ltrace 这些工具完全依赖 ptrace 来拦截进程调用的系统调用和库函数，并打印相关信息，用于诊断和分析程序行为。</li>
<li>​​代码插桩 (Instrumentation):​​ 在运行时修改程序代码或注入代码片段，用于性能分析（Profiling）、测试覆盖率、内存检测（如 AddressSanitizer&#x2F;Valgrind 的部分功能原理）等。</li>
<li>​​沙箱&#x2F;安全工具:​​ 创建受限的执行环境。Tracer 可以监控 tracee 的系统调用，并根据安全策略允许或拒绝某些敏感操作（如访问特定文件、进行网络连接）。</li>
<li>​​进程间控制:​​ 一些特殊场景下需要精细控制另一个进程的执行流。</li>
<li>​​进程注入:​​ 向另一个运行中的进程注入代码或数据。</li>
</ol>
<h3 id="重要特点和注意事项"><a href="#重要特点和注意事项" class="headerlink" title="重要特点和注意事项"></a>重要特点和注意事项</h3><ul>
<li>​​强大而底层:​​ ptrace 给了 tracer 对 tracee 几乎完全的控制权。</li>
<li>​​复杂性:​​ ptrace 接口相对复杂，涉及信号处理、进程状态、内存布局等多个方面，正确使用并不容易。</li>
<li>​​安全性:​​ ptrace 能力强大，通常普通用户只能 ptrace 自己拥有的进程（除非有 CAP_SYS_PTRACE 权限或 YAMA 等安全模块被配置）。恶意使用 ptrace 可被用于攻击或监控其他进程。</li>
<li>​​性能开销:​​ 频繁的 ptrace 操作（如 strace 追踪每个系统调用）会显著降低目标进程的执行速度。</li>
<li>​​不可靠的信号处理:​​ 使用 ptrace 的进程（tracer）在信号处理上需要极其小心，因为 SIGCHLD 等信号的默认行为会被 ptrace 事件干扰。</li>
<li>​​竞争条件:​​ 在设计使用 ptrace 的工具时要特别注意并发和竞争条件。</li>
</ul>
<p>总结:​​ ptrace 是 Linux 系统上一个非常基础的、用于进程间追踪和控制的系统调用。它赋予了调试器 (gdb)、系统调用跟踪器 (strace) 以及其他各种分析、安全和控制工具强大的能力，但同时也非常复杂且需要谨慎使用。理解 ptrace 是深入理解 Linux 下进程执行、调试和系统监控机制的关键。</p>
<h3 id="ptrace-的参数简单介绍"><a href="#ptrace-的参数简单介绍" class="headerlink" title="ptrace 的参数简单介绍"></a>ptrace 的参数简单介绍</h3><p>ptrace 的原型可以在 macOS 中找到，新建一个 macOS 的应用，或者更加简单一点的命令行程序，就可以导入 sys&#x2F;ptrace.h 文件查看函数原型并使用它了。如下图：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250704_2.png" class="">

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SYS_PTRACE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SYS_PTRACE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/appleapiopts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/cdefs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	ePtAttachDeprecated __deprecated_enum_msg(<span class="string">&quot;PT_ATTACH is deprecated. See PT_ATTACHEXC&quot;</span>) = <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_ME     0       <span class="comment">/* child declares it&#x27;s being traced */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_READ_I       1       <span class="comment">/* read word in child&#x27;s I space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_READ_D       2       <span class="comment">/* read word in child&#x27;s D space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_READ_U       3       <span class="comment">/* read word in child&#x27;s user structure */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_WRITE_I      4       <span class="comment">/* write word in child&#x27;s I space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_WRITE_D      5       <span class="comment">/* write word in child&#x27;s D space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_WRITE_U      6       <span class="comment">/* write word in child&#x27;s user structure */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_CONTINUE     7       <span class="comment">/* continue the child */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_KILL         8       <span class="comment">/* kill the child process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_STEP         9       <span class="comment">/* single step the child */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ATTACH       ePtAttachDeprecated     <span class="comment">/* trace some running process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DETACH       11      <span class="comment">/* stop tracing a process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SIGEXC       12      <span class="comment">/* signals as exceptions for current_proc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_THUPDATE     13      <span class="comment">/* signal for thread# */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ATTACHEXC    14      <span class="comment">/* attach to running process with signal exception */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_FORCEQUOTA   30      <span class="comment">/* Enforce quota for root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DENY_ATTACH  31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_FIRSTMACH    32      <span class="comment">/* for machine-specific requests */</span></span></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>     ptrace(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data);</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* !_SYS_PTRACE_H_ */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>_request： 最重要的参数，指定要对目标进程 pid 执行的具体操作类型。常用的 request 包括：<ul>
<li>PT_TRACE_ME：指示本进程希望被其父进程跟踪（通常是调试器启动目标进程时，目标进程主动调用）。</li>
<li>PT_ATTACH: 附着到已运行的 pid 进程上，开始跟踪它。</li>
<li>PT_DETACH: 停止跟踪 pid 目标进程，使其恢复独立运行。</li>
<li>PT_STEP: 设置单步陷阱标志，让目标进程 pid 执行一条指令后暂停。</li>
<li>PT_DENY_ATTACH: 拒绝调试器附加，这正是我们需要传入的参数。</li>
</ul>
</li>
<li>_pid：目标进程的进程 ID。</li>
<li>_addr​​: 内存地址（常用于 READ&#x2F;WRITE DATA，系统调用号过滤器等特定操作）。</li>
<li>_data：指向一个数据缓冲区的指针，其含义取决于 request（如要写入的数据，存储读取数据的结构体地址，信号编号等）。</li>
</ul>
<h3 id="在-iOS-中调用-ptrace-反调试"><a href="#在-iOS-中调用-ptrace-反调试" class="headerlink" title="在 iOS 中调用 ptrace 反调试"></a>在 iOS 中调用 ptrace 反调试</h3><p>在刚刚的 macOS 应用的例子中我们可以直接导入 sys&#x2F;ptrace.h 头文件使用 ptrace 函数。但是到了 iOS 环境是无法直接导入 sys&#x2F;ptrace.h 头文件的，那么自然是无法通过这种方式调用 ptrace 了。但是可以确定的是 iOS 中也的确存在 ptrace 这个函数，只是 iOS 系统没有对外开放。我们可以使用一些绕过限制的方法调用 ptrace。</p>
<h4 id="1-使用-extern"><a href="#1-使用-extern" class="headerlink" title="1. 使用 extern"></a>1. 使用 extern</h4><p>如下图：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250704_3.png" class="">
<p>这样调用之后，使用 Xcode 调试启动 APP 之后就会被断开调试了，也就意味着我们的 APP 现在无法被 lldb 调试器附加了。尝试附加调试会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=demoiOSApp</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process demoiOSApp...</span><br><span class="line">zsh: segmentation fault  debugserver localhost:3333 --attach=demoiOSApp</span><br></pre></td></tr></table></figure>

<p>这种直接使用 ptrace 函数的方式，动态绕过的办法可以使用 fishhook 进行绕过。静态的方法当然是修改汇编指令也可以绕过。以下是使用 fishhook 绕过这种反调试的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;InjectCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;fishhook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*orig_ptrace)(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hook_ptrace(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_request == <span class="number">31</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orig_ptrace(_request, _pid, _addr, _data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">InjectCode</span></span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">struct</span> rebinding one;</span><br><span class="line">        one.name = <span class="string">&quot;ptrace&quot;</span>;</span><br><span class="line">        one.replaced = (<span class="type">void</span>*)&amp;orig_ptrace;</span><br><span class="line">        one.replacement = hook_ptrace;</span><br><span class="line">        <span class="keyword">struct</span> rebinding array[] = &#123;one&#125;;</span><br><span class="line">        rebind_symbols(array, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="2-利用-dlsym"><a href="#2-利用-dlsym" class="headerlink" title="2. 利用 dlsym"></a>2. 利用 dlsym</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> (*ptrace_t)(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data);</span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="type">void</span> *handle = dlopen(<span class="number">0</span>, RTLD_GLOBAL | RTLD_NOW);</span><br><span class="line">    ptrace_t ptrace = dlsym(handle, <span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">    ptrace(<span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 dlsym 函数动态获取 ptrace 的函数调用。这种方式调用 ptrace 的话，动态的方法就无法使用 fishhook hook ptrace 绕过反调试了，但是可以通过 fishhook hook dlsym 函数的方式绕过，还可以利用 lldb 实现汇编级别的 hook 实现绕过。静态的方法同样是修改汇编指令绕过。</p>
<h4 id="3-使用-syscall-的方式"><a href="#3-使用-syscall-的方式" class="headerlink" title="3. 使用 syscall 的方式"></a>3. 使用 syscall 的方式</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    syscall(<span class="number">26</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 syscall 函数，通过传入第一个参数值 26 代表调用的 ptrace 函数，后续的参数就是 ptrace 所需的参数，而 31 正是 PT_DENY_ATTACH。这种方式也无法简单的通过 fishhook 绕过反调试。还可以使用 lldb 进行汇编指令级 hook 实现动态绕过。静态的方式依旧是修改汇编指令。</p>
<h4 id="4-使用内联汇编的方式"><a href="#4-使用内联汇编的方式" class="headerlink" title="4. 使用内联汇编的方式"></a>4. 使用内联汇编的方式</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">	</span><br><span class="line">    __asm__ <span class="keyword">volatile</span>(</span><br><span class="line">        <span class="string">&quot;mov x0, #0x1f\n&quot;</span>   <span class="comment">// PT_DENY_ATTACH 的值 (31)</span></span><br><span class="line">        <span class="string">&quot;mov x1, #0x0\n&quot;</span>    <span class="comment">// 第二个参数 (0)</span></span><br><span class="line">        <span class="string">&quot;mov x2, #0x0\n&quot;</span>    <span class="comment">// 第三个参数 (0)</span></span><br><span class="line">        <span class="string">&quot;mov x3, #0x0\n&quot;</span>    <span class="comment">// 第四个参数 (0)</span></span><br><span class="line">        <span class="string">&quot;mov x16, #0x1a\n&quot;</span>  <span class="comment">// ptrace 的系统调用号 (26)</span></span><br><span class="line">        <span class="string">&quot;svc #0x80&quot;</span>         <span class="comment">// 执行系统调用</span></span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式调用 ptrace，动态的绕过方式使用 fishhook 肯定是不行的，但是可以使用 lldb 汇编级 hook 绕过。而静态的方式当然依旧是分析并修改汇编代码。</p>
<p>以上 4 种方式都是直接或间接的调用 ptrace 函数来实现反调试。<del>iOS 内核已加强对 ptrace 的管控，非越狱环境下调用受限，开发者需依赖私有 API 或漏洞利用。</del>单一 ptrace 易被破解，通常需结合：</p>
<ul>
<li>sysctl 定期检测​​：轮询进程状态标志位（如 P_TRACED），发现调试则主动退出或相应的处理。</li>
<li>代码混淆​​：隐藏反调试逻辑，增加逆向分析难度。</li>
</ul>
<p>在 macOS&#x2F;iOS 中，ptrace 的核心价值在于​​主动阻断调试器附加​​，但需结合动态加载、系统调用和混淆技术提升可靠性。反调试本质是攻防对抗的持续升级，单一措施不足以保证绝对安全，需多层防护策略。</p>
<h2 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h2><p>sysctl 是一个用于动态配置内核参数的命令行工具同时也是一个可供编程的函数接口，在类 Unix 系统（如 Linux、FreeBSD）及 Apple 生态系统（macOS、iOS）中广泛使用，但不同平台的作用范围和权限限制存在显著差异。以下是具体分析：</p>
<h3 id="类-Unix-系统（Linux-BSD）中的作用​"><a href="#类-Unix-系统（Linux-BSD）中的作用​" class="headerlink" title="类 Unix 系统（Linux&#x2F;BSD）中的作用​"></a>类 Unix 系统（Linux&#x2F;BSD）中的作用​</h3><p>sysctl 通过操作 &#x2F;proc&#x2F;sys&#x2F; 虚拟文件系统实现内核参数的实时调整，无需重启系统。核心功能包括：</p>
<ol>
<li>​​动态调优性能​​<ul>
<li>​​网络优化​​：调整 TCP 连接队列（net.core.somaxconn）、缓冲区大小（net.ipv4.tcp_rmem）、SYN Flood 防御（net.ipv4.tcp_syncookies&#x3D;1）。</li>
<li>​​内存管理​​：控制 Swap 使用倾向（vm.swappiness&#x3D;10）、脏页写回策略（vm.dirty_ratio）。</li>
<li>​​文件系统​​：设置最大文件句柄数（fs.file-max&#x3D;2097152）。</li>
</ul>
</li>
<li>功能启停<ul>
<li>启用 IP 转发（net.ipv4.ip_forward&#x3D;1），将主机配置为路由器。</li>
<li>禁用 ICMP 响应（net.ipv4.icmp_echo_ignore_all&#x3D;1）以提升安全性。</li>
</ul>
</li>
<li>持久化配置<ul>
<li>参数写入 &#x2F;etc&#x2F;sysctl.conf 或 &#x2F;etc&#x2F;sysctl.d&#x2F;*.conf，通过 sysctl -p 加载。</li>
</ul>
</li>
</ol>
<h3 id="macOS-中的特殊性与限制​"><a href="#macOS-中的特殊性与限制​" class="headerlink" title="macOS 中的特殊性与限制​"></a>macOS 中的特殊性与限制​</h3><p>macOS 继承 BSD 的 sysctl 实现，但存在平台差异：</p>
<ol>
<li>配置方式<ul>
<li>默认无 &#x2F;etc&#x2F;sysctl.conf，需手动创建并加载（sudo sysctl -p）。</li>
<li>部分参数需通过 ​​launchd​​ 持久化（如修改 maxfiles 限制需编辑 &#x2F;etc&#x2F;launchd.conf）。</li>
</ul>
</li>
<li>系统完整性保护（SIP）<ul>
<li>macOS Big Sur 及以上版本中，修改核心参数（如 kern.ipc 系列）需​​关闭 SIP​​，否则操作被拦截。</li>
</ul>
</li>
<li>典型用例<ul>
<li>调整 Socket 队列（kern.ipc.somaxconn）、虚拟内存参数（vm.swappiness）。</li>
</ul>
</li>
</ol>
<h3 id="iOS-中的严格限制​"><a href="#iOS-中的严格限制​" class="headerlink" title="iOS 中的严格限制​"></a>iOS 中的严格限制​</h3><p>iOS 对 sysctl 的访问施加了更严格的安全策略：</p>
<ol>
<li>权限封锁<ul>
<li>多数敏感参数（如 kern.boottime）返回 ​​EPERM 错误​​，禁止用户态进程读取。</li>
<li>仅允许少数“白名单”参数（如设备型号、CPU 核心数）通过公有 API 访问。</li>
</ul>
</li>
<li>合法使用场景<ul>
<li>获取设备运行时间（kern.boottime）用于反欺诈检测（如防止日期篡改），但需 Apple 审核批准。</li>
<li>Apple 建议优先使用公开 API（如 NSProcessInfo），并​​避免依赖未文档化的参数​​。</li>
</ul>
</li>
<li>开发风险<ul>
<li>使用私有 sysctl 可能导致 App 审核被拒，因违反“禁止访问私有接口”条款。</li>
</ul>
</li>
</ol>
<h3 id="在-iOS-中使用-sysctl-检测进程是否被调试"><a href="#在-iOS-中使用-sysctl-检测进程是否被调试" class="headerlink" title="在 iOS 中使用 sysctl 检测进程是否被调试"></a>在 iOS 中使用 sysctl 检测进程是否被调试</h3><p>实现代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isBeingDebugged(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">int</span> name[<span class="number">4</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="built_in">CTL_KERN</span>;</span><br><span class="line">    name[<span class="number">1</span>] = KERN_PROC;</span><br><span class="line">    name[<span class="number">2</span>] = KERN_PROC_PID;</span><br><span class="line">    name[<span class="number">3</span>] = getpid();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> kinfo_proc info;</span><br><span class="line">    size_t infoSize = <span class="keyword">sizeof</span>(info);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sysctl(name, <span class="number">4</span>, &amp;info, &amp;infoSize, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sysctl failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((info.kp_proc.p_flag &amp; P_TRACED) != <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isBeingDebugged()) &#123;</span><br><span class="line">        printf(<span class="string">&quot;检测到调试。。。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printf(<span class="string">&quot;没有被调试。。。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种通过调用 sysctl 函数查询当前进程的一些信息来判断是否被附加调试的方式通常可以结合定时器，或者子线程 sleep 的方式来保持长期的运行。在这种情况下，检测到被调试的时候不建议直接退出当前进程如调用 exit、kill 等，这样的处理属于简单粗暴的方式。实际使用中可以根据需求制定其他的处理方式。</p>
<p>如何绕过这种检测呢？动态的方式当然同样可以使用 fishhook 进行绕过检测，但是这个 hook 方法的实现和一般的 hook 方法实现不一样，这个 hook 方法中需要修改 info 的结果，使其表示是否被调试的标志位始终为 0。具体的 hook 代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;InjectCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;fishhook.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*orig_sysctl)(<span class="type">int</span> *, u_int, <span class="type">void</span> *, size_t *oldlenp, <span class="type">void</span> *, size_t newlen);</span><br><span class="line"><span class="type">int</span> hook_sysctl(<span class="type">int</span> * name, u_int namelen,</span><br><span class="line">                <span class="type">void</span> * info, size_t *infosize,</span><br><span class="line">                <span class="type">void</span> * newInfo, size_t newsize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (namelen == <span class="number">4</span> &amp;&amp;</span><br><span class="line">        name[<span class="number">0</span>] == <span class="built_in">CTL_KERN</span> &amp;&amp;</span><br><span class="line">        name[<span class="number">1</span>] == KERN_PROC &amp;&amp;</span><br><span class="line">        name[<span class="number">2</span>] == KERN_PROC_PID &amp;&amp;</span><br><span class="line">        info &amp;&amp;</span><br><span class="line">        infosize &amp;&amp;</span><br><span class="line">        *infosize == <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kinfo_proc)) &#123;</span><br><span class="line">        <span class="type">int</span> ret = orig_sysctl(name, namelen, info, infosize, newInfo, newsize);</span><br><span class="line">        <span class="keyword">struct</span> kinfo_proc *info_ptr = (<span class="keyword">struct</span> kinfo_proc *)info;</span><br><span class="line">        <span class="comment">// 如果 info_ptr-&gt;kp_proc.p_flag 为 1，那么将它变为 0，因为 1 表示有附加调试</span></span><br><span class="line">        <span class="keyword">if</span> (info_ptr &amp;&amp; (info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) != <span class="number">0</span>) &#123;</span><br><span class="line">            info_ptr-&gt;kp_proc.p_flag ^= P_TRACED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orig_sysctl(name, namelen, info, infosize, newInfo, newsize);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">InjectCode</span></span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">struct</span> rebinding one;</span><br><span class="line">        one.name = <span class="string">&quot;sysctl&quot;</span>;</span><br><span class="line">        one.replaced = (<span class="type">void</span>*)&amp;orig_sysctl;</span><br><span class="line">        one.replacement = hook_sysctl;</span><br><span class="line">        <span class="keyword">struct</span> rebinding array[] = &#123;one&#125;;</span><br><span class="line">        rebind_symbols(array, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>那如何应对 fishhook 这种反反调试呢？当然是不要直接使用 sysctl 这样的函数调用，可以利用 dlsym 动态获取函数实现从而绕过 fishhook，或者使用汇编实现。还有一点值得注意的就是 hook 代码和反 hook 代码的执行顺序问题。</p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><h2 id="如何反制"><a href="#如何反制" class="headerlink" title="如何反制"></a>如何反制</h2><p>总的来说，反制的的手段分为动态的 hook 和静态的修改 MachO 两个方面。</p>
<p>库的先后顺序能影响检测的结果。<br>使用函数指针保存 ptrace，sysctl 地址，使用函数指针调用函数。<br>修改 MachO</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>作者的实战环境是 Mac Pro（macOS 15.3.1），iPhone 8 Plus（iOS 16.7.10）使用 palera1n 的 rootful 越狱。</p>
<h2 id="动态绕过反调试"><a href="#动态绕过反调试" class="headerlink" title="动态绕过反调试"></a>动态绕过反调试</h2><p>这里介绍一个 lldb 插件 <a href="https://github.com/4ch12dy/xia0LLDB">xia0LLDB</a>。提供了一个 debugme 命令可以 hook ptrace 和 inlinehook svc 来绕过反调试。但是在我的环境 iPhone8Plus iOS16.7.10 中想要成功利用 debugme 绕过 iOS 端最新版小红书还是没那么简单，出了点问题，我们来分析一下为什么。</p>
<h3 id="小红书"><a href="#小红书" class="headerlink" title="小红书"></a>小红书</h3><p>这里以作者编写本文时的 iOS 端小红书最新版本(8.88)为例。我们都知道，小红书是做了 lldb 反调试的。直接启动 APP，然后使用 debugserver 附加调试，肯定是附加不成功的。以下为演示：</p>
<p>APP 在前台时尝试附加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=discover</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process discover...</span><br><span class="line">zsh: segmentation fault  debugserver localhost:3333 --attach=discover</span><br></pre></td></tr></table></figure>

<p>而就算把 APP 杀死，如上划杀掉进程，或者使用 kill，killall 命令干掉 APP 进程，再次附加调试也是无法成功的，因为此时进程并不存在。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=discover</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process discover...</span><br><span class="line">error: failed to attach to process named: <span class="string">&quot;&quot;</span></span><br><span class="line">Exiting.</span><br></pre></td></tr></table></figure>

<p>的确存在一种情况，即使做了反调试也可以成功附加的，那就是应用长时间没有打开过了，也不要打开，但是 ps 查看进程依然存在。这个时候可以使用 <code>--attach</code> 附加成功，对的即使做了反调试也能附加成功，只是在附加成功之后 continue 依然会被断开调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line">Process 562 resuming</span><br><span class="line">Process 562 exited with status = 45 (0x0000002d)</span><br></pre></td></tr></table></figure>

<p>或许你在网上曾经看到过 backboard 调试​​（通过 backboard 服务启动应用）时，​​在应用代码执行前暂停​​，以便调试器（LLDB）能附加并运行命令。即以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debugserver *:端口号 -x backboard /应用路径</span><br></pre></td></tr></table></figure>

<p>然而，在 lldb 16.0.0 中，并不存在这个选项了。。。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iPhone8plus:~ root#debugserver -x backboard localhost:3333 /private/var/containers/Bundle/Application/AEE569ED-D421-4274-93EA-72456A764135/discover.app/discover</span><br><span class="line">error: invalid TYPE <span class="keyword">for</span> the --launch=TYPE (-x TYPE) option: <span class="string">&#x27;backboard&#x27;</span></span><br><span class="line">Valid values TYPE are:</span><br><span class="line">  auto       Auto-detect the best launch method to use.</span><br><span class="line">  posix      Launch the executable using posix_spawn.</span><br><span class="line">  fork       Launch the executable using fork and <span class="built_in">exec</span>.</span><br></pre></td></tr></table></figure>

<p>此时，可以使用 debugserver 的 –waitfor 选项来实现在目标应用代码执行前暂停，以便 lldb 能附加并运行命令。就是说 backboard 被 –waitfor 替代了。下面是完整的流程：</p>
<ol>
<li><p>确保目标进程不存在：实现的方式有手动上划掉进程，killall -9 进程名，kill pid 等方式</p>
</li>
<li><p>使用 debugserver 的 –waitfor 选项：</p>
<p> 我这里使用了 iproxy 进行了端口映射，将电脑的 3333 端口和手机的 3333 端口关联了起来，所以可以使用 <code>localhost:3333</code> 作为参数。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --waitfor=discover</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Waiting to attach to process discover...</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p>手指点击启动目标 APP </p>
</li>
<li><p>进入 lldb 调试：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line"></span><br><span class="line">           https://github.com/4ch12dy/xia0LLDB</span><br><span class="line">          Welcome to xia0LLDB - Python3 Edition</span><br><span class="line">          ,--.          ,--.  ,--.   ,--.   ,------.  ,-----.</span><br><span class="line">,--.  ,--.`--<span class="string">&#x27; ,--,--. /    \ |  |   |  |   |  .-.  \ |  |) /_</span></span><br><span class="line"><span class="string"> \  `&#x27;</span>  / ,--.<span class="string">&#x27; ,-.  ||  ()  ||  |   |  |   |  |  \  :|  .-.  \</span></span><br><span class="line"><span class="string"> /  /.  \ |  |\ &#x27;</span>-<span class="string">&#x27;  | \    / |  &#x27;</span>--.|  <span class="string">&#x27;--.|  &#x27;</span>--<span class="string">&#x27;  /|  &#x27;</span>--<span class="string">&#x27; /</span></span><br><span class="line"><span class="string">&#x27;</span>--<span class="string">&#x27;  &#x27;</span>--<span class="string">&#x27;`--&#x27;</span> `--`--<span class="string">&#x27;  `--&#x27;</span>  `-----<span class="string">&#x27;`-----&#x27;</span>`-------<span class="string">&#x27; `------&#x27;</span></span><br><span class="line"></span><br><span class="line">[xia0LLDB] * Version: 3.1</span><br><span class="line">[xia0LLDB] + Loading all scripts from /Users/franky/xia0LLDB/src</span><br><span class="line">[xia0LLDB] * Finished</span><br><span class="line">(lldb) process connect connect://localhost:3333 <span class="comment"># 连接到手机建立的 debugserver</span></span><br><span class="line">Process 3166 stopped</span><br><span class="line">* thread <span class="comment">#1, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000118fb6ed0 dyld`dyld4::PrebuiltLoader::isValid(dyld4::RuntimeState const&amp;) const + 520</span></span><br><span class="line">dyld`dyld4::PrebuiltLoader::isValid:</span><br><span class="line">-&gt;  0x118fb6ed0 &lt;+520&gt;: add    w22, w22, <span class="comment">#0x1</span></span><br><span class="line">    0x118fb6ed4 &lt;+524&gt;: cmp    w22, w9</span><br><span class="line">    0x118fb6ed8 &lt;+528&gt;: b.lo   0x118fb6e64    ; &lt;+412&gt;</span><br><span class="line">    0x118fb6edc &lt;+532&gt;: cbz    x8, 0x118fb6f60 ; &lt;+664&gt;</span><br><span class="line">Target 0: (discover) stopped.</span><br><span class="line">(lldb) croc <span class="comment"># 此时处在 dyld`start 方法中，是一个非常早的阶段，很多镜像都没完成加载，CoreFoundation 都没加载，直接使用 debugme 也是会报错的..所以执行这个命令，这个命令里面其实做的事情也很简单，设置了一个 CFBundleGetMainBundle 的断点，然后继续执行会来到断点，然后删掉所有断点，当断点来到 CFBundleGetMainBundle 后，此时所有镜像都加载完成了。后续的 debugme 命令也能成功运行了</span></span><br><span class="line">[*] going to <span class="built_in">env</span> that can run oc script</span><br><span class="line">1 location added to breakpoint 1</span><br><span class="line">[+] now you can exe oc</span><br><span class="line">(lldb) debugme <span class="comment"># 这个命令核心的作用就是对 ptrace 进行 hook，以及对 svc #80 指令进行 hook，这是通过对 APP 镜像文件以及所属的 Framework 的镜像文件的代码段扫描是否存在 svc #80 指令，如果存在就进行 hook。而 hook 的核心实现原理就是新创建一个内存页存放 hook 代码，同时修改原始指令的内存页跳转到 hook 代码中。</span></span><br><span class="line">[*] start patch ptrace funtion to bypass anti debug</span><br><span class="line">[+] ptrace funtion patach <span class="keyword">done</span></span><br><span class="line">[*] start patch svc ins to bypass anti debug</span><br><span class="line">[+] use <span class="string">&quot;target list&quot;</span> to get main module:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/discover</span><br><span class="line">[*] app <span class="built_in">dir</span>:/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/discover</span><br><span class="line">[*] text start:0x0000000104a48000 end:0x0000000111848630</span><br><span class="line">------&gt;  4550367176</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] start hook svc at address:0x10f3917c8</span><br><span class="line">[+] hook svc at address:0x10f3917c8 <span class="keyword">done</span></span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/A.framework/A</span><br><span class="line">[*] text start:0x0000000118eec6d4 end:0x0000000118eeeb90</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/KasaSDK.framework/KasaSDK</span></span><br><span class="line"><span class="string">[*] text start:0x0000000119bb30c0 end:0x000000011a4291e8</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/TXFFmpeg.framework/TXFFmpeg</span><br><span class="line">[*] text start:0x0000000119245dd4 end:0x000000011936f1c8</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/TXSoundTouch.framework/TXSoundTouch</span></span><br><span class="line"><span class="string">[*] text start:0x0000000118f07764 end:0x0000000118f0bcc0</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/Tquic.framework/Tquic</span><br><span class="line">[*] text start:0x00000001196b6380 end:0x00000001198378d0</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[x] happy debugging~ kill antiDebug by xia0@2019	</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>从打印结果来看，似乎顺利对 discover 的 svc #80 汇编调用进行了 hook，实现了反调试绕过。然后 continue 之后马上就遇到了 signal SIGSYS 信号。。。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line">Process 429 resuming</span><br><span class="line">Process 429 stopped</span><br><span class="line">* thread <span class="comment">#4, queue = &#x27;com.apple.root.user-initiated-qos&#x27;, stop reason = signal SIGSYS</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000010663d140 discover`___lldb_unnamed_symbol272407 + 72</span></span><br><span class="line">discover`___lldb_unnamed_symbol272407:</span><br><span class="line">-&gt;  0x10663d140 &lt;+72&gt;: mov    x8, x0</span><br><span class="line">    0x10663d144 &lt;+76&gt;: cmp    w8, <span class="comment">#0x0</span></span><br><span class="line">    0x10663d148 &lt;+80&gt;: cset   w0, eq</span><br><span class="line">    0x10663d14c &lt;+84&gt;: ldp    x29, x30, [sp, <span class="comment">#0x90]</span></span><br><span class="line">Target 0: (discover) stopped.</span><br><span class="line">(lldb) rr</span><br><span class="line">      x0 = 0x000000000000004e</span><br><span class="line">      x1 = 0x0000000000000000</span><br><span class="line">      x2 = 0x0000000000000000</span><br><span class="line">      x3 = 0x0000000000000000</span><br><span class="line">      x4 = 0x0000000000000000</span><br><span class="line">      x5 = 0x0000000000000000</span><br><span class="line">      x6 = 0x00000002806ede50</span><br><span class="line">      x7 = 0x0000000000000000</span><br><span class="line">      x8 = 0x00000001160b20ee  <span class="string">&quot;/private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library/Caches/com.apple.MobileGestalt.plist&quot;</span></span><br><span class="line">      x9 = 0x0000000000000000</span><br><span class="line">     x16 = 0x00000001194c4000</span><br><span class="line">      pc = 0x000000010663d140  discover`___lldb_unnamed_symbol272407 + 72</span><br><span class="line">      lr = 0x000000010663d110  discover`___lldb_unnamed_symbol272407 + 24</span><br><span class="line">      sp = 0x000000016bbe5730</span><br></pre></td></tr></table></figure>

<p>借助 AI 我们很容易知道，SIGSYS 是发生了系统调用异常，也就是系统调用函数出错，传入了一个非法的参数。。。通过读取寄存器 x16 的值可以发现的确不是一个正常的系统调用参数，正常的系统调用参数值在 0~558 左右之内，可以在 syscall.h 头文件查看。那为什么会出现 x16 变成一个巨大的值呢？这就需要对 debugme 进行好好研究一番了。。。实际确实花费了不少时间和功夫。最终发现出问题的地方在对原始指令的修改，跳转到 hook 代码的地方出了一点儿问题。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> ldr x16, <span class="comment">#0x8</span></span><br><span class="line"> br x16</span><br><span class="line"> hook_code_addr_1</span><br><span class="line"> hook_code_addr_2</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="number">50</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">00</span> 02 1f d6 原作者这里使用 x16 跳转,但是目前在小红书最新版本出现了问题,修改了 x16 的值,导致正常的 svc 调用参数超出范围出现 sigsys 异常</span><br><span class="line"><span class="number">51</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">20</span> 02 1F D6 改用这个 x17 跳转,试试看,没问题!</span><br><span class="line">*/</span><br><span class="line">uint8_t patch_data[] = &#123;<span class="number">0x50</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x1f</span>, <span class="number">0xd6</span>, (uint8_t)(new_p&amp;<span class="number">0xff</span>), (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">1</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">2</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">3</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">4</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">5</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">6</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">7</span>)&amp;<span class="number">0xff</span>)&#125;;</span><br><span class="line"><span class="built_in">int</span> patch_data_size = <span class="number">4</span>*<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>是的，只需要修改 2 个字节，就可以继续使用 xia0LLDB 绕过小红书最新版的反调试了，但是要能知道这 2 个字节在哪，怎么修改还是需要一些的基础的。修改完 debugme.py 之后再次重复前面的步骤进入 lldb 调试，输入 debugme 之后 c (lldb continue 命令的缩写)就能正常运行了。进入页面之后，如果想查看小红书的视图控制器层次结构可以先 process interrupt 中断进程，然后输入 <code>po [[[[UIApplication sharedApplication] keyWindow] rootViewController] _printHierarchy] </code> 就可以查看了。<code>_printHierarchy</code> 是 UIViewController 的私有方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lldb) process  interrupt</span><br><span class="line">Process 11823 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000001c6dd5030 libsystem_kernel.dylib` mach_msg2_trap  + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg2_trap:</span><br><span class="line">-&gt;  0x1c6dd5030 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;macx_swapon:    0x1c6dd5034 &lt;+0&gt;: mov    x16, #-0x30 ; =-48</span></span><br><span class="line"><span class="string">    0x1c6dd5038 &lt;+4&gt;: svc    #0x80</span></span><br><span class="line"><span class="string">    0x1c6dd503c &lt;+8&gt;: ret</span></span><br><span class="line"><span class="string">libsystem_kernel.dylib&#x27;</span>macx_swapoff:    0x1c6dd5040 &lt;+0&gt;: mov    x16, <span class="comment">#-0x31 ; =-49</span></span><br><span class="line">    0x1c6dd5044 &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x1c6dd5048 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;thread_get_special_reply_port:    0x1c6dd504c &lt;+0&gt;: mov    x16, #-0x32 ; =-50</span></span><br><span class="line"><span class="string">Target 0: (discover) stopped.</span></span><br><span class="line"><span class="string">(lldb) po [[[[UIApplication sharedApplication] keyWindow] rootViewController] _printHierarchy]</span></span><br><span class="line"><span class="string">&lt;XYPHNavigationViewController 0x12a03a600&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x12af72ca0&gt;</span></span><br><span class="line"><span class="string">   | &lt;XYPHClassicHomeViewController 0x12af703c0&gt;, state: appeared, view: &lt;UIView: 0x12af16c70&gt;</span></span><br><span class="line"><span class="string">   |    | &lt;XYPHHomeTabbarController 0x12d010e00&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x12af77040&gt;</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12d10a000&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x134438da0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYMHomeViewController 0x12a0a2000&gt;, state: appeared, view: &lt;UIView: 0x12aadca60&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    | &lt;XYPageViewController 0x12a04a800&gt;, state: appeared, view: &lt;UIView: 0x13443d850&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    | &lt;XYEXExploreFeedV2ViewController 0x139317af0&gt;, state: appeared, view: &lt;UIView: 0x13931b4e0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    | &lt;XYPageViewController 0x12d194a00&gt;, state: appeared, view: &lt;UIView: 0x13931c760&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    | &lt;XYEXExploreFeedViewController 0x12b896800&gt;, state: appeared, view: &lt;UIView: 0x12aae9d10&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    | &lt;XYEXExploreFeedChannelViewController 0x12a0bd400&gt;, state: appeared, view: &lt;UIView: 0x134441410&gt;</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12b060400&gt;, state: disappeared, view: &lt;UILayoutContainerView: 0x12ae3a270&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYVideoTab.VideoTabFeedInterface 0x134439580&gt;, state: disappeared, view: &lt;UIView: 0x12aad57c0&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12a0fbc00&gt;, state: disappeared, view: &lt;UILayoutContainerView: 0x12ae2e830&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYPMMessageCenterViewController 0x12d069400&gt;, state: disappeared, view: (view not loaded)</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12a0c4000&gt;, state: disappeared, view: &lt;UILayoutContainerView: 0x12ae2e9d0&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYPFProfileViewController 0x12b057800&gt;, state: disappeared, view: (view not loaded)</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果来看，小红书的根控制器层次结构还是有点奇怪的，导航控制器嵌入了 TabbarController，然后 TabbarController 的每个子控制器又是导航控制器。。。</p>
<p>这种方式属于通过 lldb 进行汇编级别的动态 hook 绕过反调试。这种动态的方式无法随时在需要的时候附加到目标进程，因为目标进程的反调试代码已经执行了。优点是不需要对 APP MachO 文件进行修改，不需要重新签名打包安装。后面的抖音反反调试是通过静态修改 MachO 文件内容进行的。</p>
<h3 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h3><p>支付宝最新版 10.7.50 直接使用 xia0LLDB 的 debugme 就可以绕过了，甚至连 svc 指令都没有，但是的确做了反调试。就不多说了。</p>
<h2 id="静态绕过反调试"><a href="#静态绕过反调试" class="headerlink" title="静态绕过反调试"></a>静态绕过反调试</h2><h3 id="抖音"><a href="#抖音" class="headerlink" title="抖音"></a>抖音</h3><p>这里同样以作者写作时的抖音最新版本 34.7.0 为例。如果继续使用 xia0LLDB 对抖音进行反调试绕过的话，首先会发现 xia0LLDB 无法读取到 Aweme 和 AwemeCore 两个 MachO 的代码段地址，扫描结果都是 0 到 0。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lldb) debugme</span><br><span class="line">[*] start patch ptrace funtion to bypass anti debug</span><br><span class="line">[+] ptrace funtion patach <span class="keyword">done</span></span><br><span class="line">[*] start patch svc ins to bypass anti debug</span><br><span class="line">[+] use <span class="string">&quot;target list&quot;</span> to get main module:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] app <span class="built_in">dir</span>:/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] text start:0x0000000000000000 end:0x0000000000000000</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore</span></span><br><span class="line"><span class="string">[*] text start:0x0000000000000000 end:0x0000000000000000</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/BDLRepairer.framework/BDLRepairer</span><br><span class="line">[*] text start:0x0000000105323e68 end:0x0000000105323ef0</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/ByteRTCNICOExtension.framework/ByteRTCNICOExtension</span></span><br><span class="line"><span class="string">[*] text start:0x00000001053d0000 end:0x0000000105445f74</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这就非常奇怪了，那么先开始分析 MachO 文件，这里可以使用 MachOView 查看 MachO 的 Load Command 发现，要么是不存在 __TEXT,__text 段，要么就是即便存在，但是 size 为 0。这就导致 debugme 根本无法扫描到代码段内存地址范围。但是会发现存在一个额外的 __BD_TEXT,__text 段，这个段里面都是汇编代码，看来抖音是在这里做了一定的防护。首先是 Aweme 的分析</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_1.png" class="">

<p>然后是 AwemeCore 的分析：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_2.png" class="">

<p>到此我们可以重新查看 debugme 的扫描代码段的代码 get_text_segment() 方法，新增以下逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span>(ncmds--) &#123;</span><br><span class="line">     /* go through <span class="built_in">all</span> load command to find __TEXT segment*/</span><br><span class="line">     struct load_command * lcp = (struct load_command *)((uint8_t*)header + x_offset);</span><br><span class="line">     x_offset += lcp-&gt;cmdsize;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(lcp-&gt;cmd == LC_SEGMENT_64) &#123;</span><br><span class="line">         struct segment_command_64 * curSegment = (struct segment_command_64 *)lcp;</span><br><span class="line">         struct section_64* curSection = (struct section_64*)((uint8_t*)curSegment + sizeof(struct segment_command_64));</span><br><span class="line">         </span><br><span class="line">         // check current section of segment <span class="keyword">is</span> __TEXT?</span><br><span class="line">         <span class="keyword">if</span>(!strcmp(curSection-&gt;segname, <span class="string">&quot;__TEXT&quot;</span>) &amp;&amp; !strcmp(curSection-&gt;sectname, <span class="string">&quot;__text&quot;</span>) &amp;&amp; curSection-&gt;size != <span class="number">0</span>)&#123;</span><br><span class="line">             uint64_t memAddr = curSection-&gt;addr;</span><br><span class="line">            </span><br><span class="line">             textStart = memAddr + (uint64_t)_dyld_get_image_vmaddr_slide(image_index);</span><br><span class="line">             textEnd = textStart + curSection-&gt;size;</span><br><span class="line">             /*</span><br><span class="line">             [retStr appendString:@<span class="string">&quot; &quot;</span>];</span><br><span class="line">             [retStr appendString:(<span class="built_in">id</span>)[@(textStart) stringValue]];</span><br><span class="line">             [retStr appendString:@<span class="string">&quot; , &quot;</span>];</span><br><span class="line">             [retStr appendString:(<span class="built_in">id</span>)[@(textEnd) stringValue]];</span><br><span class="line">             */</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         /*</span><br><span class="line">         针对 Aweme 中 __TEXT,__text 不存在或者即使存在也没有大小的情况这里增加使用 __BD_TEXT,__text </span><br><span class="line">         虽然 svc 指令都找到了,但是依旧无法绕过反调试,还需要进一步分析...初步分析是hook代码破坏了原始代码的结构。。。这里还是先注释了吧</span><br><span class="line">*/</span><br><span class="line">         <span class="keyword">if</span> (!strcmp(curSection-&gt;segname, <span class="string">&quot;__BD_TEXT&quot;</span>) &amp;&amp; !strcmp(curSection-&gt;sectname, <span class="string">&quot;__text&quot;</span>) &amp;&amp; curSection-&gt;size != <span class="number">0</span>) &#123;</span><br><span class="line">             uint64_t memAddr = curSection-&gt;addr;</span><br><span class="line">             textStart = memAddr + (uint64_t)_dyld_get_image_vmaddr_slide(image_index);</span><br><span class="line">             textEnd = textStart + curSection-&gt;size;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样就能在使用 debugme 的时候扫描到代码段了，而且扫描出来的 svc 指令调用的地方可真不少。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lldb) debugme</span><br><span class="line">[*] start patch ptrace funtion to bypass anti debug</span><br><span class="line">[+] ptrace funtion patach <span class="keyword">done</span></span><br><span class="line">[*] start patch svc ins to bypass anti debug</span><br><span class="line">[+] use <span class="string">&quot;target list&quot;</span> to get main module:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] app <span class="built_in">dir</span>:/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] text start:0x0000000104d90000 end:0x0000000104d97e08</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore</span></span><br><span class="line"><span class="string">[*] text start:0x0000000139638000 end:0x0000000157814b1c</span></span><br><span class="line"><span class="string">------&gt;  5258500616 5258500744 5399496488 5399652708 5399653492 5399660936 5399665264 5399668140 5399668572 5399679616 5399679704 5399679720 5399679856 5399680700 5399683596 5399683628 5399683644 5399683660 5399727432 5399727576 5399728352 5399728584 5399729028 5399729760 5399730068 5399730552 5399730736 5399730840 5399730976 5399731080 5399731340 5399746168 5399764228 5399767088 5399780608 5399840652 5399841164 5399842344 5399875652 5399877380 5399877512 5399877768 5399877900 5399878792 5399878924 5399879272 5399879400 5399879996 5399880120 5399880548 5399880672 5399883864 5399884032 5399885580 5399886116 5399886248 5399886500 5399888308 5399891000 5399900344 5399900936 5399901060 5399901300 5399901432 5399916064 5399916236 5399917056 5399917196 5399920256 5399920804 5399927376 5399934216 5399948220 5399948480 5399950216 5399968700 5399968868 5399969008 5399969316 5399969456 5399969956 5399970808 5399970920 5399971064 5399971196 5399972004 5399973804 5399974480 5399975036 5399975156 5399975680 5399977044 5399977332 5399977912 5399978976 5399979096 5399980092 5400014396 5400045444 5400046372 5400077856 5400092792 5400117400 5400117832 5400123672 5400130960 5400132620 5400144476 5400150292 5400157820 5400159948 5400172524 5400173176 5400181328 5400248688 5400248832 5400250696 5400254644 5400260284 5400300644 5400306152 5400320308 5400362148 5400362616 5400369700 5400370396 5400372020 5400372704 5400374128 5400383844 5400461880 5400462020 5435622100 5435622120 5435622140 5435622160 5435622180 5435622200 5435622220 5535057976 5535058272</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x1396e5a08</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x1396e5a08 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x1396e5a88</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x1396e5a88 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x141d5c728</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x141d5c728 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x141d82964</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x141d82964 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x141d82c74</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x141d82c74 done</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>svc 指令地址是扫描出来了，但结果还是无法成功绕过反调试。初步分析是 hook 代码破坏了原始汇编代码的结构，这么多地方（估计100到200个左右）一个个分析起来头都要炸了。。。我们还是另辟蹊径吧。既然这种动态 hook 的方式比较困难，我们就尝试静态分析一番。</p>
<p>首先 Aweme 的大小就很奇怪，只有 178 KB，这显然不是一个正常的应用应该有的大小，打开 hooper 分析一番。可执行文件的 MachO 都存在着入口函数，分析入口函数汇编代码：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_3.png" class="">

<p>直接无条件跳转到 <code>imp___stubs__awemeMain</code> 去了，双击跟进去。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_4.png" class="">

<p>这里的汇编显示，br 到寄存器 x16，而寄存器 x16 又是从 <code>_awemeMain</code> 加载的。那么继续双击 <code>_awemeMain</code> 就发现了它是一个声明在 <code>@rpath/AwemeCore.framework/AwemeCore</code> 的函数。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_5.png" class="">

<p>这下就可以确定了抖音的 APP 包下的 Aweme 只是一个壳，真正的主程序代码全部都写在了一个 AwemeCore 的 Framework 下。那么接下来要做的就是继续分析 AwemeCore 这个文件。但是这个文件太大了，629.9 MB，作者的电脑使用 hopper 完全吃不消这个文件。没关系，反汇编工具那么多，电脑升级不了就换个工具试试，作者这里使用的是 Ghidra。</p>
<p>使用 Ghidra 搜索 <code>_awemeMain</code>，可以看到关联的汇编代码，可以看到一个很熟悉的 svc 指令调用。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_6.png" class="">

<p>参数分别是 x0 &#x3D; 26, x1 &#x3D; 31。在 sys&#x2F;syscall.h 头文件中可以看到 26 是 SYS_ptrace 调用，而 SYS_ptrace 的参数 31 则是 PT_DENY_ATTACH 正是反调试的系统调用。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_7.png" class="">

<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_8.png" class="">

<p>入口函数就是一个反调试，那么我们就先干掉这个反调试试试看。使用 nop 指令替换 svc 指令，使用方法是选择 svc 指令所在的行，右键 patch instruction 输入 nop 就完成了，如下：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_9.png" class="">

<p>完成替换之后，我们重新导出可执行文件，步骤是 File -&gt; Export Program。格式选择 original file，记得勾选 Export User Byte Modifications 不然修改没有保存。保存之后我们替换 iPhone 上的 AwemeCore，可以备份一下原始的 AwemeCore。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iPhone8plus:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/AwemeCore.framework root# <span class="built_in">ls</span></span><br><span class="line">AwemeCore  AwemeCoreBackup  Info.plist  SC_Info/  _CodeSignature/</span><br></pre></td></tr></table></figure>

<p>这个时候我们可以重启手机一下 iPhone，因为有可能 APP 的 Framework 会被缓存下来，导致没有使用我们修改后的 AwemeCore 文件。重启之后，再次使用 debugserver+lldb 远程调试会发现可以成功附加调试了~~~</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=Aweme</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process Aweme...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) pcc</span><br><span class="line">Process 3322 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000001c9ca5030 libsystem_kernel.dylib` mach_msg2_trap  + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg2_trap:</span><br><span class="line">-&gt;  0x1c9ca5030 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;macx_swapon:    0x1c9ca5034 &lt;+0&gt;: mov    x16, #-0x30 ; =-48</span></span><br><span class="line"><span class="string">    0x1c9ca5038 &lt;+4&gt;: svc    #0x80</span></span><br><span class="line"><span class="string">    0x1c9ca503c &lt;+8&gt;: ret</span></span><br><span class="line"><span class="string">libsystem_kernel.dylib&#x27;</span>macx_swapoff:    0x1c9ca5040 &lt;+0&gt;: mov    x16, <span class="comment">#-0x31 ; =-49</span></span><br><span class="line">    0x1c9ca5044 &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x1c9ca5048 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;thread_get_special_reply_port:    0x1c9ca504c &lt;+0&gt;: mov    x16, #-0x32 ; =-50</span></span><br><span class="line"><span class="string">Target 0: (Aweme) stopped.</span></span><br><span class="line"><span class="string">(lldb) pvc</span></span><br><span class="line"><span class="string">&lt;AWENormalModeTabBarController 0x104a56600&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x11c53c320&gt;</span></span><br><span class="line"><span class="string">   | &lt;AWEBaseRootNavigationController 0x103a7e800&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x11c593240&gt;</span></span><br><span class="line"><span class="string">   |    | &lt;AWEFeedRootViewController 0x107b22140&gt;, state: appeared, view: &lt;UIView: 0x107a1bc00&gt;</span></span><br><span class="line"><span class="string">   |    |    | &lt;AWEFeedContainerViewController 0x10902fe00&gt;, state: appeared, view: &lt;UIView: 0x10126ecb0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;AWEFeedSlidingViewController 0x103a7a600&gt;, state: appeared, view: &lt;UIView: 0x11c4e38d0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    | &lt;AWEHPXTabChannelViewController 0x10128de70&gt;, state: appeared, view: &lt;UIView: 0x11c5cf180&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    | &lt;AWEHPChannelPageViewController 0x104a7ca00&gt;, state: appeared, view: &lt;UIView: 0x11c5843c0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    | &lt;AWEFeedTableViewController 0x104aef200&gt;, state: appeared, view: &lt;UIView: 0x11c5cd5a0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    | &lt;AWEFeedCellViewController 0x104e7c000&gt;, state: appeared, view: &lt;UIView: 0x107512080&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    | &lt;RichContentContainerViewController 0x104c4da00&gt;, state: appeared, view: &lt;UIView: 0x1075ab1b0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    |    | &lt;AWEFriendsImpl.RichContentNewListViewController 0x104e98200&gt;, state: appeared, view: &lt;UIView: 0x107538cc0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    |    |    | &lt;AWEAwemePlayVideoViewController 0x103b0d000&gt;, state: appeared, view: &lt;UIView: 0x11c4cca20&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    |    |    | &lt;AWEPlayInteractionViewController 0x104e4fa00&gt;, state: appeared, view: &lt;UIView: 0x10751d0e0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    | &lt;AWEFeedCellViewController 0x103d4f400&gt;, state: disappeared, view: &lt;UIView: 0x107b4a010&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    | &lt;AWEDPlayerFeedPlayerViewController 0x1248d0c00&gt;, state: disappeared, view: &lt;UIView: 0x1075cac30&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    | &lt;AWEPlayInteractionViewController 0x103dc4000&gt;, state: disappeared, view: &lt;UIView: 0x11c54abd0&gt; not in the window</span></span><br><span class="line"><span class="string">   + &lt;DUXAlertDialog 0x103c54600&gt;, state: appeared, view: &lt;UIView: 0x125382f80&gt;, presented with: &lt;DUXAlertDialogPresentationController: 0x125011af0&gt;</span></span><br><span class="line"><span class="string">(lldb)  </span></span><br></pre></td></tr></table></figure>

<p>到此，我们就通过修改 MachO 文件的汇编指令实现了反调试绕过。其实一般来说，在 iOS 平台，对二进制的修改之后需要重新进行签名才能正常运行，但是经过实践证明，iOS 系统在启动 APP 的时候，应该只会对 APP 包内的第一层文件进行签名验证，而不会递归验证它的子目录，比如我们这里修改了 Framework 下的某个 MachO。如果修改的是 Aweme 的二进制文件，这个毫无疑问哪怕只要是改了一个字节都无法通过签名验证，肯定是无法启动的。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>反调试</tag>
        <tag>反反调试</tag>
        <tag>小红书</tag>
        <tag>抖音</tag>
        <tag>支付宝</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS逆向与安全开篇介绍</title>
    <url>/2024/03/27/iOS%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="学习-iOS-逆向开发的前提"><a href="#学习-iOS-逆向开发的前提" class="headerlink" title="学习 iOS 逆向开发的前提"></a>学习 iOS 逆向开发的前提</h1><ul>
<li>有一定的正向开发经验（最起码对 iOS 系统的 UIKit 框架有一定的了解）</li>
<li>一台越狱的 iOS 设备（推荐至少是 64 位架构，iPhone 是从 iPhone 5s 开始，iPad 是从 iPad Air 和 iPad mini 2 开始）</li>
<li>一台 Mac 电脑，理论上来说 Linux 或 Windows 也可以（实际上作者没有实践过）</li>
<li>时间和恒心</li>
</ul>
<h1 id="什么是-iOS-逆向开发"><a href="#什么是-iOS-逆向开发" class="headerlink" title="什么是 iOS 逆向开发"></a>什么是 iOS 逆向开发</h1><p>很多 iOS 开发者可能都不是科班出身的程序员，所以对于逆向开发可能没有任何概念。实不相瞒，作者本人就是如此。工作多年后才慢慢接触并了解了逆向开发，逆向工程等相关的知识。</p>
<p>逆向开发（Reverse Engineering）是一种通过分析和研究已有软件或系统的内部结构、逻辑和功能，以理解其实现方式的技术。在软件开发中，逆向开发通常涉及反编译、反汇编或动态调试，以揭示目标程序的代码逻辑和功能。</p>
<p>iOS 逆向开发是指通过分析已有的 iOS 应用程序或 iOS 系统来理解其内部结构、行为以及工作原理的过程。与常规开发（从源代码构建应用程序）相反，逆向开发是在没有源代码的情况下，逆向分析编译后的二进制文件，研究应用的工作机制。</p>
<h1 id="学习-iOS-逆向开发有什么用"><a href="#学习-iOS-逆向开发有什么用" class="headerlink" title="学习 iOS 逆向开发有什么用"></a>学习 iOS 逆向开发有什么用</h1><ul>
<li><p><strong>应用分析与调试：</strong>使用工具来调试和分析应用程序，理解其功能实现。研究员常用 LLDB、Hopper、Ghidra 等工具来反汇编和反编译 iOS 应用，以了解代码的工作方式。</p>
</li>
<li><p><strong>破解和去除限制：</strong>通过逆向手段绕过某些应用的限制，如应用内购买、付费功能等。虽然这属于非法行为，但仍是逆向开发中不可忽视的一部分。</p>
</li>
<li><p><strong>安全性研究与漏洞发现：</strong>逆向开发在 iOS 安全研究中非常重要。通过逆向工程，安全研究人员可以分析应用的加密算法、安全协议等，寻找漏洞并提出防御措施。</p>
</li>
<li><p><strong>学习与模仿：</strong>开发者通过逆向分析成熟的应用来学习优秀的开发技巧，或者模仿某些功能。</p>
</li>
</ul>
<p>玩过 LOL 的老玩家应该还记得多年前某些辅助工具可以实现自己使用任意皮肤，这也是通过逆向开发做到的，属于 window 逆向方向的，而 iOS 平台的有移除 App 内的广告，绕过打卡类 App 的 Wi-Fi 限制，GPS 检测实现任意打卡，微信自动抢红包，还有游戏的外挂辅助软件也都是通过逆向开发实现的。。。这些都是正向开发做不到，或者不可能提供的。这些也正是逆向开发的用武之地。当然，学会了如何破解别人的 APP，自然也知道了该如何去防护自己的 APP，提高安全性，不会进攻谈什么安全防护呢。</p>
<p>以上这些功能，如果你听到了就感觉到很兴奋，那么恭喜你来对了地方！通过本门课程的学习，以上案例都有可能可以实现。不过还是需要提醒一下大家，一般来说逆向开发的难度相较于正向开发会更加困难，想要掌握逆向开发并不是一件容易的事情，需要持之以恒的学习。</p>
<h1 id="关于-iOS-开发人员的概念解释"><a href="#关于-iOS-开发人员的概念解释" class="headerlink" title="关于 iOS 开发人员的概念解释"></a>关于 iOS 开发人员的概念解释</h1><ol>
<li><p><strong>iOS 应用开发人员</strong></p>
<p> iOS 应用开发人员通常是指那些为 iOS 系统开发应用程序的人。他们主要使用苹果的开发工具和框架，比如 Xcode、Swift、Objective-C 等，目标是创建可以在苹果的 App Store 上发布的应用程序。这类开发人员的主要工作是围绕用户体验、界面设计、功能实现和优化应用性能。</p>
<p> 他们的主要任务包括：</p>
<ul>
<li>开发和维护 iPhone、iPad 上运行的应用程序</li>
<li>使用 iOS SDK（软件开发工具包）和相关的 API（如 UIKit、Core Data、ARKit 等）</li>
<li>与后端服务交互（通常使用 RESTful API 或 GraphQL）</li>
<li>解决与应用程序相关的性能和安全问题</li>
<li>测试和调试应用程序 <br></li>
</ul>
</li>
<li><p><strong>iOS 系统开发人员（越狱插件、底层开发等）</strong></p>
<p> 真正意义上的 iOS 开发人员更适合用于描述那些进行 iOS 系统级开发的人。这些开发人员深入到 iOS 系统的底层，做与操作系统本身相关的开发工作，比如修改系统行为、开发越狱插件、研究内核安全性或进行硬件驱动开发。</p>
<p> 他们的主要任务包括：</p>
<ul>
<li>研究 iOS 系统的底层结构和安全机制</li>
<li>开发越狱工具、插件（比如 Cydia 插件）</li>
<li>修改系统设置或行为，允许用户做出官方系统不允许的操作</li>
<li>逆向工程或研究系统漏洞</li>
<li>优化或修改内核（kernel）层的功能</li>
</ul>
</li>
</ol>
<p>市场上面招聘的 iOS 开发人员基本上都是指 iOS 应用开发人员。iOS 系统开发人员的岗位较少。但如果 iOS 应用开发人员具备逆向分析开发的能力则是一项优势。</p>
<h1 id="本书如何学习"><a href="#本书如何学习" class="headerlink" title="本书如何学习"></a>本书如何学习</h1><p>作者将以微信抢红包的实战项目出发，从 0 到 1 演示如何实现微信抢红包插件，实现插件过程中涉及到的技术和理论知识都会在后续的章节中详细介绍，对 iOS 逆向开发感兴趣的同学通过这个项目，可以迅速的建立对 iOS 逆向开发的整体认知。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2025/05/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><ul>
<li>你理解的多线程？</li>
<li>iOS 中的多线程方案有哪几种？你更倾向于哪一种？</li>
<li>你在项目中用过 GCD 吗？</li>
<li>GCD 的队列类型</li>
<li>说一下 OperationQueue 和 GCD 的区别，以及各自的优势</li>
<li>线程安全的处理手段有哪些？</li>
<li>Objective-C 你了解的锁有哪些？在你回答基础上进行二次提问：<ul>
<li>自旋锁和互斥锁对比？</li>
<li>使用以上锁需要注意哪些？</li>
<li>用 C&#x2F;C++&#x2F;Objective-C 任一语言实现自旋锁或互斥锁，口述即可</li>
</ul>
</li>
</ul>
<h1 id="iOS-中的多线程方案"><a href="#iOS-中的多线程方案" class="headerlink" title="iOS 中的多线程方案"></a>iOS 中的多线程方案</h1><table>
<thead>
<tr>
<th>技术方案</th>
<th>简介</th>
<th>实现的语言</th>
<th>线程生命周期</th>
<th>使用频率</th>
</tr>
</thead>
<tbody><tr>
<td>pthread</td>
<td>· 一套通用的多线程 API<br>· 适用于 Unix、Linux、Windows 等系统<br>· 跨平台、可移植<br>· 使用难度大</td>
<td>C</td>
<td>程序员管理</td>
<td>几乎不用</td>
</tr>
<tr>
<td>NSThread</td>
<td>· 提供面向对象的 API<br>· 简单易用，可直接操作线程对象</td>
<td>Objective-C</td>
<td>程序员管理</td>
<td>偶尔使用</td>
</tr>
<tr>
<td>GCD</td>
<td>· 旨在替代 NSThread 等线程技术<br>· 充分利用设备的多核心</td>
<td>C</td>
<td>系统自动管理</td>
<td>经常使用</td>
</tr>
<tr>
<td>NSOperation</td>
<td>* 提供面向对象的 API<br> * 基于 GCD 实现<br>* 比 GCD 多了一些更加简单实用的功能</td>
<td>Objective-C</td>
<td>系统自动管理</td>
<td>经常使用</td>
</tr>
</tbody></table>
<h1 id="GCD-基础知识"><a href="#GCD-基础知识" class="headerlink" title="GCD 基础知识"></a>GCD 基础知识</h1><p>什么是 GCD ？</p>
<p>​​GCD（Grand Central Dispatch）​​ 是苹果公司为优化多核处理器性能而开发的并发编程技术，旨在简化并行任务的管理。</p>
<ul>
<li>GCD 中有 2 个用来执行任务的函数<ul>
<li>用同步的方式执行任务  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure></li>
<li>用异步的方式执行任务  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务，线程：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>GCD 源码，居然在 Swift 项目下</p>
<p>GCD 的队列有两种<br>    - 串行队列：跟烤串一样，任务就像是烤串上一块一块的羊肉，执行时一个接着一个。<br>    - 并发队列：不止一根烤串了，多根烤串同时执行任务。</p>
<p>同步、异步、并发、串行的概念<br>    - 同步：不开启新线程<br>    - 异步：有能力开启新线程<br>    - 串行：一个任务接着一个任务执行<br>    - 并发：多个任务可以同一时间执行</p>
<table>
<thead>
<tr>
<th></th>
<th>并发队列</th>
<th>手动创建的串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody><tr>
<td>同步函数 sync</td>
<td>* 不开新线程<br>* 任务串行</td>
<td>* 不开新线程<br>* 任务串行</td>
<td>* 不开新线程<br>* 任务串行</td>
</tr>
<tr>
<td>异步函数 async</td>
<td>* 开新线程<br>* 任务并发</td>
<td>* 开新线程<br>* 任务串行</td>
<td>* 不开新线程<br>* 任务串行</td>
</tr>
</tbody></table>
<p>162：<br>死锁？<br>什么是死锁？<br>什么情况下产生死锁？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码如果是在主线程执行就产生了死锁。如果不在主线程执行不会产生死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码不会产生死锁，异步主队列是在主线程上执行任务。很经典的场景。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;custom_queue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码会产生死锁，两个block任务在同一个队列，又是同步函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">&quot;custom_queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">&quot;custom_queue2&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(queue2, ^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码不会产生死锁，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">&quot;custom_queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">&quot;custom_queue2&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(queue2, ^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码也不会产生死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;custom_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2&quot;</span>);</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码也不会产生死锁，并发队列</p>
<p><strong>使用同步函数 sync 往当前的串行队列再次添加任务就会产生死锁</strong></p>
<p>165：<br>面试题<br>以下代码的打印结果是什么：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果是 1，3。performSelector: withObject: afterDelay: 方法依赖 RunLoop，子线程的 RunLoop 默认不开启，导致 2 的打印并不会执行。</p>
<p>166：<br>performSelector:withObject:afterDelay: 是在 CoreFoundation 库里面实现的<br>performSelector:withObject: 是在 objc4 库里面实现的</p>
<p>GNUstep 将 Cocoa 的 Objective-C 库重写了一遍并开源了，所以可以参考学习。</p>
<p>167：<br>面试题2<br>以下代码的打印结果是什么：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread start];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果是 1，然后程序崩溃，打印完 1 之后线程退出了，没办法执行 test 了，要保活子线程就得开启 RunLoop，强引用也解决不了。</p>
<p>168：<br>调度组的使用<br>实现功能：发送多个网络请求，所有网络请求都完成的时候处理事情？<br>正是调度组的典型使用场景</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;custom_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1，线程：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2，线程：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务3，线程：%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="线程同步方案"><a href="#线程同步方案" class="headerlink" title="线程同步方案"></a>线程同步方案</h1><p>169:<br>多线程存在的问题？同时做多件事情提高了效率，但是存在线程安全问题<br>资源共享问题：<br>    多个线程访问和使用同一个资源</p>
<p>案例：<br>存钱取钱。<br>卖票案例。</p>
<p>解决办法：<br>    线程同步技术：加锁</p>
<p>170-173：<br>iOS 中的线程同步方案有：</p>
<ul>
<li>OSSpinLock</li>
<li>os_unfair_lock</li>
<li>pthread_mutex</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
<li>dispatch_semaphore</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
</ul>
<p>然后是介绍 OSSpinLock 的使用了。导入 libkern&#x2F;OSAtomic.h 头文件，OS_SPINLOCK_INIT 宏创建锁，OSSpinLockLock() 函数加锁  OSSpinLockUnlock() 函数解锁<br>OSSpinLock 叫自旋锁，等待锁的期间一直占用着 CPU，已经过时了，还有可能产生优先级问题。。。总是就是不要用了，那为什么还讲那么多七七八八的呢</p>
<p>原来 172 里是对代码的结构进行了调整。。。结合了一些封装设计在里面。。。站在讲解多线程锁的角度来讲，完全没有必要讲这块内容！<br>但是我想想有没有必要学习下怎么写的？？？</p>
<p>173：答疑</p>
<p>174：os_unfair_lock<br>这是自旋锁还是互斥锁呢？好像没讲呢？根据汇编得知是互斥锁，调用syscall让CPU休眠了</p>
<p>175：pthread_mutex<br>互斥锁，等待锁的线程会处于休眠状态。</p>
<p>176：pthread_mutex 递归锁</p>
<p>177：自旋锁，互斥锁的汇编实现<br>自旋锁底层是一个循环一直在执行。<br>互斥锁底层调用了syscall让CPU进入休眠</p>
<p>178：pthread_mutex 条件<br>讲了个什么场景没太理解。。。<br>感觉讲的真不好，总是磕磕绊绊来来回回重复叙述<br>pthread_cond_wait()<br>pthread_cond_signal()<br>意思好像是始终能保证 A 在 B 之前执行？好像是 OperationQueue 里面的依赖关系的？可能就是依赖的底层实现？<br>生产者？消费者？模式，意思是生产者必须先生产产品出来才可以给消费者消费。</p>
<p>179:<br>NSLock 是对 mutex 普通锁的封装<br>NSRecursiveLock 是对 mutex 递归锁的封装<br>NSCondition 是 mutex cond 的封装</p>
<p>180：课后答疑</p>
<p>181：<br>[self.confition signal] 解释<br>完全听不明白了，不知道在表达啥呢。。。<br>答疑 RunLoop，这不是前面讲过了，看看什么问题</p>
<ol>
<li>NSThread 的生命不是一个强引用就能保证的，它的 RunLoop 不执行，线程的入口函数执行完就释放了。</li>
<li>线程的入口函数执行了一段代码，但是如果不实现循环，它就跟普通的命令行程序执行完入口函数就结束了。<br>其实还是对线程的理解不够深入。确实线程对象比普通的对象更抽象。</li>
</ol>
<p>182：NSConditionLock<br>NSConditionLock？不是有一个 NSCondition 吗，这个又是什么<br>原来 NSConditionLock 是对 NSCondition 的封装。提供了更多功能<br>条件锁，应用场景还是建立依赖。。。</p>
<p>183：串行队列<br>是的，GCD 的串行队列也可以实现线程同步</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> moneyQueue = dispatch_queue_create(<span class="string">&quot;custom_queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(moneyQueue, ^&#123;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个好理解</p>
<p>184-185：dispatch_semaphore<br>信号量，通过信号量控制线程最大并发数量为 1 的话同样可以实现线程同步。</p>
<p>dispatch_semaphore_wait() 函数会让信号量减 1。如果信号量大于 0 会执行后续代码。如果信号量 &lt;&#x3D; 0 会进入休眠直到大于 0 才可以继续执行后续代码。<br>dispatch_semaphore_signal() 会让信号量加 1。</p>
<p>186：@synchronized 编译器语法糖<br>是 pthread_mutex_t 的封装。最简单的同步方案。<br>源码是在 objc4 库的 objc-sync.h objc-sync.mm 文件中，objc_sync_entry() objc_sync_exit()。发现是对 pthread_mutex_t 递归锁的封装。</p>
<p>187：<br>总结线程同步方案：<br>性能从高到底</p>
<ol>
<li>os_unfair_lock</li>
<li>OSSpinLock</li>
<li>dispatch_semaphore</li>
<li>pthread_mutex</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSCondition</li>
<li>pthread_mutex(recursive)</li>
<li>NSRecursiveLock</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ol>
<p>188：自旋锁，互斥锁对比</p>
<ul>
<li>什么情况使用自旋锁比较划算？<ul>
<li>预计线程等待锁的时间很短</li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>
<li>CPU 资源不紧张</li>
<li>多核心处理器</li>
</ul>
</li>
<li>什么情况使用互斥锁比较划算<ul>
<li>预计线程等待锁的时间较长</li>
<li>单核处理器</li>
<li>加锁的代码有 IO 操作</li>
<li>加锁的代码复杂，循环量大</li>
<li>加锁的代码竞争频繁</li>
</ul>
</li>
</ul>
<p>189：atomic<br>属于属性的修饰符，但在 iOS 中只推荐使用 nonatomic。atomic 更多用于 macOS 中。atomic 的作用是使属性的 getter 和 setter 是原子的，意思是属性的 setter 方法和 getter 方法都进行了加锁。<br>源码在 objc4 中。objc-accessors.mm 中，可以看到 atomic 的情况下进行了加锁。<br>但是又说没有办法保证使用属性的线程是安全的？这是什么意思<br>这个还是需要 AI 再详细解读一下了<br>问清楚为什么在 iOS 中不推荐使用 atomic。</p>
<p>190-192：读写安全<br>文件的读写安全的实现。</p>
<ol>
<li>信号量最大并发为1，可以实现，但是只能单读单写。如果要实现多读单写就不能使用信号量了。多个线程可以同时读取数据，但只有一个线程写入数据，读和写是不能同时进行（只能有一个线程写，且写的时候无法读，可以有多个线程读但读的时候无法写）</li>
<li>pthread_rwlock 读写锁，等待锁的线程会进入休眠 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;lock);</span><br></pre></td></tr></table></figure></li>
<li>dispatch_barrier_async 异步栅栏函数 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须使用创建的并发队列，全局并发队列或串行队列都无效</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;rw_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="comment">// 读操作...</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">	<span class="comment">// 写操作...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>代码注入</title>
    <url>/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>上一篇我们已经讲到使用 shell 脚本来重签并调试别人的 APP，那么我们又是重签又是附加调试别人的 APP 是为了啥呢？是太闲了吗，当然不是…我们接下来的任务就是<strong>代码注入</strong></p>
<h1 id="App-执行哪些代码"><a href="#App-执行哪些代码" class="headerlink" title="App 执行哪些代码?"></a>App 执行哪些代码?</h1><p>在开始代码注入之前，我们先了解一下一个 iOS 的 App 在运行的时候,究竟会执行哪些代码,以及我们从哪里入手注入代码</p>
<ol>
<li>MachO。App 的二进制文件，我们写的所有代码都会在这里，后面的文章会介绍</li>
<li>Framework 可以是我们写的，也可以是第三方的代码</li>
<li>系统库</li>
</ol>
<p>其中系统库，在非越狱手机上我们改不了。MachO 我们可以修改，但是比较麻烦，需要会写汇编。而 Framework 是我们经常接触也是最容易入手的，我们自己写一个就行了…</p>
<p>那么现在的问题就是我们写的 Framework 别人的 APP 怎么会执行呢?</p>
<p>MachO 文件里面有一个 Load Commands 的部分，DYLD(the dynamic link editor 是苹果的动态链接器，后面的文章也会介绍)会读取这个 Load Commands 里面的内容，并加载到内存中，如果我们能把我们自己的 Framework 插入到别人 APP 的 MachO 的 Load Commands 里，那么我们的代码就自然的被执行了</p>
<p>那么现在的问题就变成了如何把我们写的 Framework 插入到别人 App 的 MachO 文件里?</p>
<p><a href="https://github.com/KJCracks/yololib"><strong>yololib</strong></a> 这是一个终端命令行工具，就是用来把我们写的 Framework 插入到 MachO 文件里，代码不多就 200 来行，感兴趣的可以看看源码，用法是 <code>yololib 参数1 参数2</code> 其中参数 1 是 MachO 文件,参数 2 是我们的 Framework 相对于 MachO 文件的路径。</p>
<p>下载源码之后是我们很熟悉的 Xcode 工程，只不过是 Mac 上的命令行工程而不是我们常用的 iOS 工程，修改一下 Deployment Target 到你的 Xcode 兼容的最低版本，然后编译一下就能在编译后的文件夹下找到。编译后的文件夹可以通过点击 Xcode 上的 Product -&gt; Show Build Folder in Finder 中的 Products-&gt;Debug 找到。</p>
<p>为了方便我们使用这个工具,建议把它放到系统的 usr&#x2F;local&#x2F;bin 目录下，记得给它提升可执行权限(在终端<code>chmod +x yololib</code>)，这样我们任意打开一个终端都可以使用这个命令了，也方便我们使用脚本来操作。</p>
<p>好了，现在万事具备，只欠我们动手操作了…还记得上一篇文章讲到的内容吗，使用 shell 脚本重签 App。可以接着使用上次的工程，也可以新建一个工程来执行后面的代码注入，配置好脚本之后只需要放入一个砸壳的 app 包到根目录下就好了。我这里新建一个项目来演示后面的代码注入</p>
<h1 id="代码注入的步骤"><a href="#代码注入的步骤" class="headerlink" title="代码注入的步骤"></a>代码注入的步骤</h1><h2 id="新建-Framework"><a href="#新建-Framework" class="headerlink" title="新建 Framework"></a>新建 Framework</h2><p>在完成了上一篇 shell 脚本重签的步骤之后，我们先来新建一个 Framework，把我们的 Framework 准备好</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/df6e2cd5a8a44393bd4c2ad7e6e968b3~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>Framework 的名字就叫 FrankyHook 这个名字无所谓，但是要记住因为在后续使用 yololib 的时候要用到，在里面新建一个类 CodeInject 这个叫什么也无所谓，继承自 NSObject 就够了，主要是需要它的 load 方法，并在 load 方法里面打印点内容</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/e6907858950d4925955c8e35546d239a~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h2 id="在脚本中添加代码"><a href="#在脚本中添加代码" class="headerlink" title="在脚本中添加代码"></a>在脚本中添加代码</h2><p>记得修改为你自己的 Framework 名字，要是照着我的抄的的当我没说</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yololib <span class="string">&quot;<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;TARGET_NAME&#125;</span>.app/<span class="variable">$&#123;APP_BINARY&#125;</span>&quot;</span> <span class="string">&quot;Frameworks/FrankyHook.framework/FrankyHook&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里面有一个小细节，就是你的脚本运行一定要放在嵌入 Frameworks 之后，不然每次脚本运行之后再嵌入 Frameworks 的话 Xcode 会结合 Framework 的 Info.plist 重新处理工程源代码下的 Info.plist 文件到编译的包中，会导致少了很多配置从而启动崩溃。</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/c1d7d440bea24897a23196bf5f8333eb~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>实不相瞒，做了四年多的 iOS 开发，也是到今天才知道这个地方居然可以拖动…</p>
<h2 id="command-R-看控制台输出"><a href="#command-R-看控制台输出" class="headerlink" title="command + R 看控制台输出"></a>command + R 看控制台输出</h2><img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/756a92a31db340e29078c8fa6a4e15f5~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>怎么样，是不是发现我们已经可以在 WeChat 里面执行我们的代码了？接下来我们来实现两个小小的需求</p>
<h1 id="需要具备的一些知识点"><a href="#需要具备的一些知识点" class="headerlink" title="需要具备的一些知识点"></a>需要具备的一些知识点</h1><p>接下来的内容需要对 Objective-C 的 rumtime 有一定的了解,了解的同学这部分可以直接跳过,看下一部分<br></p>
<p><strong>Method Swizzle方法交换</strong><br></p>
<p>runtime 提供了一些 api 来让我们实现方法交换,现在假设有这么一段代码:</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/448f73738ec247ffb300687ec6f3b910~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>使用 NSURL 初始化 URL 的时候，如果 URL 中含有中文，那么初始化就会失败返回 nil。这个问题做过 iOS 开发的同学应该都遇到过，解决的办法就是对 URL 进行一次百分号编码，现在假设一种情景，你刚入职一家新公司，发现了这个问题，然后在工程里面搜索了一下，发现我的天啦，到处都是这种 URL 中夹着中文，而没有进行编码的情况，那么这个时候，你是选择一个一个的去修改呢，还是会想其他更好的办法?</p>
<p>使用方法交换就是更好的办法，新建一个 NSURL 的分类，在分类的 load 方法中,实现我们的方法交换</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/37ae39be58a44d84be2e8b3d8f776c33~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>一个 OC 方法，我们可以分为两个部分，一个是方法名 SEL，一个是方法的实现 IMP。正常情况下，一个方法的名字对应着它的实现。而有时候我们通过 runtime 来交换方法的实现。就如上面的 <code>load</code> 方法里面的代码，默认情况下方法 <code>one</code> 和方法 <code>two</code> 的实现都是指向他们自己的 IMP 的，通过 <code>method_exchangeImplementations()</code> 函数交换之后，方法 <code>one</code> 的实现就指向了方法 <code>two</code> 的实现，而方法 <code>two</code> 的实现就指向了方法 <code>one</code> 的实现，当代码调用 <code>URLWithString:</code> 的时候，就会来到我们的 <code>HK_URLWithString:</code> 方法，当代码调用 <code>HK_URLWithString:</code> 的时候，就会执行 <code>URLWithString:</code> 方法</p>
<p>这样原来工程里的所有 <code>URLWithString:</code> 方法都会执行到我们的代码中去，首先调用一次原始的初始化 URL 的方法，看能否成功生成 url 如果为 nil，就表示我们可能需要对字符串 str 进行一下编码。再用编码过后的 str 初始化 url，这样就不用浪费时间精力去一个一个的去修改工程里的代码了</p>
<h1 id="拦截微信的注册点击"><a href="#拦截微信的注册点击" class="headerlink" title="拦截微信的注册点击"></a>拦截微信的注册点击</h1><p>使用 Debug View Hierarchy 查看微信的登录注册页面的视图层次结构，找到注册的按钮，查看按钮的 target 和 action</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/ca5a9d2062f94a66819e4b3d7c70342e~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>我们知道了注册按钮点击的时候，会调用 <code>WCAccountLoginControlLogic</code> 的 <code>onFirstViewRegister</code> 方法，而且我们也已经可以在我们的 Framework 中执行我们的注入代码了，那么接下来我们如何实现拦截微信的注册按钮点击呢？当然可以使用 Method Swizzle 来实现</p>
<p>在开始写代码实现方法交换之前，还有一个小小的问题，虽然我们根据经验可以知道这个 <code>onFirstViewRegister</code> 应该是个对象方法，可能没有返回值也没有参数，但这些都只是根据我们经验的猜测…关考猜测可不行，那么怎么验证我们的猜测呢？</p>
<p><a href="https://github.com/nygard/class-dump"><strong>Class-dump</strong></a> 和 <strong>yololib</strong> 一样，也是一个终端命令行工具，同样也可以放到 usr&#x2F;local&#x2F;bin 目录下可以全局使用，它的作用是可以把 MachO 文件里的头文件信息全部导出来，我们可以 cd 到工程编译生成的 APP 包里面,使用以下命令<br></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">class-dump -H WeChat -o ./headers/</span><br></pre></td></tr></table></figure>

<p>将它的头文件都导到一个 headers 的文件夹内，这个过程需要一点时间</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1d783025112d46a7b01eaec3b73c3bd7~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>看了下这个文件挺大的，导完之后可以把它剪切到工程根目录下，这样给我们手机也能省点空间，也确实完全没必要放在 APP 包里面</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/d734b1bee7d54b31b18821dba3857f24~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>可以看到这里面有 15074 个项目，微信的头文件还真不少呢…这么大的文件夹如果我们用 Xcode 打开搜索的话，一定会十分的痛苦。这里推荐使用 sublime…更轻量一点，找起头文件来也更快，搜索一番发现如图所示</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/91d0302f97474f3295c318d5234d8944~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这样就确保了这个 <code>onFirstViewRegister</code> 方法是无返回值无参数的，可以开始编写代码实现拦截了</p>
<p>现在我们可以来到我们 Framework 的 CodeInject.m 文件写点代码</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1303896e20f242a69833262c714c29e9~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>代码就这么点，现在 command + R 运行起来之后，再次点击微信的注册按钮试试看？</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/c3fbbc9607184b71b639734374708a27~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<h1 id="窃取用户的账号密码"><a href="#窃取用户的账号密码" class="headerlink" title="窃取用户的账号密码"></a>窃取用户的账号密码</h1><p>上面的需求仅仅只是破坏了功能，原来的功能都没法使用了。接下来这个需求让用户在神不知鬼不觉的情况下，账号密码就被窃取了（所以市面上那些来源不明的 App 真不要下载使用，除非你也是搞逆向研究的）。那么我们在什么时候，能拿到用户的账号和密码呢？当然是点击登录按钮的时候，所以你懂的，使用 viewDebug 查看登录按钮</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/f7a259179375477c850d9ec4e85e6cff~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>登录按钮点击的 target:<code>WCAccountMainLoginViewController</code>,action:<code>onNext</code>;</p>
<p>查看刚刚 class-dump 出来的头文件发现这个 onNext 方法是没有参数的，那么我们需要的账号密码在哪里呢？哈哈，有经验的同学是不是发现这两个名字是不是莫名的熟悉</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">WCAccountTextFieldItem *_textFieldUserNameItem;</span><br><span class="line">WCAccountTextFieldItem *_textFieldUserPwdItem;</span><br></pre></td></tr></table></figure>

<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/f71ee81de1e24f7e9abf2f6c5100420f~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>变量名是挺熟悉的，但是这个 <code>WCAccountTextFieldItem</code> 我们不知道是个什么东西怎么办？头文件都在手上了还问怎么办，接着搜索啊…</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/750ecea4818247c8b7773d78750e4cab~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p><code>WCAccountTextFieldItem</code> 里面貌似没啥东西，那就看它父类 <code>WCBaseTextFieldItem</code></p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/f44b4b6fd6b94c2fb6cfb3e138e3b213~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>在 <code>WCBaseTextFieldItem</code> 类里面发现了一个 <code>WXUITextField</code> 的东西,跟我们熟悉的 <code>UITextField</code> 很像了，我们猜测可能就是这个 <code>m_textField</code> 存放着我们想要的东西，先不着急写代码</p>
<p>现在我们可以再次使用 viewDebug 工具调试查看一下我们的账号和密码在哪里，并且使用 lldb 来动态调试验证我们的猜测</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/4f7d5f230f76437e9438557b03ff5490~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>首先控制器的地址，可以由登录按钮的 target 获取到。获取到控制器之后，再使用 KVC 大法获取成员变量 <code>_textFieldUserPwdItem</code> 的地址(密码都能获取到了，账号也是一样的操作)并打印它。获取到 <code>_textFieldUserPwdItem</code> 的地址之后，再次使用 KVC 大法获取它的成员变量 <code>m_textField</code> 的地址并打印这个对象，好家伙，明文密码不就在这儿了吗!!!</p>
<p>接下来我们通过代码来实现需求:</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/935ac041181d4ebb9647deb4dadd555d~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>这代码看起来跟拦截微信注册的代码差不太多，那么我们 command + R 运行看看结果</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/736508d48fa74925978c44a80393e619~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>WTF？账号密码确实是都获取到了，但是 APP 却崩溃了？为什么会发生崩溃，崩溃信息是我们经常能够遇到的经典报错 <code>unrecognized selector sent to instance 0x10b15b400</code> 说是控制器 <code>WCAccountMainLoginViewController</code> 无法识别 <code>FK_onNext</code> 这个方法</p>
<p>我们思考一下，方法交换为什么一般推荐写在想要交换方法的类所在的分类里面？因为在想要交换方法的类的分类当中，我们会新增一个方法，用来实现我们的逻辑，也正好是因为在分类中，所以当前类自然的添加了我们新增的方法，这样交换下来就不会出现找不到方法的错误</p>
<p>而上面的代码，我们的本意也是希望在 <code>WCAccountMainLoginViewController</code> 里面新增一个方法处理我们的逻辑，并交换 <code>onNext</code> 方法，但现在的问题是我们在 <code>CodeInject</code> 这个类的 <code>load</code> 方法中，那么有什么办法可以解决这个问题呢？</p>
<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><p>rumtime 的 api 提供了运行时动态添加方法的能力</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL</span><br><span class="line"><span class="title function_">class_addMethod</span><span class="params">(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, <span class="type">const</span> <span class="type">char</span> * _Nullable types)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数1: 给哪个类添加方法</li>
<li>参数2: 方法的名字</li>
<li>参数3: 方法的实现</li>
<li>参数4: 方法的参数和返回值描述,用一些特定的符号表示,也可以不写</li>
<li>参数5: BOOL值,表示是否添加成功</li>
</ul>
<p>那么借用这个 api 我们能想到什么解决办法呢，给 <code>WCAccountMainLoginViewController</code> 控制器添加我们的 <code>FK_onNext</code> 方法，再让 <code>FK_onNext</code> 和 <code>onNext</code> 方法交换，最终的代码如下</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/c78c52886b3b41c3849c099e1634f3f3~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>再次 command + R 运行发现，既能成功获取到用户输入的账号密码，又能成功的去调用微信的登录逻辑了</p>
<h3 id="动态替换方法"><a href="#动态替换方法" class="headerlink" title="动态替换方法"></a>动态替换方法</h3><p>现在除了添加新方法的方式，我们还有其他的办法吗？当然有(强大的runtime) rumtime 的 api 还提供了运行时替换方法的能力</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IMP _Nullable</span><br><span class="line"><span class="title function_">class_replaceMethod</span><span class="params">(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, <span class="type">const</span> <span class="type">char</span> * _Nullable types)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数1: 替换哪个类</li>
<li>参数2: 方法的名字</li>
<li>参数3: 方法的实现</li>
<li>参数4: 方法的参数和返回值描述,用一些特定的符号表示,也可以不写</li>
<li>返回值: IMP，原始的方法实现</li>
</ul>
<p>如果使用这个方式，那么我们应该是将原始的 <code>onNext</code> 方法替换成我们的 <code>FK_onNext</code> 方法，那么我们如何去调用微信原始的 <code>onNext</code> 方法呢，在替换之前将原始的 <code>onNext</code> 方法的实现 IMP 记录下来，然后在我们的 <code>FK_onNext</code> 方法中使用这个记录的 IMP 来实现对原始 <code>onNext</code> 的调用，具体代码如下图:</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/dea8641224fa410a9830ea57b23be7d1~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>对比方法交换的代码实现，我们发现方法替换的方式需要多一个变量 <code>originalIMP</code>，用来记录原始的 <code>onNext</code> 方法的实现，而且还会报个警告，虽然少了一点点代码，但看起来也不是那么好理解…当然，这里使用方法替换也只是为了学习一下 runtime 提供的 api，感受一下 rumtime 的强大，具体使用哪个方式就看个人的喜好</p>
<h3 id="动态获取方法实现和设置方法实现"><a href="#动态获取方法实现和设置方法实现" class="headerlink" title="动态获取方法实现和设置方法实现"></a>动态获取方法实现和设置方法实现</h3><p>那么,还有更骚的操作吗？当然有…</p>
<p>获取方法 m 的实现 IMP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IMP _Nonnull</span><br><span class="line"><span class="title function_">method_getImplementation</span><span class="params">(Method _Nonnull m)</span></span><br></pre></td></tr></table></figure>

<p>设置方法 m 的实现 IMP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IMP _Nonnull</span><br><span class="line"><span class="title function_">method_setImplementation</span><span class="params">(Method _Nonnull m, IMP _Nonnull imp)</span></span><br></pre></td></tr></table></figure>

<p>这个原理其实跟替换差不太多，首先获取原始 <code>onNext</code> 的实现并记录，然后设置新的 IMP(我们写的 <code>FK_onNext</code> )给 <code>WCAccountMainLoginViewController</code> 的 <code>onNext</code> 方法，具体代码如下：</p>
<img src="/2021/06/24/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/dfd4a8d6d9b0480584bcf4c782353eaf~tplv-k3u1fbpfcp-watermark.png" class="" alt="image.png">

<p>好了，到此我们为了实现窃取用户的账号密码已经使用了三种 runtime 提供的方式…到这里就真的没了</p>
<p>从上一篇 iOS 重签名，到这一篇的代码注入，如果你使用过 MonkeyDev 工具的 MonkeyApp 就会发现是如此的相似。其实这就是 MonkeyDev 的实现原理，只是 MonkeyDev 的实现更加复杂。</p>
<p>下一篇文章开始介绍我们最近一直提到的 MachO 文件，到底什么是 MachO 文件，它包含了什么东西，干什么用的…</p>
<h1 id="反微信重签名检测"><a href="#反微信重签名检测" class="headerlink" title="反微信重签名检测"></a>反微信重签名检测</h1><p>如果你希望在重签名的微信上登录账号使用，最好在添加以下代码绕过微信的检测。否则会有封号的风险，不保证以下代码长期有效。将以下代码粘贴到 CodeInject.m 文件中，不要放到类的实现中就行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="built_in">NSUUID</span>* (*original_advertisingIdentifier)(<span class="type">id</span>, SEL);</span><br><span class="line"><span class="type">void</span> (*original_setBundleId)(<span class="type">id</span>, SEL, <span class="built_in">NSString</span>*);</span><br><span class="line"><span class="type">void</span> (*original_setClientSeqId)(<span class="type">id</span>, SEL, <span class="built_in">NSString</span>*);</span><br><span class="line"><span class="type">void</span> (*original_setDeviceName)(<span class="type">id</span>, SEL, <span class="built_in">NSString</span>*);</span><br><span class="line"><span class="type">void</span> (*original_addLogInfo_withMessage)(<span class="type">id</span>, SEL,<span class="type">int</span> *,<span class="keyword">const</span> <span class="type">char</span> *);</span><br><span class="line"><span class="type">BOOL</span> (*original_HasInstallJailbreakPluginInvalidIAPPurchase)(<span class="type">id</span>, SEL);</span><br><span class="line"><span class="type">BOOL</span> (*original_IsJailBreak)(<span class="type">id</span>, SEL);</span><br><span class="line"><span class="type">BOOL</span> (*original_HasInstallJailbreakPlugin)(<span class="type">id</span>, SEL, <span class="type">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUUID</span>* hook_advertisingIdentifier(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSUUID</span> *advertisingIdentifier;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@&quot;idfa&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *idfa = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] stringForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (idfa &amp;&amp; idfa.length)&#123;</span><br><span class="line">        advertisingIdentifier = [[<span class="built_in">NSUUID</span> alloc] initWithUUIDString:idfa];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        advertisingIdentifier = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:advertisingIdentifier.UUIDString forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advertisingIdentifier;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> hook_setBundleId(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *bundleId) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([bundleId isEqualToString:[<span class="built_in">NSBundle</span> mainBundle].bundleIdentifier]) &#123;</span><br><span class="line">        bundleId = <span class="string">@&quot;com.tencent.xin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    original_setBundleId(<span class="keyword">self</span>, _cmd, bundleId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> hook_setClientDeqId(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *clientSeqId) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@&quot;clientSeqId&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *clientSeqId_fist = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] stringForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (!clientSeqId_fist || clientSeqId_fist.length == <span class="number">0</span>) &#123;</span><br><span class="line">        clientSeqId_fist = [[<span class="built_in">NSUUID</span> UUID].UUIDString stringByReplacingOccurrencesOfString:<span class="string">@&quot;-&quot;</span> withString:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:clientSeqId_fist forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *newClientSeqId;</span><br><span class="line">    <span class="keyword">if</span> ([clientSeqId containsString:<span class="string">@&quot;-&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSRange</span> range = [clientSeqId rangeOfString:<span class="string">@&quot;-&quot;</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *clientSeqId_last = [clientSeqId substringFromIndex:range.location];</span><br><span class="line">        newClientSeqId = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@&quot;</span>, clientSeqId_fist, clientSeqId_last];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newClientSeqId = clientSeqId_fist;</span><br><span class="line">    &#125;</span><br><span class="line">    original_setClientSeqId(<span class="keyword">self</span>, _cmd, newClientSeqId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> hook_setDeviceName(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *deviceName) &#123;</span><br><span class="line">    original_setDeviceName(<span class="keyword">self</span>, _cmd, <span class="string">@&quot;iPhone&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> hook_addLogInfo_withMessage(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="type">int</span> *arg1, <span class="keyword">const</span> <span class="type">char</span> *arg2) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">BOOL</span> hook_original_HasInstallJailbreakPluginInvalidIAPPurchase(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">BOOL</span> hook_IsJailBreak(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">BOOL</span> hook_HasInstallJailbreakPlugin(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="type">id</span> arg1) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有被 hook 的类和函数放在这里的构造函数中</span></span><br><span class="line">__attribute__((constructor)) <span class="keyword">static</span> <span class="type">void</span> hookMethods(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;ASIdentifierManager&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            Method method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(advertisingIdentifier));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_advertisingIdentifier = (<span class="built_in">NSUUID</span>*(*)(<span class="type">id</span>, SEL))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_advertisingIdentifier);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;ManualAuthAesReqData&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            Method method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(setBundleId:));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_setBundleId = (<span class="type">void</span>(*)(<span class="type">id</span>,SEL,<span class="built_in">NSString</span>*))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_setBundleId);</span><br><span class="line">            &#125;</span><br><span class="line">            method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(setClientSeqId:));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_setBundleId = (<span class="type">void</span>(*)(<span class="type">id</span>,SEL,<span class="built_in">NSString</span>*))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_setBundleId);</span><br><span class="line">            &#125;</span><br><span class="line">            method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(setDeviceName:));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_setDeviceName = (<span class="type">void</span>(*)(<span class="type">id</span>,SEL,<span class="built_in">NSString</span>*))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_setDeviceName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;MMCrashReportExtLogMgr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            Method method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(addLogInfo:withMessage:));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_addLogInfo_withMessage = (<span class="type">void</span>(*)(<span class="type">id</span>,SEL,<span class="type">int</span>*,<span class="keyword">const</span> <span class="type">char</span>*))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_addLogInfo_withMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;JailBreakHelper&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            Method method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(HasInstallJailbreakPluginInvalidIAPPurchase));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_HasInstallJailbreakPluginInvalidIAPPurchase = (<span class="type">BOOL</span>(*)(<span class="type">id</span>,SEL))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_original_HasInstallJailbreakPluginInvalidIAPPurchase);</span><br><span class="line">            &#125;</span><br><span class="line">            method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(IsJailBreak));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_IsJailBreak = (<span class="type">BOOL</span>(*)(<span class="type">id</span>,SEL))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_IsJailBreak);</span><br><span class="line">            &#125;</span><br><span class="line">            method = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(HasInstallJailbreakPlugin:));</span><br><span class="line">            <span class="keyword">if</span> (method) &#123;</span><br><span class="line">                original_HasInstallJailbreakPlugin = (<span class="type">BOOL</span>(*)(<span class="type">id</span>,SEL,<span class="type">id</span>))method_getImplementation(method);</span><br><span class="line">                method_setImplementation(method, (IMP)hook_HasInstallJailbreakPlugin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>yololib</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理导图</title>
    <url>/2025/04/25/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="iOS-底层原理导图"><a href="#iOS-底层原理导图" class="headerlink" title="iOS 底层原理导图"></a>iOS 底层原理导图</h1><ul>
<li><p>iOS 底层知识入门</p>
</li>
<li><p>KVC </p>
</li>
<li><p>KVO </p>
</li>
<li><p>Category</p>
</li>
<li><p>关联对象</p>
</li>
<li><p>Block</p>
</li>
<li><p>Runtime</p>
<ul>
<li>深入理解iOS对象模型（一）：实例对象的内存探秘</li>
<li>Objective-C 类对象</li>
</ul>
</li>
<li><p>Runloop</p>
</li>
<li><p>多线程</p>
<ul>
<li>线程同步方案（锁、串行队列）</li>
</ul>
</li>
<li><p>内存管理</p>
</li>
<li><p>性能优化</p>
</li>
<li><p>架构设计</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>揭开神秘的iOS布局</title>
    <url>/2018/03/26/%E6%8F%AD%E7%A7%98iOS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>翻译自: <a href="http://tech.gc.com/demystifying-ios-layout/">Demystifying iOS Layout</a></p>
<p>在你刚开始开发iOS应用时,最难避免或者说最难调试的是处理视图的布局和内容;通常这些事情的发生是因为对 <strong>视图更新</strong> 真实发生存在误解;了解 <strong>视图更新</strong> 的方式和时间需要更深入地了解iOS应用程序的主运行循环,以及它如何与<code>UIView</code>提供的某些方法关联;这篇博文将解释这些互动,希望澄清如何使用<code>UIView</code>的方法来获得你想要的行为;</p>
<h2 id="iOS应用程序的主运行循环"><a href="#iOS应用程序的主运行循环" class="headerlink" title="iOS应用程序的主运行循环"></a>iOS应用程序的主运行循环</h2><p>iOS应用程序的主运行循环用来处理所有用户输入事件并在您的应用程序中触发适当的响应;任何与应用程序的用户交互都会被添加到事件队列中;应用程序对象(如下图所示)将事件队列中的事件取出,并将它们分派给应用程序中的其他对象;<strong>它本质上是通过解释来自用户的输入事件并在应用程序的核心对象中为该输入调用相应的处理程序来执行运行循环</strong>;这些处理程序调用应用程序开发人员编写的代码;一旦这些方法调用返回,控制回到主运行循环并且开始更新周期;更新周期负责布局和重绘视图(在下一节中介绍);下面是应用程序如何与设备进行通信并处理用户输入的插图</p>
<p>538</p>
<p><em><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html">https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html</a></em></p>
<h2 id="更新周期-Update-Cycle"><a href="#更新周期-Update-Cycle" class="headerlink" title="更新周期(Update Cycle)"></a>更新周期(Update Cycle)</h2><p>更新周期是应用程序完成运行所有事件处理代码后,控制权返回到主运行循环的点;就是在这个点,系统开始更新布局,显示和约束;如果您要求改变视图而它正在执行事件处理程序,系统会将此视图标记为需要重绘;在下一次更新周期,系统将执行这些视图上所有的变化;用户交互和布局更新之间的时间间隔对用户来说应该是感觉不到的;iOS应用程序通常以60fps动画,这意味着一个刷新周期只需要1&#x2F;60秒;由于这种情况发生的速度很快,用户不会注意到她与设备上的应用程序进行交互和看到内容和布局更新之间的UI的滞后;但是,由于事件被执行的时间和相应视图的重绘时间之间存在时间间隔,所以在运行循环过程中,视图可能不会按照您希望的方式更新;如果您有任何计算依赖视图最新的内容或布局,您有可能操作的是该视图的旧的内容或布局而不是最新的;了解运行循环,更新周期和某些的<code>UIView</code>方法能够帮助避免或者调试这类问题;</p>
<p>您可以在下图中看到更新周期在运行循环结束时如何发生<br>1185</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>视图的布局指的是它在屏幕上的大小和位置;每一个视图都有一个<code>frame</code>属性来描述它在父视图坐标系统中的位置以及它的大小;<code>UIView</code>提供了一些方法,可以让你通知系统一个视图的布局已经改变,同时为你提供了可以重写的方法,以便在重新计算视图的布局后定义要执行的操作</p>
<h3 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews()"></a>layoutSubviews()</h3><p>这个<code>UIView</code>方法调整视图及其所有子视图的大小和位置;它给出当前视图和每个子视图的位置和大小;此方法很昂贵,因为它对视图的所有子视图起作用并调用其相应的<code>layoutSubviews</code>方法;系统会在任何需要重新计算视图的 frame 属性时调用此方法,因此当您想要设置 frame 属性指定视图位置和大小的时候您应该重写此方法;但是,当您的视图层次结构需要布局刷新时,您绝不应该显示的调用它;相反,在运行循环期间,您可以使用多种机制在不同点触发<code>layoutSubviews</code>调用,这比直接调用<code>layoutSubviews</code>方法要便宜的多;</p>
<p>当<code>layoutSubviews</code>方法完成时,将在拥有该视图的视图控制器中触发对<code>viewDidLayoutSubviews</code>的调用;<strong>由于<code>layoutSubviews</code>是更新视图布局后可靠调用的唯一方法,因此应该将任何取决于布局和大小的逻辑代码方法<code>viewDidLayoutSubviews</code>中,而不是放在<code>viewDidLoad</code>或<code>viewDidAppear</code>中</strong>;这是避免使用过时的布局或者位置变量的唯一方法。</p>
<h2 id="自动刷新触发器"><a href="#自动刷新触发器" class="headerlink" title="自动刷新触发器"></a>自动刷新触发器</h2><p>有多个事件会自动地将视图标记为布局已经改变,所以该视图的<code>layoutSubviews</code>方法将在下一次更新周期时被系统调用,不需要开发人员手动执行这个方法;</p>
<p>这些自动将视图标记为布局已经改变的方式有以下几种:</p>
<ul>
<li>改变视图的大小</li>
<li>添加子视图</li>
<li>用户滚动<code>UIScrollView</code>(<code>layoutSubviews</code>方法会被<code>UIScrollView</code>以及它的父视图调用)</li>
<li>用户旋转设备</li>
<li>更新视图的约束</li>
</ul>
<p>以上这些方式都告诉系统,视图的位置需要重新计算并且会自动导致最终的<code>layoutSubviews</code>方法的调用;当然,也有直接触发<code>layoutSubviews</code>方法调用的办法;</p>
<h3 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout()"></a>setNeedsLayout()</h3><p>触发<code>layoutSubviews</code>调用最省资源的方式就是在您的视图上调用<code>setNeedsLayout</code>方法;这将指示系统这个视图的布局需要重新计算;<code>setNeedsLayout</code>执行并立即返回,并且在返回之前并不实际更新视图;相反,视图将会在下一个更新周期(系统调用这些视图以及后续所有子视图的<code>layoutSubviews</code>方法)实际更新视图的布局;即使从<code>setNeedsLayout</code>返回后到视图被重新绘制布局之间有一段任意的时间间隔,但是这个延迟不会对用户造成影响,因为永远不会长到对界面造成卡顿;</p>
<h3 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded()"></a>layoutIfNeeded()</h3><p><code>layoutIfNeeded</code>是<code>UIView</code>的另一个将会在不久后触发<code>layoutSubviews</code>调用的方法;与<code>setNeedsLayout</code>会让视图在下一个周期调用<code>layoutSubviews</code>更新视图不同,<code>layoutIfNeeded</code>会立即触发<code>layoutSubviews</code>方法调用,如果视图需要布局更新的话;如果你在调用<code>setNeedsLayout</code>方法或者触发上面描述的自动刷新触发器之后调用了<code>layoutIfNeeded</code>方法,<code>layoutSubviews</code>将会在视图上被调用;然而,如果你调用<code>layoutIfNeeded</code>之后没有动作指示系统视图需要重新刷新视图,那么<code>layoutSubviews</code>方法将不会被调用;<br>在一次运行循环中,两次调用视图的<code>layoutIfNeeded</code>方法之间,视图的布局并没有变化的话,那么第二次调用将不会触发<code>layoutSubviews</code>的调用;</p>
<p>与<code>setNeedsLayout</code>方法不同,使用<code>layoutIfNeeded</code>方法,布局和重绘会在函数返回之前立即发生改变(除非有正在运行中的动画);这个方法在你需要依赖新的布局而又无法等待视图的下次更新周期到来的时候特别有用;然而,除了这种情况外,你还是应该调用<code>setNeedsLayout</code>然后等待下次更新周期的到来,这样在每次运行循环中都只会更新一次布局;</p>
<p>动画更改约束时,此方法特别有用;您应该在动画的 block 开始之前调用一次<code>layoutIfNeeded</code>,以确保在动画开始之前通知所有的布局更新;配置新的约束,然后在动画 block 内,再次调用<code>layoutIfNeeded</code>以动画到最新的状态;</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>视图的显示包含颜色,文本,图片和Core Graphics绘制等视图属性,但不包含它和它的子视图的大小和位置;和布局的方法类似,显示也有触发更新的方法,它们由系统在检测到更新时被自动调用,或者我们可以手动调用直接触发更新;</p>
<h3 id="draw"><a href="#draw" class="headerlink" title="draw(_:)"></a>draw(_:)</h3><p><code>UIView</code>的<code>draw</code>方法(Objective-C中的<code>drawRect</code>)对视图的显示内容的作用	就像 <code>layoutSubviews</code>方法对视图的位置和尺寸的作用;同<code>layoutSubviews</code>一样,你不应该在代码中直接调用<code>draw</code>方法,而应该在运行循环的不同点调用能触发<code>draw</code>方法调用的方法;然而,与<code>layoutSubviews</code>方法不同的是,<code>draw</code>方法不会触发后续子视图的调用;</p>
<h3 id="setNeedsDisplay"><a href="#setNeedsDisplay" class="headerlink" title="setNeedsDisplay()"></a>setNeedsDisplay()</h3><p>这个方法类似布局中的<code>setNeedsLayout</code>;它会给有显示内容更新的视图设置一个内部的标记之后返回,并不会真正的视图重绘;而是在接下来的更新周期中,系统会遍历所有已被标记的视图,调用它们的<code>draw</code>方法;如果你只想在下次更新时重绘部分的视图,你可以调用<code>setNeedsDisplay(_:)</code>(Objective-C中的<code>setNeedsDisplayInRect:</code>)方法,并把希望重绘的矩形部分传入参数;</p>
<p>大部分时候,在视图中更新任何 UI 组件都会通过自动设置内部的”显示内容更新”标记将视图标记为”dirty”的;导致在下一次更新周期中视图的内容就会重绘而不需要直接显示调用<code>setNeedsDisplay</code>;然而如果你有一个属性没有绑定到UI控件,但需要在属性值每次更新重绘视图,那么你可以实现该属性的<code>didSet</code>方法,并在里面调用<code>setNeedsDisplay</code>方法来触发视图的更新;</p>
<p>有时设置一个属性要求自定义绘制,这种情况下你需要重写<code>draw</code>方法;在下面的例子中,设置<code>numberOfPoints</code>会触发系统根据具体点数绘制不同的视图;在这个例子中,你需要在<code>draw</code>方法中实现自定义绘制,并在<code>numberOfPoints</code>的property observer里调用<code>setNeedsDisplay</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class MyView: UIView &#123;</span><br><span class="line">	var numberOfPoints = 0 &#123;</span><br><span class="line">		didSet &#123;</span><br><span class="line">			setNeedsDisplay()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	override func draw(_ rect: CGRect) &#123;</span><br><span class="line">		switch numberOfPoints &#123;</span><br><span class="line">		case 0: </span><br><span class="line">			return</span><br><span class="line">		case 1: </span><br><span class="line">			drawPoint(rect)</span><br><span class="line">		case 2:</span><br><span class="line">			drawLine(rect)</span><br><span class="line">		case 3: </span><br><span class="line">			drawTriangle(rect)</span><br><span class="line">		case 4:</span><br><span class="line">			drawRectangle(rect)</span><br><span class="line">		case 5: </span><br><span class="line">			drawPentagon(rect)</span><br><span class="line">		default:</span><br><span class="line">			drawEllipse(rect)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视图的显示方法里没有类似布局中的<code>layoutIfNeeded</code>这样可以触发立即更新的方法;通常情况下等到下一个更新周期再重新绘制视图也无所谓;</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>在自动布局技术中布局和重绘视图有三个步骤;第一步是更新约束,系统计算并设置视图上所有必需的约束条件;第二步是布局阶段,布局引擎计算视图和子视图的 frame 并且将它们布局;最后一步完成这一循环的是显示阶段;第三步完成此次循环的是显示阶段,如果有必要,那么通过调用视图的<code>draw</code>方法重绘视图的内容;</p>
<h3 id="updateConstraints"><a href="#updateConstraints" class="headerlink" title="updateConstraints()"></a>updateConstraints()</h3><p>这个方法用在自动布局中动态的改变视图的约束;和布局中的<code>layoutSubviews</code>方法和显示内容中的<code>draw</code>方法类似,<code>updateConstraints</code>只应该被重写,而不应该在你的代码中直接调用;一般来说,您应该在<code>updateConstraints</code>方法中仅仅实现必须要更新的约束;静态的约束应该设置在interface builder,视图的初始化方法(initializer)或者控制器的<code>viewDidLoad</code>中;</p>
<p>通常情况下,开启或者关闭约束,更改约束的优先级或者常量值,或者从视图层级中移除一个视图时都会设置一个内部的标记,这个标记将会在下一次更新周期触发<code>updateConstraints</code>方法调用;当然啦,也有手动的给视图打上需要更新约束的标记的方法,如下:</p>
<h3 id="setNeedsUpdateConstraints"><a href="#setNeedsUpdateConstraints" class="headerlink" title="setNeedsUpdateConstraints()"></a>setNeedsUpdateConstraints()</h3><p>调用<code>setNeedsUpdateConstraints</code>会保证在下一次的更新周期中更新约束;它通过标记视图的约束已更新来触发<code>updateConstraints</code>调用;这个方法和<code>setNeedsDisplay</code>,<code>setNeedsLayout</code>方法的工作机制类似;</p>
<h3 id="updateConstraintsIfNeeded"><a href="#updateConstraintsIfNeeded" class="headerlink" title="updateConstraintsIfNeeded()"></a>updateConstraintsIfNeeded()</h3><p>这个方法就等同于使用了自动布局的视图中的<code>layoutIfNeeded</code>方法;它会检查视图约束是否更新的标记(能够被自动设置,或者通过<code>setNeedsUpdateConstraints</code>设置,或者通过<code>invalidateInstrinsicContentSize</code>设置),如果它表明约束需要更新,它将立刻触发<code>updateConstraints</code>方法的调用而不需要等到运行循环的结束;</p>
<h3 id="invalidateIntrinsicContentSize"><a href="#invalidateIntrinsicContentSize" class="headerlink" title="invalidateIntrinsicContentSize()"></a>invalidateIntrinsicContentSize()</h3><p>一些使用自动布局的视图中会有一个<code>intrinsicContentSize</code>的属性,这是视图根据它的内容得到的自然尺寸;一个视图的<code>intrinsicContentSize</code>属性通常由所包含的元素的约束来决定,但是也可以通过重写来提供自定义的行为;调用<code>invalidateIntrinsicContentSize</code>会设置一个标记表示这个视图的<code>intrinsicContentSize</code>已经过期,需要在下一个布局阶段重新计算;</p>
<h2 id="它们是如何连接的"><a href="#它们是如何连接的" class="headerlink" title="它们是如何连接的"></a>它们是如何连接的</h2><p>视图的布局,显示以及约束都遵循着相似的模式,例如它们更新的方式以及如何在运行循环的不同点上强制更新;任意组件都有一个实际去更新的方法(<code>layoutSubviews</code>,<code>draw</code>,以及<code>updateConstraints</code>),你可以重写来手动操作视图,但是任何情况下都不要在你的代码中直接调用;这些方法仅仅在视图有标记,告诉系统视图的某些组件需要更新了,在主运行循环的后面被调用;有些操作会自动设置这个标志,也有一些方法能够让您手动的设置它;对于布局和约束的更新,如果您无法等到更新周期的到来(因为有些操作依赖最新的布局),有这么一些方法可以让你立即更新,并保证布局需要更新标记被正确标记;下面的表格列出了任意组件会怎样更新及其对应方法;</p>
<table>
<thead>
<tr>
<th>Method purposes</th>
<th>Layout</th>
<th>Display</th>
<th>Constraints</th>
</tr>
</thead>
<tbody><tr>
<td>Implement updates(override,don’t call explicitly)</td>
<td><code>layoutSubviews</code></td>
<td><code>draw</code></td>
<td><code>updateConstraints</code></td>
</tr>
<tr>
<td>Explicitly mark view as needing update on next update cycle</td>
<td><code>setNeedsLayout</code></td>
<td><code>setNeedsDisplay</code></td>
<td><code>setNeedsUpdateConstraints</code> <code>invalidateIntrinsicContentSize</code></td>
</tr>
<tr>
<td>Update iimmediately if view is marked as ‘dirty’</td>
<td><code>layoutIfNeeded</code></td>
<td></td>
<td><code>updateConstraintsIfNeeded</code></td>
</tr>
<tr>
<td>Actions that implicitly cause views to be updated</td>
<td><code>addSubview</code><br> Resizing视图,通过<code>setFrame</code>改变视图的<code>bounds</code>(不只是translation)<br>用户滑动UIScrollView<br>用户旋转设备</td>
<td>改变视图的<code>bounds</code></td>
<td>激活&#x2F;禁用约束<br>更改约束的值或者优先级<br>从视图层次结构中移除视图</td>
</tr>
</tbody></table>
<p>下面的流程图总结了<strong>更新周期</strong>和<strong>事件循环</strong>之间的交互,并指出了上文提到的方法在<strong>运行循环</strong>期间的位置;你可以在运行循环中的任意一点直接的调用<code>layoutIfNeeded</code>或者<code>updateConstraintsIfNeeded</code>,需要记住,这开销会很大;在循环的主运行循环的后面是更新周期,如果视图被设置特定的”需要更新约束”,”需要更新布局”或者”需要更新显示”的标记,在这个节点会进行更新约束,更新布局以及更新显示内容;一旦这些更新结束,主运行循环会重新开始;</p>
<p>8831<em><a href="https://i.stack.imgur.com/i9YuN.png">https://i.stack.imgur.com/i9YuN.png</a></em></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学概述</title>
    <url>/2021/06/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>密码学（来自希腊语kryptos，意思是隐藏）一词的核心是指使数据无法被窥探者读取的技术。当然，密码学也可以用于其他目的。密码学包括一系列技术，如验证数据的真实性（检测是否修改）、确定个人或其他实体的身份、确定谁发送了特定消息或创建了特定数据片段、通过网络安全地发送数据、用密码或口令安全地锁定文件等等。</p>
<p>计算机安全中使用的加密主要有两种类型，称为对称密钥加密和非对称密钥加密。</p>
<h1 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h1><p>对称密钥加密（也称为秘密密钥加密）是大多数人熟悉的密钥的经典用法：使用相同的密钥来加密和解密数据。经典且最容易破解的版本是凯撒密码（以朱利叶斯·凯撒命名），其中消息中的每个字母都被替换为字母表中固定位置数的字母（例如，“a”被“c”替换，“b”被替换为“d”等）。在凯撒密码中，用于加密和解密消息的密钥只是字母表旋转的位数以及旋转的方向。现代对称密钥算法更加复杂并且更难破解。</p>
<p>有许多不同的算法用于对称密钥加密，提供从最低限度到几乎牢不可破的安全性。其中一些算法提供了强大的安全性、易于代码实现以及快速的加密和解密。此类算法对于加密存储在计算机上的文件以保护它们以防未经授权的个人使用计算机等目的非常有用。但它们在从一台计算机向另一台计算机发送消息时用处不大，因为通信通道的两端都必须拥有相同的密钥并且必须保证其安全。此类密钥的分发和安全存储可能很困难，并且可能会造成安全漏洞。</p>
<p>虽然交换或创建对称密钥的安全技术可以在一定程度上克服这个问题（例如 Diffie-Hellman 密钥交换），但随着非对称密钥加密算法的发明，出现了一种用于计算机通信的更实用的解决方案。</p>
<p>常见的现代对称密钥加密算法有 DES，3DES，AES 等</p>
<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准，随后在国际上广泛流传开来。</p>
<p>DES 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。1999 年 1 月，distributed.net 与电子前哨基金会合作，在 22 小时 15 分钟内即公开破解了一个 DES 密钥。<br>也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用 DES 的派生算法 3DES 来进行加密，虽然 3DES 也存在理论上的攻击方法。DES 标准和 3DES 标准已逐渐被高级加密标准（AES）所取代。</p>
<h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><p>三重数据加密算法（英语：Triple Data Encryption Algorithm，缩写为 TDEA，Triple DEA），或称 3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次资料加密标准（DES）算法。由于计算机运算能力的增强，原版 DES 由于密钥长度过低容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称 Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。现在，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
<p>该算法为比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，结合两位作者的名字，以 Rijndael 为名投稿高级加密标准的甄选流程。</p>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>对称加密算法的加密模式是指在对称加密过程中，明文如何被切分、填充和加密，以及密文如何被解密和还原成原始的明文。常见的对称加密算法包括 AES（高级加密标准）和 DES（数据加密标准），它们可以使用不同的加密模式来实现数据的保密性。</p>
<p>虽然加密模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对 RSA 进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p>
<p>常见的对称加密模式包括：</p>
<ul>
<li>电子密码本模式（ECB）：是最简单的加密模式，将明文分成固定大小的块，然后每个块单独加密。这种模式的问题在于相同的明文块会加密成相同的密文块，可能导致安全性问题。</li>
<li>密码分组链接模式（CBC）：1976 年，IBM 发明了密码分组链接（CBC，Cipher-block chaining）模式。在 CBC 模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</li>
<li>计数器模式（CTR）：将一个计数器与明文块进行加密，然后再将结果与明文进行异或操作，从而产生密文。这种模式可以并行处理，并且不需要对明文进行填充，因此在某些情况下更高效。</li>
<li>密文反馈模式（CFB）：将前一个密文块作为加密器的输入，然后将结果与明文进行异或操作，得到密文。这种模式可以进行流加密，即逐位地进行加密和解密。</li>
<li>输出反馈模式（OFB）：类似于CFB，但是加密器的输出用于生成密钥流，而不是直接与明文进行异或操作。</li>
</ul>
<p>这些加密模式的选择取决于应用场景、安全需求和性能要求。在实际应用中，需要根据具体情况选择最合适的加密方式和模式。</p>
<h2 id="对称加密的终端练习"><a href="#对称加密的终端练习" class="headerlink" title="对称加密的终端练习"></a>对称加密的终端练习</h2><p>MacOS 自带了一个叫 OpenSSL 的开源加密工具包，提供了一系列的加密算法和安全通信协议的实现，包括 SSL 和 TLS。它由一组函数库和命令行工具组成，可以用于处理数字证书、实现安全通信协议、进行加密和解密等任务。</p>
<p>由于 DES，3DES 目前都不太推荐了，所以这里仅使用 AES 算法演示。</p>
<p>使用 openssl 对明文 helloworld 进行 AES 算法 ECB 模式加密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-ecb -a -pbkdf2 -K 123456</span><br></pre></td></tr></table></figure>

<p>会输出如下结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bnPkNleniCxX5rE1JjnOYg==</span><br></pre></td></tr></table></figure>

<p>对以上结果解密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bnPkNleniCxX5rE1JjnOYg==&quot;</span> | openssl enc -d -aes-256-ecb -a -pbkdf2 -K</span><br><span class="line"> 123456</span><br></pre></td></tr></table></figure>


<p>对明文 helloworld 进行 aes cbc 加密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> helloworld | openssl enc -e -aes-256-cbc -a -pbkdf2 -K 123456</span><br><span class="line">U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8=</span><br></pre></td></tr></table></figure>

<p>这里 -k 后面的参数 123456 就是用到的密钥。对上面的输出进行解密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8= | openssl enc -d -aes-256</span><br><span class="line">-cbc -a -pbkdf2 -K 123456</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>

<h2 id="iOS-中使用对称加密"><a href="#iOS-中使用对称加密" class="headerlink" title="iOS 中使用对称加密"></a>iOS 中使用对称加密</h2><p>iOS 系统提供了一个 CommonCrypto 库用于加密解密，生成消息摘要（hash）等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;CommonCrypto/CommonCrypto.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *encryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesEncrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesEncrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *decryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesDecrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesDecrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSString</span> *plaintext = <span class="string">@&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@&quot;12345678123456781234567812345678&quot;</span>; <span class="comment">// 32字节长的密钥</span></span><br><span class="line">    <span class="built_in">NSString</span> *iv = <span class="string">@&quot;0123456789abcdef&quot;</span>; <span class="comment">// 16字节长的初始化向量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *plaintextData = [plaintext dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *ivData = [iv dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = encryptAES256CBC(plaintextData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *decryptedData = decryptAES256CBC(encryptedData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted data: %@&quot;</span>, [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上面的 iOS 代码中使用的加密和解密函数，等价于以下 openssl 终端命令：</p>
<p>加密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">dMujh+yeGsbTA0xqdhae4Q==</span><br></pre></td></tr></table></figure>

<p>解密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;dMujh+yeGsbTA0xqdhae4Q==&quot;</span> | openssl enc -d -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">helloworld%</span><br></pre></td></tr></table></figure>

<p>openssl 的 -K 和 -iv 参数的类型是 16 进制编码的字符串。12345678123456781234567812345678 的 16 进制编码就是 3132333435363738313233343536373831323334353637383132333435363738，同样 0123456789abcdef 的 16 进制编码就是 30313233343536373839616263646566</p>
<h1 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h1><p>在非对称密钥加密中，不同的密钥用于加密和解密消息。最有用的非对称密钥算法是那些不能从另一个密钥推导出密钥的算法。在这种情况下，一个密钥可以公开，而另一个密钥则保持安全。这种安排通常称为公钥密码术，并且与对称加密相比具有一些明显的优势：消除了向大量用户分发密钥的必要性，并且该算法可用于身份验证以及加密。</p>
<p>第一个广泛使用的公钥算法由 Ron Rivest、Adi Shamir 和 Len Adleman 于 1977 年描述，被称为 RSA 加密，源自其缩写。尽管此后又创建了其他公钥算法，但 RSA 仍然是最常用的。该方法的数学原理超出了本文档的范围，可以在互联网和许多密码学书籍中找到。该算法基于两个大素数及其乘积的数学运算。人们认为它的强度与分解非常大的数的难度有关。以现代数字计算机当前和可预见的速度，在生成 RSA 密钥时选择足够长的素数应该可以使该算法无限期地安全。然而，这一观点尚未得到数学证明，并且快速分解算法或完全不同的破解 RSA 加密的方法是有可能的。此外，如果实用的量子计算机被开发出来，分解大数将不再是一个棘手的问题。</p>
<p>其他公钥算法基于与 RSA 具有同等复杂性的不同数学，包括 ElGamal 加密和椭圆曲线加密。它们的使用类似于 RSA 加密（尽管它们背后的数学原理不同），并且本文档不会进一步讨论它们。</p>
<h2 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h2><p>1977 年三位麻省理工学院的数学家 罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起设计了一种算法，可以实现非对称加密。这个算法用他们三个人的名字命名，叫做 RSA 算法。</p>
<h3 id="RSA-密钥生成过程"><a href="#RSA-密钥生成过程" class="headerlink" title="RSA 密钥生成过程"></a>RSA 密钥生成过程</h3><p>在 RSA 算法中，首先选择两个大质数 p 和 q，然后计算他们的乘积 n &#x3D; p * q。接下来，计算欧拉函数 φ(n) &#x3D; (p-1)(q-1)。在选择公钥 e 时，需要确保 e 和 φ(n) 互质。<br>然后找到一个整数 d，使得（e * d）mod φ(n) &#x3D; 1。这个 d 就是私钥。</p>
<h3 id="RSA-加密和解密"><a href="#RSA-加密和解密" class="headerlink" title="RSA 加密和解密"></a>RSA 加密和解密</h3><p>在 RSA 加密过程中，明文 m 经过公钥 e 进行加密得到密文 c ，计算公式为 c &#x3D; m<sup>e</sup> % n。在 RSA 解密过程中，密文 c 经过私钥 d 进行解密得到明文 m，计算公式为 m &#x3D; c<sup>d</sup> % n。</p>
<blockquote>
<p>一个问题？在 RSA 算法中，为什么 e 和 φ(n) 互质，d 是 e 的模反元素，就可以保证 M<sup>e * d</sup> % n &#x3D; M 呢？我听过某讲师说是基于欧拉定理，但是欧拉定理的推导中是要求 m 和 n 互质的，但是刚刚 RSA 密钥生成过程中并没有要求 m 和 n 互质，只需要 m 小于 n 就够了。</p>
</blockquote>
<h3 id="RSA-算法的终端练习"><a href="#RSA-算法的终端练习" class="headerlink" title="RSA 算法的终端练习"></a>RSA 算法的终端练习</h3><p>使用 openssl 生成 RSA 私钥的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out private_key.pem 2048</span><br></pre></td></tr></table></figure>

<p>这个命令会生成一个 2048 位长度的 RSA 私钥，并将其保存在名为 private_key.pem 的文件中。</p>
<p>将私钥转换成对应的公钥，可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private_key.pem -out public_key.pem</span><br></pre></td></tr></table></figure>

<p>现在在当前目录下就会存在两个文件，一个是公钥 <em>public_key.pem</em>，一个是私钥 <em>private_key.pem</em> 。</p>
<p>接下来我们使用这对密钥进行加密解密的演示，先创建一个文件 original.txt 存放明文数据，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;密码是123456&quot;</span> &gt; original.txt</span><br></pre></td></tr></table></figure>

<p>使用公钥对 original.txt 文件进行加密并生成一个 encrypted.txt 文件的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -encrypt -<span class="keyword">in</span> original.txt -out encrypted.txt -pubin -inkey public_key.pem</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>cat encrypted.txt </code> 查看加密后的结果，发现是一堆乱码，啥也看不懂。。。接下来使用私钥对 encrypted.txt 文件进行解密并生成一个 decrypted.txt 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -decrypt -<span class="keyword">in</span> encrypted.txt -out decrypted.txt -inkey private_key.pem</span><br></pre></td></tr></table></figure>

<p>使用 <code>cat decrypted.txt </code> 查看解密后的结果，可以看到跟 original.txt 的内容是一模一样的。</p>
<!--
### RSA 的数学原理
理解 RSA 的密钥生成过程和加密解密需要一定的数学基础，欧拉函数，欧拉定理，模反元素。如果不感兴趣的也可以跳过本节内容。

了解欧拉函数之前，首先需要知道什么是两个数互质，如果两个正整数，除了 1 以外，没有其他公因数，那么这两个数就是互质的。

#### 欧拉函数

欧拉函数也称为欧拉 φ 函数（phi函数），通常用符号 φ(n) 表示，是一个与正整数 n 相关的算术函数。它表示小于或等于 n 的正整数中与 n 互质的数的个数。

欧拉函数的性质：

* 如果 n 为质数，那么 φ(n) = n - 1
* 如果 n 是两个互质的整数 a，b 之积，那么 φ(n) = φ(a) * φ(b)

结合上面两点可以得到以下结论，如果 n 是两个质数 p1，p2 之积，那么

φ(n) = φ(p1) * φ(p2) = (p1 - 1) * (p2 - 1)

#### 欧拉定理

如果两个正整数 m 和 n 互质，那么 m 的 φ(n) 次方减去 1，可以被 n 整除。即：

m<sup>φ(n)</sup> mod n = 1

这个是已经证明的数学定理，不需要怀疑它的正确性。将上式两边同时加上 k 次方可以得到

m<sup>k * φ(n)</sup> mod n = 1

再将两边同时乘以 m 可以得到：

m<sup>k * φ(n) + 1</sup> mod n = m

#### 模反元素
-->

<h3 id="iOS-中使用非对称加密算法"><a href="#iOS-中使用非对称加密算法" class="headerlink" title="iOS 中使用非对称加密算法"></a>iOS 中使用非对称加密算法</h3><p>iOS 提供了 Security.framework 框架用于帮助开发者实现各种安全相关的功能。这个框架包含了处理加密、密钥管理、证书、信任策略和安全通信的基本功能。通过使用 Security 框架，开发者可以确保应用程序的数据保护、安全传输和用户身份验证等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Security/Security.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="comment">// 生成密钥对</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)generateKeyPair &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *parameters = @&#123;</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeySizeInBits : @<span class="number">2048</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> createError = <span class="literal">NULL</span>;</span><br><span class="line">    SecKeyRef privateKeyRef = SecKeyCreateRandomKey((__bridge <span class="built_in">CFDictionaryRef</span>)parameters, &amp;createError);</span><br><span class="line">    SecKeyRef publicKeyRef  = SecKeyCopyPublicKey(privateKeyRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (privateKeyRef &amp;&amp; publicKeyRef &amp;&amp; createError == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *publicKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(publicKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *privateKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(privateKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        <span class="keyword">return</span> @&#123;</span><br><span class="line">            <span class="string">@&quot;publicKey&quot;</span>: publicKeyData,</span><br><span class="line">            <span class="string">@&quot;privateKey&quot;</span>: privateKeyData</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed to generate key pair: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)createError);</span><br><span class="line">        <span class="keyword">if</span> (createError) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(createError); <span class="comment">// 释放错误对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (privateKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (publicKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用公钥加密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)encryptDataWithPublicKey:(SecKeyRef)publicKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> encryptedData = SecKeyCreateEncryptedData(publicKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData &amp;&amp; error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *result = (__bridge_transfer <span class="built_in">NSData</span> *)encryptedData;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(encryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)decryptDataWithPrivateKey:(SecKeyRef)privateKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> decryptedData = SecKeyCreateDecryptedData(privateKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="literal">NULL</span> &amp;&amp; decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = (__bridge <span class="built_in">NSData</span> *)decryptedData;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(decryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *keyPair = [<span class="keyword">self</span> generateKeyPair];</span><br><span class="line">    <span class="built_in">NSData</span> *publicKeyData = keyPair[<span class="string">@&quot;publicKey&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *privateKeyData = keyPair[<span class="string">@&quot;privateKey&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (publicKeyData &amp;&amp; privateKeyData) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *attributes = @&#123;</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyClass : (__bridge <span class="type">id</span>)kSecAttrKeyClassPublic</span><br><span class="line">        &#125;.mutableCopy;</span><br><span class="line">        SecKeyRef publicKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)publicKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        attributes[(__bridge <span class="type">id</span>)kSecAttrKeyClass] = (__bridge <span class="type">id</span>)kSecAttrKeyClassPrivate;</span><br><span class="line">        SecKeyRef privateKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)privateKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *originalString = <span class="string">@&quot;Hello, World!&quot;</span>;</span><br><span class="line">        <span class="built_in">NSData</span> *originalData = [originalString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSData</span> *encryptedData = [<span class="keyword">self</span> encryptDataWithPublicKey:publicKeyRef data:originalData];</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted Data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSData</span> *decryptedData = [<span class="keyword">self</span> decryptDataWithPrivateKey:privateKeyRef data:encryptedData];</span><br><span class="line">            <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *decryptedString = [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted String: %@&quot;</span>, decryptedString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h1 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h1><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的。哈希函数是一种将任意大小的输入数据转换为固定长度散列值的算法。哈希函数的主要作用是验证数据的完整性和唯一性，可以简单的理解为二进制数据的身份证或者指纹。常见的哈希函数包括 MD5、SHA-1 和 SHA-256 等。</p>
<p>哈希函数的特点：</p>
<ul>
<li>计算速度快</li>
<li>将任意长度的数据计算出固定长度的哈希值</li>
<li>对相同数据计算得到的结果是不变的</li>
<li>具备单向性，无法逆运算</li>
</ul>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>即 Message Digest 5 的缩写，产生 128 位的哈希值。也就是 32 位 16 进制数。Mac 电脑终端一般自带 md5 命令，可以用于一些简单的计算。例如计算 “12345” 的 md5 值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">md5 -s 12345</span><br><span class="line">MD5 (<span class="string">&quot;12345&quot;</span>) = 827ccb0eea8a706c4c34a16891f84e7b</span><br></pre></td></tr></table></figure>

<p>假设你有两份同名的文件，但是不确定内容是否是一样的。就可以使用 md5 查看两个文件的哈希值。</p>
<p>注意 md5 由于长度较短，目前已经不太安全，因为可以对明文和它的 md5 哈希值建立一个字典，比如 “12345” 的 md5 值是 827ccb0eea8a706c4c34a16891f84e7b 。目前某些解密网站已经建立了这样的字典，如 <a href="https://www.cmd5.com/">https://www.cmd5.com/</a> 所以如果你的需求对安全性要求较高的话，不推荐使用了。但如果是平时用来验证文件的唯一性倒也没什么太大问题。</p>
<h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><p>SHA 代表安全散列算法（Secure Hash Algorithm），是一种广泛使用的密码学哈希函数，用于生成数据的哈希值。哈希函数将输入数据转换为固定长度的数据串，通常是一串数字和字母的组合，该串称为哈希值或消息摘要。SHA 算法的哈希值长度可以根据具体的 SHA 版本而变化，比如 SHA-1 生成 160 位的哈希值，而 SHA-256 生成 256 位的哈希值。目前主流的 SHA 版本主要是 SHA-256 和 SHA-3。这两个版本都是较新的，并且在安全性和性能方面都得到了广泛认可。</p>
<h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>产生 160 位的散列值，目前已经不安全</p>
<h3 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h3><p>SHA-256，SHA-384，SHA-512，散列值长度分别是 256 位，384 位，512 位</p>
<h3 id="SHA-3"><a href="#SHA-3" class="headerlink" title="SHA-3"></a>SHA-3</h3><p>SHA-3 是 NIST 选定的一种新的哈希算法标准，也称为 Keccak。它是在 SHA-2 之后发布的，与 SHA-2 系列不同，SHA-3 提供了与之前版本不同的设计和性能特性。SHA-3 的最常见变体是 SHA-3-256，生成 256 位的哈希值。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>HMAC（Hash-based Message Authentication Code）是一种用于验证消息完整性和真实性的加密方案。</li>
<li>拆词搜索</li>
<li>版权</li>
<li>数字签名</li>
</ul>
<h1 id="base64-编码"><a href="#base64-编码" class="headerlink" title="base64 编码"></a>base64 编码</h1><p>Base64 编码是一种将二进制数据转换成文本数据的编码方式。在 Base64 编码中，每个字符由 64 个字符中的一个表示，因此得名。Base64 编码常用于在网络传输中表示二进制数据，比如在电子邮件中传输附件、在网页中嵌入图片等场景。</p>
<p>Base64 编码的原理是将二进制数据每 6 位转换成一个字符，所以每 3 个字节（24 位）的二进制数据转换成 4 个 Base64 字符。如果原始数据长度不是 3 的倍数，则在末尾补上相应数量的 0，并用 “&#x3D;” 字符填充以保持长度是 4 的倍数。所以以后看到字符串的末尾是 “&#x3D;” 字符的时候，它有可能就是 Base64 编码后的字符串。</p>
<p>Base64 编码使用了 64 个字符，通常是大小写字母 a-z、A-Z、数字 0-9，以及两个额外的字符（通常是”+”和”&#x2F;“）作为基本字符集，不同的实现中有时候会用不同的字符集。</p>
<p>Base64 编码并不是加密算法，因为它可以轻松地被解码还原成原始数据。它的主要作用是在不支持二进制传输的环境中，将二进制数据表示为文本，便于传输和处理。</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是一种用于验证数据完整性和身份验证的技术。它使用非对称加密技术，结合了哈希函数和公钥加密算法，以确保数据的完整性、真实性和不可否认性。</p>
<p>数字签名通常由以下步骤组成：</p>
<ol>
<li>创建消息摘要：发送方使用哈希函数（如 SHA-256）生成消息的摘要或哈希值。这个摘要是一个固定长度的字符串，用于代表原始数据的内容。</li>
<li>使用私钥签名：发送方使用自己的私钥对消息摘要进行加密，形成数字签名。私钥只有发送方知道，因此只有发送方能够使用私钥进行签名。</li>
<li>传输数据：发送方将原始数据与数字签名一起发送给接收方。</li>
<li>验证签名：接收方收到数据后，使用发送方的公钥对数字签名进行解密，得到消息摘要。然后，接收方使用相同的哈希函数生成接收到的原始数据的摘要。如果两个摘要匹配，则表明数据未被篡改，签名有效；否则，数据可能已被篡改或签名无效。</li>
</ol>
<p>数字签名的主要目的是确保数据的完整性和真实性，同时提供身份验证和不可否认性，即发送方不能否认其曾经签署过数据。这使得数字签名在许多领域，如电子商务、数字文档、软件分发等方面发挥了重要作用。</p>
<p>简单的一句话概括，数字签名就是使用私钥对数据的哈希值进行加密。</p>
<h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>数字证书是一种用于加密和认证网络通信的安全工具。它是由一个权威的数字证书颁发机构（Certificate Authority，CA）签发的一种电子文档，用于确认特定实体的身份信息。数字证书包含了一些重要的信息，包括：</p>
<p>一个数字证书通常包含以下信息：</p>
<ul>
<li>主体信息：证书的主体是该证书所代表的实体，通常是一个个人、组织或网络设备。主体信息通常包括名称、电子邮件地址等。</li>
<li>公钥：证书包含了主体的公钥，用于加密和验证数字签名。这个公钥与主体的私钥配对，用于加密和解密通信数据。</li>
<li>证书序列号：每个证书都有一个唯一的序列号，用于标识该证书。</li>
<li>有效期：证书有一个有效期限，指定了证书的生效时间和到期时间。过期的证书不再可信。</li>
<li>数字签名：证书被 CA 用其私钥签名，以确保证书的真实性和完整性。客户端可以使用 CA 的公钥来验证数字签名。</li>
<li>颁发者信息：指定了颁发该证书的 CA 的信息。</li>
<li>扩展信息：可能包含一些其他信息，例如用途、策略等。</li>
</ul>
<p>数字证书在网络通信中广泛用于安全连接的建立，例如 HTTPS（安全的HTTP）、SSL&#x2F;TLS等。通过验证数字证书的真实性，可以确保与远程服务器之间的通信是安全的，并且可以防止中间人攻击等安全威胁。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>密码学</tag>
        <tag>hash</tag>
        <tag>RSA</tag>
        <tag>DES</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title>解决git clone速度慢的问题</title>
    <url>/2018/10/26/%E8%A7%A3%E5%86%B3git-clone%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前一直以为是公司对网络的封锁,导致git clone速度慢,后来网上查找这个问题的时候得知不能怪公司,是因为咱们在这个局域网内…<br>扯多了,回到正题,解决问题,由于我的是Mac电脑,我说的只针对Mac电脑</p>
<h5 id="1-进入终端命令行模式-输入"><a href="#1-进入终端命令行模式-输入" class="headerlink" title="1. 进入终端命令行模式,输入"></a>1. 进入终端命令行模式,输入</h5><p><code>sudo vim /etc/hosts</code></p>
<h5 id="2-输入i进入编辑模式-移动到最后一行准备输入"><a href="#2-输入i进入编辑模式-移动到最后一行准备输入" class="headerlink" title="2. 输入i进入编辑模式,移动到最后一行准备输入"></a>2. 输入i进入编辑模式,移动到最后一行准备输入</h5><h5 id="3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址"><a href="#3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址" class="headerlink" title="3. 用浏览器访问 http://tool.chinaz.com 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址"></a>3. 用浏览器访问 <a href="http://tool.chinaz.com/">http://tool.chinaz.com</a> 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址</h5><h5 id="4-回到第2步中按如下格式输入"><a href="#4-回到第2步中按如下格式输入" class="headerlink" title="4. 回到第2步中按如下格式输入:"></a>4. 回到第2步中按如下格式输入:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<h5 id="5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束"><a href="#5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束" class="headerlink" title="5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束"></a>5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束</h5><h5 id="6-更新DNS缓存-输入"><a href="#6-更新DNS缓存-输入" class="headerlink" title="6. 更新DNS缓存,输入"></a>6. 更新DNS缓存,输入</h5><p><code>sudo dscacheutil -flushcache </code></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>微信抢红包插件</title>
    <url>/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>本篇文章将介绍如何从 0 到 1 一步步实现微信抢红包插件功能，需要用到</p>
<ul>
<li><p>一部能越狱的 iPhone，作者使用的 iOS12.5.7 的 5s。</p>
<p>   推荐使用 iOS15 之前的设备，因为 iOS15 <a href="https://theapplewiki.com/wiki/Signed_System_Volume">SSV</a> 的出现诞生了一种新的越狱方案 <a href="https://theapplewiki.com/wiki/Rootless">rootless</a>。导致很多以前能运行的越狱插件，工具都无法在 iOS15 及后续的系统上正常运行。因为这些工具大多都还没有针对 rootless 进行适配。使用 iOS15 之前的设备能够更完美的进行教学，和拥有更好的体验。当你学有所成的时候，可以尝试对那些暂时没有适配的越狱插件，工具自己进行适配了。这里特别说明一下，rootless 越狱并不是指越狱后没有 root 权限，而是 iOS15 SSV 的出现导致即使是 root 用户也无法往系统目录（如&#x2F;System和&#x2F;usr）写入文件，类似于 macOS 上的 SIP，所以诞生了 rootless 解决方案。</p>
<p>   如果你是 iOS15 及以上的设备，那么越狱也推荐选择 rootful 越狱而不是 rootless，同样还是因为 rootless 很多工具无法使用的原因，比如砸壳工具 frida-ios-dump 在 rootless 越狱设备下大部分 App 都无法砸壳成功。作为普通用户，你可以选择 rootless 越狱，但如果你是想进行逆向学习，还是更推荐使用 rootful 越狱。</p>
</li>
<li><p>一台 Mac 电脑，作者使用的系统是 14.5。</p>
<p>  理论上来说 Linux 或 Windows 也可以，因为 Theos 支持，但是作者没有亲自实践过。</p>
</li>
<li><p>使用终端输入命令行的基本知识。比如 cd 进入目录或删除文件</p>
<p>  其实最好是有 Linux 或者 Unix 系统的基础知识。毕竟 iOS 系统内核 XNU 就是 Unix 类的系统。这一点不算是必要条件吧，可以在过程中学习。</p>
</li>
</ul>
<p>只需要具备以上先决条件即使你不了解 iOS 应用逆向开发也能实现这个功能，感受逆向开发的乐趣。而对于懂编程，对 iOS 应用逆向开发感兴趣的同学则可以通过这个实战项目，迅速的建立对 iOS 应用逆向开发的整体认知。作者将以这一实战项目为根基，实现项目过程中涉及的技术点为枝叶，建立起 iOS 应用逆向开发的知识体系。</p>
<p>从 0 到 1 实现微信抢红包项目的步骤为：</p>
<ol>
<li><a href="#1">越狱 iPhone</a> <ul>
<li><a href="#2">什么是 iPhone 越狱</a></li>
<li><a href="#3">越狱的原理</a></li>
<li><a href="#4">越狱的主要目的</a></li>
<li><a href="#5">越狱后的注意事项</a></li>
<li><a href="#6">iOS 越狱的四种类型</a></li>
<li><a href="#7">包管理器</a></li>
<li><a href="#8">越狱后常用的软件包</a></li>
<li><a href="#9">iOS 如何判断设备是否越狱</a></li>
</ul>
</li>
<li><a href="#10">脱壳微信</a><ul>
<li><a href="#11">下载 frida-ios-dump 项目</a></li>
<li><a href="#12">手机安装 frida</a></li>
<li><a href="#13">安装 frida-ios-dump 的依赖库</a></li>
<li><a href="#14">进行端口转发</a></li>
<li><a href="#15">运行 dump.py 脚本 </a></li>
</ul>
</li>
<li><a href="#16">安装 Theos 创建抢红包 tweak 项目</a></li>
<li><a href="#17">实现抢红包插件的 UI 代码</a></li>
<li><a href="#18">实现抢红包插件的功能代码</a><ul>
<li><a href="#19">1.定位收到微信消息的方法</a></li>
<li><a href="#20">2.定位打开红包的方法</a></li>
<li><a href="#21">3.静态分析开红包的方法</a></li>
<li><a href="#22">最终代码</a></li>
</ul>
</li>
</ol>
<!--
编写 tweak 的过程中用到了。。。
3. 界面分析：分析微信设置界面，实现抢红包功能 UI 界面
    * Cycript
    * Revael
    * Lookin
    * lldb 
5. 静态分析代码：反编译可执行文件，分析微信获取消息流程代码，开红包逻辑
    * MachOView，class-dump，Hopper Disassembler，ida，ghidra 等
6. 动态调试代码
    * lldb+debugserver
7. 编写插件：将我们的代码注入到app中，必要时可能需要重新签名，打包 ipa
-->

<h1 id="越狱-iPhone"><a href="#越狱-iPhone" class="headerlink" title="越狱 iPhone"></a>越狱 iPhone</h1><p>这一步不是本篇文章的重点。因为有很多更好的越狱教程，推荐个<a href="https://ios.cfw.guide/">网站</a>，大家自己去看，选择手机实现越狱。如果对越狱比较熟悉的同学就可以直接跳过这一部分了。</p>
<p>综合考虑下来，目前 8，8plus，x 都是不错的选择，价格合适，性能够用，LCD 屏不怕长时间亮屏幕导致烧屏，且最高支持 iOS16.7.10 越狱，即使出现任何问题导致白苹果，也可以通过刷机恢复之后再次越狱。不会像后面新出的手机如果出现问题，只能更新到最新系统，结果无法越狱的尴尬。</p>
<p>但从学习逆向的角度来说，可能最高搭载 iOS12.5.7 的 iPhone 6&#x2F;6plus 是更合适的选择，一是它是 iOS15 以前的系统许多逆向相关的工具都能正常使用，二是同前面一样即使因为越狱出现了任何问题导致手机无法正常使用，也完全可以通过刷机之后重新越狱，可刷机可越狱的机型就是这么任性。</p>
<p>当然，如果你手中刚好有一台 iOS15 系统之前的 iPhone，也完全可以使用它进行逆向学习，毕竟因为越狱导致 iPhone<br>无法正常使用的情况还是蛮少的，实在不放心就将数据备份已备恢复。</p>
<p>其实越狱 iPhone 并不是逆向开发的必要条件，因为有 <a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a> 的存在可以实现在未越狱的 iOS 设备上开发插件，但在未越狱设备上开发插件时总会存在一些不方便的情况。比如一些知名的 App 都做了 CFBundleIdentifier 的防护，MonkeyDev 重签名 App 之后修改了 CFBundleIdentifier 就会导致获取不到数据的情况出现就会影响开发，虽然也可以做一些绕过措施但依旧存在其他的问题。</p>
<h2 id="什么是-iPhone-越狱"><a href="#什么是-iPhone-越狱" class="headerlink" title="什么是 iPhone 越狱"></a>什么是 iPhone 越狱</h2><p>iPhone 越狱是指通过特定工具或方法绕过苹果公司对 iOS 操作系统的限制，获取更高权限的过程。这使用户能够访问和修改系统文件、安装非苹果 App Store 中的应用程序，以及对系统进行其他未被官方允许的更改。</p>
<h2 id="越狱的原理"><a href="#越狱的原理" class="headerlink" title="越狱的原理"></a>越狱的原理</h2><p>越狱的原理主要在于利用 iOS 系统中的安全漏洞，获取 root 权限，从而绕过 Apple 的限制，允许用户安装未经过认证的应用和进行系统级的修改。一些开源的越狱工具如 <a href="https://github.com/palera1n/palera1n">palera1n</a>，<a href="https://github.com/opa334/Dopamine">Dopamine</a> 就是通过利用公开的 iOS 系统漏洞来实现的。</p>
<p>公开的 iOS 系统漏洞有 CVE-2021-1782，CVE-2022-32917，CVE-2021-30955 等等，CVE（Common Vulnerabilities and Exposures）是一个公共数据库，用于标识和记录已知的安全漏洞和暴露。每个 CVE 条目都有一个唯一的标识符，格式为 CVE-年份-序号。具体含义如下：</p>
<ul>
<li><strong>CVE：</strong>代表“通用漏洞和曝光”。</li>
<li><strong>年份：</strong>指出该漏洞首次被记录或公开的年份。</li>
<li><strong>序号：</strong>在该年份中，为该漏洞分配的唯一数字。</li>
</ul>
<p>至于这些公开的 iOS 系统漏洞是如何发现和记录的，一般通过以下这几种方式：</p>
<ul>
<li><p><strong>安全研究人员：</strong>独立的安全专家和研究机构会对软件和系统进行审计和测试，发现漏洞后会将其报告给开发者，并在确认后提交 CVE 申请。</p>
</li>
<li><p><strong>开发者和厂商：</strong>软件开发者和公司在进行内部安全测试时，可能会发现漏洞，并会向 CVE 数据库提交这些信息。</p>
</li>
<li><p><strong>社区报告：</strong>开源软件社区和用户在使用软件时，可能会发现安全问题并进行报告。这些报告有时会引发更深入的安全审计。</p>
</li>
<li><p><strong>安全会议和黑客大会：</strong>在这些会议上，研究人员通常会展示他们的研究成果，包括新发现的漏洞，之后这些信息可能会被记录为 CVE。</p>
</li>
<li><p><strong>自动化工具：</strong>一些工具会扫描软件和系统以发现已知的漏洞，并将结果报告给开发者或安全机构。</p>
</li>
</ul>
<p>那么安全研究人员又是如何发现漏洞的呢？一般也就是通过逆向工程，对二进制文件进行反汇编之后，分析代码的内部工作原理，找出潜在的漏洞。安全研究人员的要求通常比一般的程序员更高，主要体现在以下几个方面：</p>
<ul>
<li><p><strong>深厚的安全知识：</strong>安全研究人员需要深入了解安全理论、漏洞类型、攻击向量以及防御机制。</p>
</li>
<li><p><strong>逆向工程能力：</strong>能够反汇编和分析二进制文件，理解底层实现，以发现潜在漏洞。</p>
</li>
<li><p><strong>熟悉网络协议：</strong>对网络安全、协议分析和加密技术有深入理解，以识别网络层面的安全问题。</p>
</li>
<li><p><strong>编程能力：</strong>熟悉多种编程语言，能够编写自动化工具或脚本来测试和分析系统。</p>
</li>
<li><p><strong>持续学习：</strong>安全领域不断变化，研究人员需要跟上最新的安全威胁和防护措施，参与安全社区的讨论和研究。</p>
</li>
<li><p><strong>问题解决能力：</strong>能够分析复杂问题，进行创新性思考，以找到漏洞或制定有效的安全策略。</p>
</li>
</ul>
<h2 id="越狱的主要目的"><a href="#越狱的主要目的" class="headerlink" title="越狱的主要目的"></a>越狱的主要目的</h2><ol>
<li><strong>安装非官方应用：</strong> 越狱允许用户安装苹果官方 App Store 外的应用程序和插件。</li>
<li><strong>自定义界面：</strong> 用户可以通过越狱自定义 iOS 设备的界面和功能，如主题、图标等。</li>
<li><strong>增强功能：</strong> 可以使用各种增强功能的插件和工具，如系统优化、功能扩展等。</li>
<li><strong>完全的访问 iOS 文件系统：</strong> 越狱之后的 iOS 设备可以完全访问它的文件系统。</li>
<li><strong>提供逆向开发的环境：</strong> 越狱之后的 iOS 设备可以更方便的进行逆向开发。</li>
</ol>
<h2 id="越狱后的注意事项"><a href="#越狱后的注意事项" class="headerlink" title="越狱后的注意事项"></a>越狱后的注意事项</h2><ol>
<li>安全风险：<ul>
<li><strong>恶意软件和病毒：</strong>越狱解除了一些系统安全限制，非官方来源的应用可能包含恶意代码，增加设备感染恶意软件的风险。所以要谨慎安装不知名的插件。</li>
<li><strong>系统漏洞：</strong>越狱会使设备暴露于更大的安全漏洞中，黑客可以利用这些漏洞攻击设备。</li>
<li><strong>App 沙盒机制可能被绕过：</strong>虽然越狱不会直接破坏沙盒，但有的恶意插件可能试图绕过应用的沙盒保护，获取不应有的数据访问权限。</li>
</ul>
</li>
<li>系统稳定性降低：<ul>
<li><strong>崩溃和异常：</strong>越狱后安装的某些第三方插件和应用可能与系统不兼容，导致应用崩溃或系统不稳定，甚至出现无法启动的问题。</li>
<li><strong>电池续航缩短：</strong>某些越狱插件可能在后台耗电增加，导致设备电池续航能力下降。</li>
</ul>
</li>
<li>设备保修失效：<ul>
<li><strong>失去官方支持：</strong>苹果公司规定，越狱设备不再享有官方保修服务。如果越狱导致设备问题，官方可能拒绝维修。</li>
</ul>
</li>
<li>应用兼容性问题：<ul>
<li><strong>应用检测越狱：</strong>某些应用（如金融类、支付类、游戏类应用）可能会检测越狱状态，并拒绝在越狱设备上运行。</li>
</ul>
</li>
</ol>
<h2 id="iOS-越狱的四种类型"><a href="#iOS-越狱的四种类型" class="headerlink" title="iOS 越狱的四种类型"></a>iOS 越狱的四种类型</h2><p>有以下四种不同类型的越狱，每种类型取决于它与计算机的独立程度。</p>
<ul>
<li><p><strong>Untethered Jailbreaks 不受限制的越狱</strong></p>
<p>  不受限制的越狱可以被认为是所有越狱的圣杯。他们只需要通过网站、应用程序或计算机运行一次漏洞利用程序。之后，您的设备已完全越狱，不需要任何进一步的操作。即使您重新启动设备后，该漏洞仍将保留在设备上。</p>
<p>  不幸的是，已经很长一段时间没有为最终用户提供新的不受限制的越狱了，而且我们很可能以后都不会看到这样的越狱了。不受限制的越狱的唯一缺点是，如果出现问题，很可能会导致引导循环，要求您通过 iTunes 或 Finder（macOS Catalina 或更高版本）恢复设备。这种情况发生的可能性很低，但确实有可能。</p>
</li>
<li><p><strong>Semi-Untethered Jailbreaks 半不受限制的越狱</strong></p>
<p>  半自由越狱是近这些年来最流行的越狱类型。这种类型的越狱需要在每次重新启动或关闭 iOS 设备时执行漏洞利用。大部分是通过 iOS 设备上的应用程序或者网站运行漏洞。</p>
</li>
<li><p><strong>Semi-Tethered Jailbreaks 半受限制的越狱</strong></p>
<p>  半受限制的越狱与半不受限制的越狱非常相似，但是该漏洞必须使用计算机运行，而不是使用侧载应用程序。由于在每次重新启动 iOS 设备后需要计算机才能重新越狱，因此大多数人选择使用半不受限制的越狱。</p>
</li>
<li><p><strong>Tethered Jailbreaks 受限制的越狱</strong></p>
<p>  受限制的越狱并不适合公众使用。这些漏洞会修改设备，甚至即使没有越狱也需要 PC 才能启动。因此，这些往往只被为新版 iOS 做好准备的越狱开发人员使用。</p>
</li>
</ul>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>在 iOS 设备未越狱时，我们只能通过 App Store 或爱思，沙漏这样的第三方平台下载安装应用程序。而越狱之后，我们不仅同样可以使用上面的方式下载安装应用程序，还可以通过像 Cydia，Sileo，等一些包管理器来安装 tweak，应用程序，命令行程序等其他软件。默认情况下，不同的越狱程序与不同的包管理器捆绑在一起，但目前最受欢迎的是 Sileo。</p>
<h3 id="Sileo"><a href="#Sileo" class="headerlink" title="Sileo"></a>Sileo</h3><p>Sileo 是 <a href="https://x.com/elihwyma">Amy</a> 为 iOS 11 及更高版本维护的包管理器。 Sileo 以其基于 Swift 的设计、快速性能和总体质量改进（例如适当的 iPad 支持）而自豪。</p>
<p>Sileo 默认安装在 Electra、Chimera、Odyssey、Taurine 和 Odysseyra1n 上。 Sileo 还可以在 iOS 12.0 及更高版本上通过 checkra1n 以及 unc0ver 下载。</p>
<h3 id="Cydia"><a href="#Cydia" class="headerlink" title="Cydia"></a>Cydia</h3><p>Cydia 是一个包管理器，长期以来被认为是越狱的代表，以前是大多数越狱的首选包管理器。Cydia 的原始创建者 Saurik 已停止维护该项目，但近年来 Sam Bingner 更新了适用于现代设备和 iOS 版本的软件。</p>
<p>关于包管理器的使用，这里不做更深入的介绍了，网上有很多介绍。</p>
<blockquote>
<p>在使用包管理器安装某些应用程序之后，包管理器有时会提示我们重启 SpringBoard 。</p>
<p>SpringBoard 是 iOS 的主屏幕应用程序，管理图标、壁纸、通知等元素，就是我们接触最多的 iOS 桌面。Apple 官方有专门的岗位 iOS SpringBoard Engineer 用于开发和维护 SpringBoard 。</p>
</blockquote>
<h2 id="越狱后常用的软件包"><a href="#越狱后常用的软件包" class="headerlink" title="越狱后常用的软件包"></a>越狱后常用的软件包</h2><ul>
<li><p><strong>Apple File Conduit “2”：</strong> </p>
<p>  简称 AFC2，是一款在越狱后的 iOS 设备上使用的工具，它扩展了默认的 Apple File Conduit 服务，使得用户可以通过 USB 连接访问 iOS 文件系统中的完整内容。通常情况下，非越狱设备的文件系统只能通过 AFC 协议访问有限的部分，而 AFC2 则允许用户访问系统的根目录及其他受限制的区域。Mac 使用如 iFunBox、iExplorer、3uTools 等工具配合 AFC2 实现对越狱设备文件系统的完整访问。</p>
</li>
<li><p><strong>AppSync Unified：</strong> </p>
<p>  它允许用户在设备上安装、管理和运行非官方签名的应用程序。这类应用通常包括未通过苹果审核的应用、已修改的应用、以及自行编译或未经 App Store 发布的应用。AppSync Unified 通过补丁系统文件，绕过了 iOS 的应用签名限制。</p>
</li>
<li><p><strong>Filza File Manager：</strong> </p>
<p>  是一款功能强大的文件管理器，专为越狱后的 iOS 设备设计。它允许用户在设备上直接浏览、管理和编辑文件系统的内容。Filza 提供了与桌面操作系统文件管理器类似的体验，让用户可以轻松访问和操作 iOS 设备上的所有文件，包括系统文件和应用数据。</p>
</li>
<li><p><strong><a href="../openssh/openssh.md">OpenSSH</a></strong> </p>
<p>  是一个开源的 SSH 实现，它提供服务器的功能，用于安全远程登录、命令执行和文件传输。iOS 安装之后可以我们可以使用 Mac 远程登录到设备上。</p>
</li>
</ul>
<blockquote>
<p>如果遇到包管理器下载安装某些软件包失败的情况，可以手动安装软件包。</p>
</blockquote>
<p>如果你已经下载了 .deb 文件（iOS 软件包的格式），可以通过以下步骤在 Sileo 中进行本地安装：</p>
<ol>
<li><strong>将 .deb 文件传输到设备上：</strong>你可以使用文件管理工具或其他方法将 .deb 文件传输到你的 iOS 设备上，比如使用文件传输工具或通过越狱后的文件系统。</li>
<li><strong>使用文件管理工具访问文件：</strong>在设备上打开你用来管理文件的工具（例如 Filza File Manager）。</li>
<li><strong>找到 .deb 文件：</strong>浏览到存储 .deb 文件的目录。</li>
<li><strong>使用 Sileo 安装：</strong>在文件管理工具中找到 .deb 文件，点击它，通常会弹出一个选项，允许你选择使用 Sileo 或其他包管理工具进行安装。</li>
<li><strong>确认安装：</strong>选择 Sileo 进行安装，Sileo 将会处理包的安装过程。</li>
</ol>
<h2 id="iOS-如何判断设备是否越狱"><a href="#iOS-如何判断设备是否越狱" class="headerlink" title="iOS 如何判断设备是否越狱"></a>iOS 如何判断设备是否越狱</h2><p>iOS 可以通过多种方法来检测设备是否越狱，主要是利用越狱后系统的某些变化和越狱工具的行为。以下是常见的越狱检测方法：</p>
<h3 id="检查系统文件的存在"><a href="#检查系统文件的存在" class="headerlink" title="检查系统文件的存在"></a>检查系统文件的存在</h3><p>越狱后，一些特定的文件和目录可能会存在，正常情况下这些文件不应该存在。例如：</p>
<ul>
<li><strong>Cydia 应用的路径：</strong>&#x2F;Applications&#x2F;Cydia.app，如果这个路径存在，说明设备很可能已经越狱。</li>
<li><strong>其他越狱工具的路径：</strong>比如 Sileo.app 或者 Zebra.app。</li>
</ul>
<p>常用代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/Applications/Cydia.app&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/Library/MobileSubstrate/MobileSubstrate.dylib&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/usr/sbin/sshd&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/etc/apt&quot;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 设备已经越狱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种方式存在一个问题，即曾经越狱过的设备可能在系统中留下了这些文件，但后续升级了 iOS 之后失去了越狱状态就会导致明明是未越狱设备却被判定为越狱设备。</p>
<h3 id="检查是否能够访问系统的根目录"><a href="#检查是否能够访问系统的根目录" class="headerlink" title="检查是否能够访问系统的根目录"></a>检查是否能够访问系统的根目录</h3><p>越狱后，某些应用会获得更高权限，可以访问系统的根目录。因此，通过尝试在 &#x2F;private 目录下写入文件，可以判断设备是否越狱：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSString</span> *testWrite = <span class="string">@&quot;/private/jailbreak_test.txt&quot;</span>;</span><br><span class="line">[<span class="string">@&quot;Jailbreak Test&quot;</span> writeToFile:testWrite atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:testWrite error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查是否可以调用-fork-函数"><a href="#检查是否可以调用-fork-函数" class="headerlink" title="检查是否可以调用 fork() 函数"></a>检查是否可以调用 fork() 函数</h3><p>iOS 设备在非越狱环境下不允许创建子进程，而越狱设备可以使用 fork() 函数来创建子进程。通过检查是否可以成功调用 fork()，可以判断设备是否越狱：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检测越狱工具的存在"><a href="#检测越狱工具的存在" class="headerlink" title="检测越狱工具的存在"></a>检测越狱工具的存在</h3><p>有些应用会检查常见的越狱工具，如 Cydia 或 Sileo 是否能够被打开：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;cydia://&quot;</span>]]) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查动态库注入"><a href="#检查动态库注入" class="headerlink" title="检查动态库注入"></a>检查动态库注入</h3><p>越狱通常会引入一些动态库来修改系统行为。可以通过查看运行时的动态库是否有常见的越狱库，例如 MobileSubstrate:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dyld_count = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dyld_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(_dyld_get_image_name(i), <span class="string">&quot;MobileSubstrate&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 设备已越狱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="脱壳微信"><a href="#脱壳微信" class="headerlink" title="脱壳微信"></a>脱壳微信</h1><p>对一个应用程序进行逆向分析之前，首先需要对其进行脱壳操作。至于什么是壳，请看 <a href="../binary_dumping/binary_dumping.md">iOS 应用脱壳</a></p>
<p>在 iOS12.5.7 上脱壳微信的方法有很多，这里只介绍 frida-ios-dump，要想成功脱壳还需要不少的配置和步骤。简单点来说就是使用 frida-ios-dump 需要用到 frida 等第三方库，而安装 frida 又需要用到其他的库，所以导致可能不会一次性就能成功运行脱壳。加上每个人的电脑环境不同，可能出现的问题千奇百怪，这里就记录作者本人使用过程中遇到的问题和解决的办法。</p>
<h3 id="1-手机安装-frida"><a href="#1-手机安装-frida" class="headerlink" title="1.手机安装 frida"></a>1.手机安装 frida</h3><p>在 cydia&#x2F;sileo 上添加源 <a href="https://build.frida.re/">https://build.frida.re</a>，点击 frida 安装就好了。可以参考<a href="https://frida.re/docs/ios/#with-jailbreak">官方文档</a> </p>
<h3 id="2-Mac下载-frida-ios-dump-项目"><a href="#2-Mac下载-frida-ios-dump-项目" class="headerlink" title="2.Mac下载 frida-ios-dump 项目"></a>2.Mac下载 <a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a> 项目</h3><p>这一步是最简单的，大家都是程序员的话应该不用多说了吧。在终端输入以下命令下载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump.git</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-frida-ios-dump-的依赖库"><a href="#3-安装-frida-ios-dump-的依赖库" class="headerlink" title="3.安装 frida-ios-dump 的依赖库"></a>3.安装 frida-ios-dump 的依赖库</h3><p>按照 frida-ios-dump 的文档执行 <code>sudo pip install -r requirements.txt --upgrade</code> 的时候，出现了以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">sudo</span> pip install -r requirements.txt --upgrade</span><br><span class="line">Password:</span><br><span class="line"><span class="built_in">sudo</span>: pip: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>这个问题好解决，由于作者是用 brew 安装的 python3，可以使用它附带的 pip3。所以修改为 pip3 就好了。输入 <code>sudo pip3 install -r requirements.txt --upgrade</code>，还是出错了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">sudo</span> pip3 install -r requirements.txt --upgrade</span><br><span class="line">WARNING: The directory <span class="string">&#x27;/Users/franky/Library/Caches/pip&#x27;</span> or its parent directory is not owned or is not writable by the current user. The cache has been disabled. Check the permissions and owner of that directory. If executing pip with <span class="built_in">sudo</span>, you should use <span class="built_in">sudo</span><span class="string">&#x27;s -H flag.</span></span><br><span class="line"><span class="string">error: externally-managed-environment</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">× This environment is externally managed</span></span><br><span class="line"><span class="string">╰─&gt; To install Python packages system-wide, try brew install</span></span><br><span class="line"><span class="string">    xyz, where xyz is the package you are trying to</span></span><br><span class="line"><span class="string">    install.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If you wish to install a Python library that isn&#x27;</span>t <span class="keyword">in</span> Homebrew,</span><br><span class="line">    use a virtual environment:</span><br><span class="line"></span><br><span class="line">    python3 -m venv path/to/venv</span><br><span class="line">    <span class="built_in">source</span> path/to/venv/bin/activate</span><br><span class="line">    python3 -m pip install xyz</span><br><span class="line"></span><br><span class="line">    If you wish to install a Python application that isn<span class="string">&#x27;t in Homebrew,</span></span><br><span class="line"><span class="string">    it may be easiest to use &#x27;</span>pipx install xyz<span class="string">&#x27;, which will manage a</span></span><br><span class="line"><span class="string">    virtual environment for you. You can install pipx with</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    brew install pipx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You may restore the old behavior of pip by passing</span></span><br><span class="line"><span class="string">    the &#x27;</span>--break-system-packages<span class="string">&#x27; flag to pip, or by adding</span></span><br><span class="line"><span class="string">    &#x27;</span>break-system-packages = <span class="literal">true</span><span class="string">&#x27; to your pip.conf file. The latter</span></span><br><span class="line"><span class="string">    will permanently disable this error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If you disable this error, we STRONGLY recommend that you additionally</span></span><br><span class="line"><span class="string">    pass the &#x27;</span>--user<span class="string">&#x27; flag to pip, or set &#x27;</span>user = <span class="literal">true</span><span class="string">&#x27; in your pip.conf</span></span><br><span class="line"><span class="string">    file. Failure to do this can result in a broken Homebrew installation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Read more about this behavior here: &lt;https://peps.python.org/pep-0668/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.</span></span><br><span class="line"><span class="string">hint: See PEP 668 for the detailed specification.</span></span><br></pre></td></tr></table></figure>

<p>好在给出的提示足够多，解决方法也有。于是按照提示使用 python 虚拟环境。这个虚拟环境一开始给我的感觉很懵逼。但实际的做法就是在项目的目录下新建一个文件夹用于存放 python 相关的资源，这样不影响系统的 python 环境。按照提示输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master] python3 -m venv path/to/venv</span><br><span class="line"> ~/frida-ios-dump/ [master] <span class="built_in">source</span> path/to/venv/bin/activate</span><br><span class="line">(venv)  ~/frida-ios-dump/ [master] pip3 install -r requirements.txt --upgrade</span><br><span class="line">Collecting asn1crypto (from -r requirements.txt (line 1))</span><br><span class="line">  Using cached asn1crypto-1.5.1-py2.py3-none-any.whl.metadata (13 kB)</span><br><span class="line">Collecting bcrypt (from -r requirements.txt (line 2))</span><br><span class="line">  Using cached bcrypt-4.2.0-cp39-abi3-macosx_10_12_universal2.whl.metadata (9.6 kB)</span><br><span class="line">Collecting cffi (from -r requirements.txt (line 3))</span><br><span class="line">  Using cached cffi-1.17.1-cp312-cp312-macosx_10_9_x86_64.whl.metadata (1.5 kB)</span><br><span class="line">Collecting colorama (from -r requirements.txt (line 4))</span><br><span class="line">  Using cached colorama-0.4.6-py2.py3-none-any.whl.metadata (17 kB)</span><br><span class="line">Collecting cryptography (from -r requirements.txt (line 5))</span><br><span class="line">  Using cached cryptography-43.0.1-cp39-abi3-macosx_10_9_universal2.whl.metadata (5.4 kB)</span><br><span class="line">Collecting enum34 (from -r requirements.txt (line 6))</span><br><span class="line">  Using cached enum34-1.1.10-py3-none-any.whl.metadata (1.6 kB)</span><br><span class="line">Collecting frida-tools (from -r requirements.txt (line 7))</span><br><span class="line">  Using cached frida_tools-13.3.0-py3-none-any.whl</span><br><span class="line">Collecting idna (from -r requirements.txt (line 8))</span><br><span class="line">  Using cached idna-3.10-py3-none-any.whl.metadata (10 kB)</span><br><span class="line">Collecting ipaddress (from -r requirements.txt (line 9))</span><br><span class="line">  Using cached ipaddress-1.0.23-py2.py3-none-any.whl.metadata (923 bytes)</span><br><span class="line">Collecting paramiko (from -r requirements.txt (line 10))</span><br><span class="line">  Using cached paramiko-3.5.0-py3-none-any.whl.metadata (4.4 kB)</span><br><span class="line">Collecting prompt-toolkit (from -r requirements.txt (line 11))</span><br><span class="line">  Using cached prompt_toolkit-3.0.48-py3-none-any.whl.metadata (6.4 kB)</span><br><span class="line">Collecting pyasn1 (from -r requirements.txt (line 12))</span><br><span class="line">  Using cached pyasn1-0.6.1-py3-none-any.whl.metadata (8.4 kB)</span><br><span class="line">Collecting pycparser (from -r requirements.txt (line 13))</span><br><span class="line">  Using cached pycparser-2.22-py3-none-any.whl.metadata (943 bytes)</span><br><span class="line">Collecting Pygments (from -r requirements.txt (line 14))</span><br><span class="line">  Using cached pygments-2.18.0-py3-none-any.whl.metadata (2.5 kB)</span><br><span class="line">Collecting PyNaCl (from -r requirements.txt (line 15))</span><br><span class="line">  Using cached PyNaCl-1.5.0-cp36-abi3-macosx_10_10_universal2.whl.metadata (8.7 kB)</span><br><span class="line">Collecting scp (from -r requirements.txt (line 16))</span><br><span class="line">  Using cached scp-0.15.0-py2.py3-none-any.whl.metadata (4.3 kB)</span><br><span class="line">Collecting six (from -r requirements.txt (line 17))</span><br><span class="line">  Using cached six-1.16.0-py2.py3-none-any.whl.metadata (1.8 kB)</span><br><span class="line">Collecting tqdm (from -r requirements.txt (line 18))</span><br><span class="line">  Using cached tqdm-4.66.5-py3-none-any.whl.metadata (57 kB)</span><br><span class="line">Collecting wcwidth (from -r requirements.txt (line 19))</span><br><span class="line">  Using cached wcwidth-0.2.13-py2.py3-none-any.whl.metadata (14 kB)</span><br><span class="line">Collecting frida&lt;17.0.0,&gt;=16.2.2 (from frida-tools-&gt;-r requirements.txt (line 7))</span><br><span class="line">  Using cached frida-16.5.5-cp37-abi3-macosx_10_13_x86_64.whl.metadata (2.0 kB)</span><br><span class="line">Collecting websockets&lt;14.0.0,&gt;=13.0.0 (from frida-tools-&gt;-r requirements.txt (line 7))</span><br><span class="line">  Using cached websockets-13.1-cp312-cp312-macosx_10_9_x86_64.whl.metadata (6.8 kB)</span><br><span class="line">Using cached asn1crypto-1.5.1-py2.py3-none-any.whl (105 kB)</span><br><span class="line">Using cached bcrypt-4.2.0-cp39-abi3-macosx_10_12_universal2.whl (472 kB)</span><br><span class="line">Using cached cffi-1.17.1-cp312-cp312-macosx_10_9_x86_64.whl (183 kB)</span><br><span class="line">Using cached colorama-0.4.6-py2.py3-none-any.whl (25 kB)</span><br><span class="line">Using cached cryptography-43.0.1-cp39-abi3-macosx_10_9_universal2.whl (6.2 MB)</span><br><span class="line">Using cached enum34-1.1.10-py3-none-any.whl (11 kB)</span><br><span class="line">Using cached idna-3.10-py3-none-any.whl (70 kB)</span><br><span class="line">Using cached ipaddress-1.0.23-py2.py3-none-any.whl (18 kB)</span><br><span class="line">Using cached paramiko-3.5.0-py3-none-any.whl (227 kB)</span><br><span class="line">Using cached prompt_toolkit-3.0.48-py3-none-any.whl (386 kB)</span><br><span class="line">Using cached pyasn1-0.6.1-py3-none-any.whl (83 kB)</span><br><span class="line">Using cached pycparser-2.22-py3-none-any.whl (117 kB)</span><br><span class="line">Using cached pygments-2.18.0-py3-none-any.whl (1.2 MB)</span><br><span class="line">Using cached PyNaCl-1.5.0-cp36-abi3-macosx_10_10_universal2.whl (349 kB)</span><br><span class="line">Using cached scp-0.15.0-py2.py3-none-any.whl (8.8 kB)</span><br><span class="line">Using cached six-1.16.0-py2.py3-none-any.whl (11 kB)</span><br><span class="line">Using cached tqdm-4.66.5-py3-none-any.whl (78 kB)</span><br><span class="line">Using cached wcwidth-0.2.13-py2.py3-none-any.whl (34 kB)</span><br><span class="line">Using cached frida-16.5.5-cp37-abi3-macosx_10_13_x86_64.whl (16.7 MB)</span><br><span class="line">Using cached websockets-13.1-cp312-cp312-macosx_10_9_x86_64.whl (155 kB)</span><br><span class="line">Installing collected packages: wcwidth, ipaddress, enum34, asn1crypto, websockets, tqdm, six, Pygments, pycparser, pyasn1, prompt-toolkit, idna, frida, colorama, bcrypt, frida-tools, cffi, PyNaCl, cryptography, paramiko, scp</span><br><span class="line">Successfully installed PyNaCl-1.5.0 Pygments-2.18.0 asn1crypto-1.5.1 bcrypt-4.2.0 cffi-1.17.1 colorama-0.4.6 cryptography-43.0.1 enum34-1.1.10 frida-16.5.5 frida-tools-13.3.0 idna-3.10 ipaddress-1.0.23 paramiko-3.5.0 prompt-toolkit-3.0.48 pyasn1-0.6.1 pycparser-2.22 scp-0.15.0 six-1.16.0 tqdm-4.66.5 wcwidth-0.2.13 websockets-13.1</span><br></pre></td></tr></table></figure>

<p>可以看到成功安装了 frida。可以使用 <code>pip3 list</code> 查看 frida 的版本号。确保 frida 的版本号和手机上的 frida 是同个版本。</p>
<h3 id="4-进行端口转发"><a href="#4-进行端口转发" class="headerlink" title="4.进行端口转发"></a>4.进行端口转发</h3><p>使用 frida-ios-dump 的前提是你的越狱设备安装并配置好了 <a href="../openssh/openssh.md">OpenSSH</a> 免密码登录。这可以看我之前写过的文章。</p>
<p>使用 iproxy 进行端口转发，<code>iproxy 2222:22</code> 通过 USB 将电脑上的 2222 端口和手机的 22 端口建立映射。这一步基本没什么问题。<code>iproxy</code> 是 <code>libimobiledevice</code> 工具集的一部分，所以通过 <code>brew</code> 安装 <code>libimobiledevice</code> 获得 <code>iproxy</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install libimobiledevice</span><br></pre></td></tr></table></figure>

<p>然后在终端新开一个窗口运行 <code>iproxy 2222:22</code>，之后这个终端窗口就不接受用户输入，无法交互了，但不要关闭它，因为它一直在工作中。。。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ iproxy 2222:22</span><br><span class="line">Creating listening port 2222 <span class="keyword">for</span> device port 22</span><br><span class="line">waiting <span class="keyword">for</span> connection</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="5-运行-dump-py-脚本"><a href="#5-运行-dump-py-脚本" class="headerlink" title="5.运行 dump.py 脚本"></a>5.运行 dump.py 脚本</h3><p>在运行 dump.py 脚本之前，我们可能还需要对它进行一些修改。打开 dump.py 文件，找到下面配置，在文件的 40-43 行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">User = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">Password = <span class="string">&#x27;alpine&#x27;</span></span><br><span class="line">Host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">Port = <span class="number">2222</span></span><br><span class="line">KeyFileName = <span class="literal">None</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里的密码，是你在越狱 iPhone 之后设置的密码，如果是老旧的 iOS12 越狱可能是默认的密码 alpine。如果是新一点的版本如 iOS16，则是你越狱后安装 Sileo 时设置的密码，或者后续手动设置的密码。Host 设置为 localhost，是因为我们进行了 USB 端口转发，通过 USB 连接手机，就可以实现访问电脑的 2222 端口相当于访问了手机的 22 端口。</p>
<p>修改好以上配置之后使用命令 <code>python3 dump.py -l</code> 可以列举越狱设备上可砸壳的应用程序。然后输入以下命令 <code>python3 dump.py 微信</code> 运行，就可以看到终端脱壳的过程了。如果终端没有反应，可以手动打开 微信 app。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv)  ~/frida-ios-dump/ [master*] python3 dump.py 微信</span><br><span class="line">Start the target app 微信</span><br><span class="line">attach pid : 18956</span><br><span class="line">Dumping 微信 to /var/folders/rt/zkm8hst55kv45x396jh95v3h0000gn/T</span><br><span class="line">[frida-ios-dump]: Load ilink_network.framework success.</span><br><span class="line">[frida-ios-dump]: Load TPFFmpeg.framework success.</span><br><span class="line">[frida-ios-dump]: Load NewMessageRingUtil.framework success.</span><br><span class="line">[frida-ios-dump]: Load SoundTouch.framework success.</span><br><span class="line">[frida-ios-dump]: Load openssl.framework success.</span><br><span class="line">[frida-ios-dump]: Load MMRouter.framework success.</span><br><span class="line">[frida-ios-dump]: Load owl.framework success.</span><br><span class="line">[frida-ios-dump]: Load TPThirdParties.framework success.</span><br><span class="line">[frida-ios-dump]: Load andromeda.framework success.</span><br><span class="line">[frida-ios-dump]: Load matrixreport.framework success.</span><br><span class="line">[frida-ios-dump]: Load Lottie.framework success.</span><br><span class="line">[frida-ios-dump]: Load ProtobufLite.framework success.</span><br><span class="line">[frida-ios-dump]: Load App.framework success.</span><br><span class="line">[frida-ios-dump]: Load JavaScriptCore2.framework success.</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/WeChat</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/WeChat.322542873.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/WeChat&#x27;</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/frida/core.py&quot;</span>, line 562, <span class="keyword">in</span> _on_message</span><br><span class="line">    callback(message, data)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/dump.py&quot;</span>, line 571, <span class="keyword">in</span> on_message</span><br><span class="line">    scp.get(scp_from, scp_to)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 286, <span class="keyword">in</span> get</span><br><span class="line">    self._recv_all()</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 440, <span class="keyword">in</span> _recv_all</span><br><span class="line">    raise SCPException(asunicode(msg[1:]))</span><br><span class="line">scp.SCPException: scp: /var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/WeChat.322542873.fid: No such file or directory</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPThirdParties.framework/TPThirdParties</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPThirdParties.-1804490760.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPThirdParties.framework/TPThirdParties&#x27;</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/frida/core.py&quot;</span>, line 562, <span class="keyword">in</span> _on_message</span><br><span class="line">    callback(message, data)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/dump.py&quot;</span>, line 571, <span class="keyword">in</span> on_message</span><br><span class="line">    scp.get(scp_from, scp_to)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 286, <span class="keyword">in</span> get</span><br><span class="line">    self._recv_all()</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 440, <span class="keyword">in</span> _recv_all</span><br><span class="line">    raise SCPException(asunicode(msg[1:]))</span><br><span class="line">scp.SCPException: scp: /var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPThirdParties.-1804490760.fid: No such file or directory</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPFFmpeg.framework/TPFFmpeg</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPFFmpeg.-1887525640.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPFFmpeg.framework/TPFFmpeg&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 12.3M/12.3M [00:00&lt;00:00, 34.7MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/owl.framework/owl</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/owl.348061506.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/owl.framework/owl&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 1.36M/1.36M [00:00&lt;00:00, 15.2MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ilink_network.framework/ilink_network</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/ilink_network.928538910.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ilink_network.framework/ilink_network&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 7.14M/7.14M [00:00&lt;00:00, 21.6MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/SoundTouch.framework/SoundTouch</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/SoundTouch.1717022808.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/SoundTouch.framework/SoundTouch&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 113k/113k [00:00&lt;00:00, 2.13MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/JavaScriptCore2.framework/JavaScriptCore2</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/JavaScriptCore2.514565318.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/JavaScriptCore2.framework/JavaScriptCore2&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 12.6M/12.6M [00:00&lt;00:00, 34.6MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ProtobufLite.framework/ProtobufLite</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/ProtobufLite.410267128.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ProtobufLite.framework/ProtobufLite&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 544k/544k [00:00&lt;00:00, 7.19MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/MMRouter.framework/MMRouter</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/MMRouter.-2017767432.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/MMRouter.framework/MMRouter&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 96.5k/96.5k [00:00&lt;00:00, 1.82MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/Lottie.framework/Lottie</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/Lottie.1475886264.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/Lottie.framework/Lottie&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 488k/488k [00:00&lt;00:00, 9.93MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/andromeda.framework/andromeda</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/andromeda.419211084.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/andromeda.framework/andromeda&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 8.50M/8.50M [00:00&lt;00:00, 34.4MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/openssl.framework/openssl</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/openssl.680017982.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/openssl.framework/openssl&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2.59M/2.59M [00:00&lt;00:00, 17.5MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/matrixreport.framework/matrixreport</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/matrixreport.-1076983176.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/matrixreport.framework/matrixreport&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 469k/469k [00:00&lt;00:00, 8.20MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/NewMessageRingUtil.framework/NewMessageRingUtil</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/NewMessageRingUtil.709267448.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/NewMessageRingUtil.framework/NewMessageRingUtil&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 87.6k/87.6k [00:00&lt;00:00, 2.23MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/App.framework/App</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/App.-760674948.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/App.framework/App&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 50.6M/50.6M [00:01&lt;00:00, 38.5MB/s]</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;app&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app&#x27;</span>&#125;</span><br><span class="line">/var/folders/rt/zkm8hst55kv45x396jh95v3h0000gn/T/Payload/</span><br><span class="line">666MB [00:25, 27.1MB/s]</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;done&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>&#125;</span><br><span class="line">DONE!</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">Generating <span class="string">&quot;微信.ipa&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入 la 查看当前目录下，多了一个 微信.ipa 文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv)  ~/frida-ios-dump/ [master*] la</span><br><span class="line">total 590168</span><br><span class="line">drwxr-xr-x@ 13 franky  staff   416B  9 26 18:46 .git</span><br><span class="line">-rw-r--r--@  1 franky  staff   1.0K  5 31 20:48 LICENSE</span><br><span class="line">-rw-r--r--@  1 franky  staff   804B  5 31 20:48 README.md</span><br><span class="line">-rwxr-xr-x@  1 franky  staff    25K  9 26 11:19 dump.py</span><br><span class="line">drwxr-xr-x@  3 franky  staff    96B  9 26 18:49 path</span><br><span class="line">-rw-r--r--@  1 franky  staff   2.0K  5 31 20:48 process.sh</span><br><span class="line">-rw-r--r--@  1 franky  staff    36B  9 26 18:53 requirements.txt</span><br><span class="line">-rw-r--r--@  1 franky  staff   276M  9 26 19:35 微信.ipa</span><br></pre></td></tr></table></figure>

<p>解压缩 ipa 之后，使用 <code>otool -l Payload/WeChat.app/WeChat | grep crypt</code> 查看 WeChat 是否脱壳成功，记得一定要检查，有时候会看起一切正常然而并没有脱壳成功。如何判断是否脱壳成功呢？检查 cryptid 后面的值，是 0 就代表脱壳成功了，非 0 表示脱壳失败，该二进制文件依旧有壳。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] otool -l Payload/WeChat.app/WeChat | grep crypt</span><br><span class="line">     cryptoff 138072064</span><br><span class="line">    cryptsize 4096</span><br><span class="line">      cryptid 0</span><br></pre></td></tr></table></figure>

<p>至此，你就得到了一个脱壳成功的 ipa 了。有了它之后才可以进行后面的分析。</p>
<h1 id="安装-Theos-创建抢红包-tweak-项目"><a href="#安装-Theos-创建抢红包-tweak-项目" class="headerlink" title="安装 Theos 创建抢红包 tweak 项目"></a>安装 Theos 创建抢红包 tweak 项目</h1><p>在 iOS 越狱环境中，”tweak” 通常指的是对系统或应用进行修改的小程序或插件。这些修改可以改变应用的外观、功能或行为。Tweaks 通常通过 Cydia、Sileo 等包管理器安装，允许用户自定义他们的设备。例如，有些 tweak 可以添加新的功能到现有的应用，或者移除一些系统限制。</p>
<p>编写 tweak 需要用到 Theos，Theos 最初是一个名为 “iphone-framework” 的项目，旨在简化命令行下的代码构建，主要用于越狱的 iOS 设备。后来，它经历了重大改进，成为 Theos —— 一个基于 Make 的灵活构建系统，专注于越狱软件开发，同时也支持为其他多个平台构建项目。安装 Theos 需要安装 Xcode 和 Homebrew。具体的安装方法可以查看 <a href="https://theos.dev/docs/installation-macos">官方文档</a></p>
<p>Theos 安装好之后，打开终端输入以下命令 <code>nic.pl</code> 创建 tweak 项目，然后按照提示输入相关信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ nic.pl</span><br><span class="line">NIC 2.0 - New Instance Creator</span><br><span class="line">------------------------------</span><br><span class="line">  [1.] iphone/activator_event</span><br><span class="line">  [2.] iphone/activator_listener</span><br><span class="line">  [3.] iphone/application</span><br><span class="line">  [4.] iphone/application_swift</span><br><span class="line">  [5.] iphone/application_swiftui</span><br><span class="line">  [6.] iphone/control_center_module-11up</span><br><span class="line">  [7.] iphone/cydget</span><br><span class="line">  [8.] iphone/flipswitch_switch</span><br><span class="line">  [9.] iphone/framework</span><br><span class="line">  [10.] iphone/library</span><br><span class="line">  [11.] iphone/notification_center_widget</span><br><span class="line">  [12.] iphone/notification_center_widget-7up</span><br><span class="line">  [13.] iphone/null</span><br><span class="line">  [14.] iphone/preference_bundle</span><br><span class="line">  [15.] iphone/preference_bundle_swift</span><br><span class="line">  [16.] iphone/theme</span><br><span class="line">  [17.] iphone/tool</span><br><span class="line">  [18.] iphone/tool_swift</span><br><span class="line">  [19.] iphone/tweak</span><br><span class="line">  [20.] iphone/tweak_swift</span><br><span class="line">  [21.] iphone/tweak_with_simple_preferences</span><br><span class="line">  [22.] iphone/xpc_service</span><br><span class="line">  [23.] iphone/xpc_service_modern</span><br><span class="line">Choose a Template (required): 19</span><br><span class="line">Project Name (required): redEnveloper</span><br><span class="line">Package Name [com.yourcompany.redenveloper]:</span><br><span class="line">Author/Maintainer Name [franky]:</span><br><span class="line">[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.tencent.xin</span><br><span class="line">[iphone/tweak] List of applications to terminate upon installation (space-separated, <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span> none) [SpringBoard]: WeChat</span><br><span class="line">Instantiating iphone/tweak <span class="keyword">in</span> redEnveloper/...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>这里我们填写了工程名为 redEnveloper</p>
<p>然后在 <code>[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]:</code> 这一栏输入的 <code>com.tencent.xin</code> 是微信的唯一标识，也就是 CFBundleIdentifier，至于如何知道微信的 CFBundleIdentifier 是这个的，其实有很多方法。。。</p>
<p>然后在 <code>[iphone/tweak] List of applications to terminate upon installation (space-separated, &#39;-&#39; for none) [SpringBoard]: </code> 这一栏输入 <code>WeChat</code> 这是微信的进程名。</p>
<p>其他项都可以直接回车使用默认值就行了。我们先认识一下 tweak 项目都有哪些文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/redEnveloper/ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── Tweak.xm</span><br><span class="line">├── control</span><br><span class="line">└── redEnveloper.plist</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>tree</code> 命令默认是没有的，可以使用 <code>brew install tree</code> 安装。</p>
</blockquote>
<p>在 iOS Tweak 项目中，这些文件和文件夹的作用如下：</p>
<ol>
<li><p><strong>Makefile</strong>：用于编译和构建你的 tweak。它定义了如何将源代码（如 Tweak.x）编译成动态库，包括所需的编译器选项和依赖关系。</p>
</li>
<li><p><strong>Tweak.x</strong>：这是你的插件主要源代码文件，通常包含了你想要实现的功能的代码。你可以在这里编写用于修改系统行为或应用程序功能的代码。</p>
</li>
<li><p><strong>control</strong>：这个文件包含关于你的 tweak 的元数据，例如名称、版本、作者、依赖关系等。它通常用于生成一个可安装的包。</p>
</li>
<li><p><strong>packages</strong>：这个文件夹通常用于存放编译后的 deb 包，方便发布和安装。</p>
</li>
<li><p><strong>redEnveloper.plist</strong>：这是一个属性列表文件，这个部分用于定义哪些应用程序的行为会受到你的 tweak 影响。</p>
</li>
</ol>
<h1 id="实现抢红包插件的-UI-代码"><a href="#实现抢红包插件的-UI-代码" class="headerlink" title="实现抢红包插件的 UI 代码"></a>实现抢红包插件的 UI 代码</h1><p>实现微信自动抢红包功能可以完全不提供 UI 界面，这样每个红包消息过来的时候就自动拆开了。但这样不太好，而且实际的情况下不合适的红包自动抢了会很尴尬，另外从学习逆向开发的角度来说，多练习下也是不错的。但这个功能 UI 不是重点，所以我们还是尽可能的简单处理，只在微信的设置页面添加一个 cell 左边显示自动抢红包功能，右边显示一个开关用来控制该功能。</p>
<p>现在很多人可能会好奇，Tweak.x 编写什么代码呢？.x 文件里面写 Logos 语法的代码。Logos 是一个基于 Perl 语言的正则表达式的预处理器，它通过优雅的类似 Objective-C 的语法简化了为 Objective-C 方法和 C 函数创建 hook 所需的模板代码。如果熟悉 Objective-C 的 runtime 的话，就可以理解为 Logos 语法将平时我们自己通过 runtime 编写的 hook 代码简化了。Logos 语法也没有很多，官方文档在<a href="https://theos.dev/docs/logos-syntax">这里</a>。</p>
<p>了解或熟悉 Logos 语法之后，接下来就是考虑对哪些类，哪些方法进行 hook 了，至于什么是 hook，<a href="hook/hook.md">这篇文章</a> 有介绍。按照刚刚所说的 UI 需求的话，就需要分析微信的设置界面所用的类，和实现的逻辑了。这里会用到界面分析工具 <a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%BF%87%E6%96%87%E7%AB%A0">Reveal</a> 或者 Lookin 等类似工具用于查看设置界面的控制器类，也可以用 <a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%BF%87%E6%96%87%E7%AB%A0">cycript</a>，<a href="%E8%BF%99%E9%87%8C%E4%B9%9F%E6%9C%89%E6%96%87%E7%AB%A0%E4%BA%86">lldb</a> 等命令行工具查看。知道了是哪个控制器类之后，就可以使用 <a href="%E9%9C%80%E8%A6%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0">class-dump</a> 工具对前面脱壳过的微信可执行文件导出所有的头文件，阅读对应的控制器类的头文件了。再结合正向开发的经验，分析应该 hook 哪些类的哪些方法。</p>
<p>这里我们以 Reveal 为例，作者使用的是 Reveal46，因为 Reveal47 要求 iOS13 以上了，老版本可以在<a href="https://revealapp.com/updates/46/">官网下载</a>。</p>
<p>在手机上的 Cydia 搜索安装 Reveal2Loader 并安装。安装成功之后还需要再去设置中，找到 Reveal 项，进入 Enabled Applications 打开微信的右侧开关，这样才会在启动微信的时候注入 Reveal 服务。Reveal2Loader 自带的 RevealServer.framework 很古老了，大概率和你 Mac 上的 Reveal 是不匹配的，但是不用担心，可以将 Mac 上 Reveal 的 RevealServer.framework 复制到越狱设备的 &#x2F;Library&#x2F;Frameworks 文件夹下。可以使用任何你熟悉的方式，如：使用 iFunBox，使用 scp 命令。这里以 scp 命令为例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ scp -r -P 2222 /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework root@localhost:/Library/Frameworks</span><br><span class="line">CodeResources                                                                                                                                                100% 2754     1.1MB/s   00:00</span><br><span class="line">RevealServer.h                                                                                                                                               100%  309   197.0KB/s   00:00</span><br><span class="line">RevealServer                                                                                                                                                 100%   12MB  38.1MB/s   00:00</span><br><span class="line">copy_and_codesign_revealserver.sh                                                                                                                            100% 1399   700.3KB/s   00:00</span><br><span class="line">module.modulemap                                                                                                                                             100%  105    59.6KB/s   00:00</span><br><span class="line">Info.plist</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：需要提前进行端口转发 iproxy 2222:22</p>
</blockquote>
<p>RevealServer.framework 的路径可以通过下图中的方式找到</p>
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-13_00-59-11.jpg" class="">

<p>如果你使用的是较新的 iOS 版本，可能 Reveal2Loader 或者 LookinLoader 都无法正常使用了，没关系，作者都已经发布了适配 rootless 越狱的和较新版本的 <a href="https://github.com/masterKing/RevealLoader2">RevealLoader2</a> 和 <a href="https://github.com/masterKing/LookinLoader2">LookinLoader2</a>。</p>
<p>最终，越狱设备打开微信进入到设置页面并且 Mac 打开 Reveal，就可以在 Reveal 中看到微信 APP 了。我们选择带有 USB 图标的微信，这是通过 USB 进行数据传输的方式，另一个是通过 WiFi 传输数据，在网络不好的情况下会比较慢。</p>
<p>Reveal 的显示如下图：</p>
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-13_13-09-41.jpg" class="">

<p>如果 <code>WCTableView</code> 对象的数据源就是 <code>NewSettingViewController</code> 对象那就可以直接对 <code>NewSettingViewController</code> 进行 hook 了。但如果不是的话，就没有必要对 <code>NewSettingViewController</code> 进行 hook 了没有意义。Reveal 无法进行命令交互，给我们提供更多的信息，这一点 Lookin 做的更好。这时，可以使用 cycript 或 lldb 进行验证。这里以 cycript 为例：</p>
<p>在越狱设备上进入 Cydia，搜索 Cycript 并安装，之后我们远程登录到越狱设备就可以使用 Cycript 了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# cycript -p WeChat</span><br><span class="line">cy# <span class="comment">#0x117f56e00</span></span><br><span class="line"><span class="comment">#&quot;&lt;WCTableView: 0x117f56e00; baseClass = UITableView; frame = (0 0; 320 568); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x286cee370&gt;; layer = &lt;CALayer: 0x2827e89e0&gt;; contentOffset: &#123;0, -64&#125;; contentSize: &#123;320, 942&#125;; adjustedContentInset: &#123;64, 0, 0, 0&#125;&gt;&quot;</span></span><br><span class="line">cy# <span class="comment">#0x117f56e00.dataSource</span></span><br><span class="line"><span class="comment">#&quot;&lt;WCTableViewManager: 0x286cef9f0&gt;&quot;</span></span><br><span class="line">cy#</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：0x117f56e00 这个内存地址是从 Reveal 中获取的</p>
</blockquote>
<p>结果发现 <code>WCTableView</code> 对象 0x117f56e00 的 <code>dataSource</code> 并不是控制器 <code>NewSettingViewController</code> 而是一个 <code>WCTableViewManager</code> 类的对象。那么接下来就是对 <code>WCTableViewManager</code> 类的头文件进行分析了。其实知道了 <code>WCTableView</code> 的数据源是 <code>WCTableViewManager</code> 之后也可以不用再分析下去了，<code>WCTableViewManager</code> 一定会实现 <code>UITableView</code> 的数据源方法的。但是为了方便后面编写 tweak 代码，我们这里还是要介绍一下 class-dump。</p>
<p><a href="https://github.com/nygard/class-dump">class-dump</a> 是一个用于从 macOS 和 iOS 应用的 Mach-O 可执行文件中提取 Objective-C 类、协议和方法声明的工具。它不进行完整的反汇编或反编译，而是专注于提取头文件（.h 文件）中的结构信息，从而帮助开发者和逆向工程师了解应用的类结构和接口。</p>
<p>使用 class-dump 提取微信的头文件的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] class-dump -H Payload/WeChat.app/WeChat -o WeChatHeaders</span><br><span class="line">2024-10-06 20:38:38.536 class-dump[80038:3372682] Unknown load <span class="built_in">command</span>: 0x00000032</span><br><span class="line">2024-10-06 20:38:52.655 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, ready_</span><br><span class="line">2024-10-06 20:38:58.673 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, scheme</span><br><span class="line">2024-10-06 20:38:58.673 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, queue</span><br><span class="line">2024-10-06 20:38:58.676 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, svrID</span><br><span class="line">...</span><br><span class="line">省略很多打印</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里我们需要用到刚刚砸壳成功的微信，否则是无法成功提取头文件的。使用 <code>la</code> 查看当前文件夹下的内容，可以看到多了一个 WeChatHeaders 的文件，里面有接近3万个的头文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] la</span><br><span class="line">total 526064</span><br><span class="line">-rw-r--r--@     1 Franky  staff   6.0K Jul  2 16:39 .DS_Store</span><br><span class="line">drwxr-xr-x     13 Franky  staff   416B Oct  6 18:57 .git</span><br><span class="line">-rw-r--r--      1 Franky  staff    30B May  4  2023 .gitignore</span><br><span class="line">-rw-r--r--      1 Franky  staff   1.0K May  4  2023 LICENSE</span><br><span class="line">drwxr-xr-x      3 Franky  staff    96B Oct  6 20:29 Payload</span><br><span class="line">-rw-r--r--@     1 Franky  staff   3.2K May  4  2023 README.md</span><br><span class="line">drwxr-xr-x  29607 Franky  staff   925K Oct  6 20:39 WeChatHeaders</span><br><span class="line">-rw-r--r--      1 Franky  staff    11K May  4  2023 dump.js</span><br><span class="line">-rwxr-xr-x@     1 Franky  staff    11K Apr  2  2024 dump.py</span><br><span class="line">-rwxr-xr-x      1 Franky  staff   2.0K May  4  2023 process.sh</span><br><span class="line">-rw-r--r--@     1 Franky  staff   157B May  4  2023 requirements.txt</span><br><span class="line">-rw-r--r--      1 Franky  staff   255M Oct  6 20:30 微信.ipa</span><br></pre></td></tr></table></figure>

<p>使用 Sublime Text 打开这个 WeChatHeaders 文件夹，Sublime 是一个编辑器，对于这种上万份的头文件不推荐用 Xcode 打开，会很卡顿。当然也可以用你熟悉的其他编辑器打开。搜索 <code>WCTableViewManager</code> 就可以看到对应的头文件内容了。</p>
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-06_20-49-33.png" class="">

<p>有了这个头文件之后，我们在编写 tweak 的时候，就可以方便的进行复制粘贴了，而不是每一行每一句代码，如这里的 <code>UITableView</code> 的数据源方法都自己敲一遍。</p>
<p>最后同样是使用 Sublime 打开我们之前创建 tweak 项目，选择 Tweak.x 文件删掉默认生成的代码进行编辑，代码如下：</p>
<figure class="highlight objective-c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="comment">// 界面代码</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCTableViewManager</span></span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">%hook WCTableViewManager</span><br><span class="line"></span><br><span class="line">- (<span class="type">double</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">UITableViewCell</span> * cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:(<span class="built_in">UITableViewCellStyleDefault</span>) reuseIdentifier:<span class="literal">nil</span>];</span><br><span class="line">        cell.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="keyword">if</span>([indexPath row] == <span class="number">0</span>)&#123;</span><br><span class="line">            cell.textLabel.text = <span class="string">@&quot;自动抢红包&quot;</span>;</span><br><span class="line">            <span class="built_in">UISwitch</span> * switchView = [[<span class="built_in">UISwitch</span> alloc] init];</span><br><span class="line">            switchView.on = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">            [switchView addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(switchChang:) forControlEvents:(<span class="built_in">UIControlEventValueChanged</span>)];</span><br><span class="line">            cell.accessoryView = switchView;</span><br><span class="line">            <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@&quot;/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle/&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>] == <span class="number">1</span>) ? <span class="string">@&quot;locked.png&quot;</span> : <span class="string">@&quot;unlocked.png&quot;</span>;</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br><span class="line">            cell.imageView.image = image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="type">long</span> <span class="type">long</span>)section&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;(section == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)])&#123;</span><br><span class="line">        <span class="keyword">return</span> %orig+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%new</span><br><span class="line">-(<span class="type">void</span>)switchChang:(<span class="built_in">UISwitch</span> *)switchView&#123;</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:switchView.isOn forKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">    [MSHookIvar&lt;<span class="built_in">UITableView</span> *&gt;(<span class="keyword">self</span>,<span class="string">&quot;_tableView&quot;</span>) reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>这段代码对于有经验的 iOS 应用开发者来说，即很熟悉又有点陌生，陌生的是一些 Logos 语法，而熟悉的是这代码基本就像是 Objective-C。这段代码中的<code>[MSHookIvar&lt;UITableView *&gt;(self,&quot;_tableView&quot;) reloadData];</code>用到了 Objective-C++ 的语法，直接编译会不通过。需要将 tweak.x 改为 tweak.xm，同时修改 Makefile 中的 <code>redEnveloper_FILES = Tweak.x</code> 为 <code>redEnveloper_FILES = Tweak.xm</code>。这样才能通过编译。同时我们使用了两张图片作为开关的状态显示。最终项目的结构如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/redEnveloper/ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── Tweak.xm</span><br><span class="line">├── control</span><br><span class="line">├── layout</span><br><span class="line">│   └── Library</span><br><span class="line">│       └── MobileSubstrate</span><br><span class="line">│           └── DynamicLibraries</span><br><span class="line">│               └── redEnveloper.bundle</span><br><span class="line">│                   ├── locked.png</span><br><span class="line">│                   └── unlocked.png</span><br><span class="line">└── redEnveloper.plist</span><br><span class="line"></span><br><span class="line">6 directories, 6 files</span><br></pre></td></tr></table></figure>

<p>其中 layout 及下面的子文件夹是我们自己创建的，在编译的时候，Thoes 会将这个文件夹下面的内容移动到越狱设备的对应文件路径下。意思就是在编译安装之后，越狱设备的 <code>/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle</code> 路径下放了两张图片。这个 layout 文件夹相当于 iOS 文件系统的根目录一样。</p>
<p>这样界面相关的代码就全部完成了。我们编译打包安装看看效果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/iOSREProject/redEnveloper/ make clean &amp;&amp; make package &amp;&amp; make install</span><br><span class="line">==&gt; Cleaning…</span><br><span class="line">&gt; Making all <span class="keyword">for</span> tweak redEnveloper…</span><br><span class="line">==&gt; Preprocessing Tweak.xm…</span><br><span class="line">==&gt; Preprocessing Tweak.xm…</span><br><span class="line">==&gt; Compiling Tweak.xm (arm64)…</span><br><span class="line">==&gt; Compiling Tweak.xm (arm64e)…</span><br><span class="line">==&gt; Linking tweak redEnveloper (arm64)…</span><br><span class="line">ld: warning: -multiply_defined is obsolete</span><br><span class="line">==&gt; Generating debug symbols <span class="keyword">for</span> redEnveloper…</span><br><span class="line">==&gt; Linking tweak redEnveloper (arm64e)…</span><br><span class="line">ld: warning: -multiply_defined is obsolete</span><br><span class="line">==&gt; Generating debug symbols <span class="keyword">for</span> redEnveloper…</span><br><span class="line">==&gt; Merging tweak redEnveloper…</span><br><span class="line">==&gt; Signing redEnveloper…</span><br><span class="line">&gt; Making stage <span class="keyword">for</span> tweak redEnveloper…</span><br><span class="line">dm.pl: building package `com.yourcompany.redenveloper:iphoneos-arm<span class="string">&#x27; in `./packages/com.yourcompany.redenveloper_0.0.1-15+debug_iphoneos-arm.deb&#x27;</span></span><br><span class="line">==&gt; Installing…</span><br><span class="line">(Reading database ... 7856 files and directories currently installed.)</span><br><span class="line">Preparing to unpack /tmp/_theos_install.deb ...</span><br><span class="line">Unpacking com.yourcompany.redenveloper (0.0.1-15+debug) over (0.0.1-14+debug) ...</span><br><span class="line">Setting up com.yourcompany.redenveloper (0.0.1-15+debug) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> org.coolstar.sileo (2.5) ...</span><br><span class="line">Not running <span class="keyword">in</span> Sileo. Trigger UICache</span><br><span class="line">==&gt; Unloading WeChat…</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>&amp;&amp;</code> 符号将多个命令合并一起执行了。命令运行时，手机上的微信会被杀死。命令完成后我们打开微信，进入设置页面，滑倒最底部就会看到新增的界面了。 </p>
<img src="./微信抢红包插件/IMG_0002.PNG" alt="IMG_0002.PNG" width="50%" />



<h1 id="实现抢红包插件的功能代码"><a href="#实现抢红包插件的功能代码" class="headerlink" title="实现抢红包插件的功能代码"></a>实现抢红包插件的功能代码</h1><p>实现自动抢红包功能的思路就是，在我们收到消息的时候，判断是红包消息，就调用打开红包的代码。完整的分析流程会十分耗时耗力，这里只大概的讲述一下。实际完成抢红包功能之后就会发现，实际所写的代码并不多，但是分析出如何写才是真正耗费时间精力的地方。</p>
<h2 id="1-定位收到微信消息的方法"><a href="#1-定位收到微信消息的方法" class="headerlink" title="1.定位收到微信消息的方法"></a>1.定位收到微信消息的方法</h2><p>为了定位收到微信消息的方法，我们可以从聊天页面出发，hook 聊天页面的所有方法，然后让对方发送消息过来，从而发现接收消息时调用了哪些方法。</p>
<p>Theos 附带了一个 logify.pl 命令行程序，它将 Objective-C 头文件（或任何包含 @interface 和方法定义的文件）转换为 Logos 输入文件，以便记录和打印所有函数调用。先使用 Reveal 查看微信聊天页面，可以知道是 <code>BaseMsgContentViewController</code> 类。然后将使用 logify.pl 将这个类的头文件转成 xm 文件并添加到我们抢红包的 tweak 工程中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">cd</span> ~/redEnveloper</span><br><span class="line"> ~/redEnveloper/ logify.pl ~/frida-ios-dump/WeChatHeaders/BaseMsgContentViewController.h &gt; ./BaseMsgContentViewController.xm</span><br><span class="line"> ~/redEnveloper/ <span class="built_in">ls</span></span><br><span class="line">BaseMsgContentViewController.xm Tweak.xm                        layout                          redEnveloper.plist</span><br><span class="line">Makefile                        control                         packages</span><br></pre></td></tr></table></figure>

<p>可以看到使用 logify.pl 之后多出了一个 <code>BaseMsgContentViewController.xm</code> 文件。还需要在 Makefile 文件中添加这个文件，Theos 才会在编译时处理这个文件。makefile 文件内容如下所示:</p>
<figure class="highlight objective-c++"><table><tr><td class="code"><pre><span class="line">TARGET := iphone:clang:latest:<span class="number">7.0</span></span><br><span class="line">INSTALL_TARGET_PROCESSES = WeChat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include $(THEOS)/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = redEnveloper</span><br><span class="line"></span><br><span class="line">redEnveloper_FILES = Tweak.xm BaseMsgContentViewController.xm</span><br><span class="line">redEnveloper_CFLAGS = -fobjc-arc</span><br><span class="line"></span><br><span class="line">include $(THEOS_MAKE_PATH)/tweak.mk</span><br></pre></td></tr></table></figure>

<p>这个时候<code>make package</code>会报很多错误，主要是 logify.pl 生成的文件并不能直接使用，我们一起解决:</p>
<ul>
<li>添加 <code>UIKit</code> 头文件</li>
<li>声明用到的类和协议</li>
<li>移除 <code>- (void).cxx_destruct &#123; %log; %orig; &#125;</code> 方法</li>
<li>将 <code>CDUnknownBlockType</code> 改为 id</li>
<li>删掉 <code>inout</code> </li>
<li>Makefile 中给 redEnveloper_CFLAGS &#x3D; -fobjc-arc 后面添加 -Wno-ignored-qualifiers 编译器标记</li>
</ul>
<p>再次<code>make package</code>就可以成功编译了。之后<code>make install</code>安装到越狱设备上。我们在微信的聊天页面等待接收消息，然后打开 Mac 的控制台程序，选择我们的越狱设备，右侧搜索框输入 WeChat 过滤其他不关心的打印信息。接下来就可以给我们的越狱设备发生微信消息了，查看控制器台的打印信息，可以发现每次收到新消息的时候，都会调用以下这些方法，而高亮选中的方法带有一个 <code>addMessageNode:</code> 参数令人感到兴奋。</p>
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-13_15-09-33.jpg" class="">

<p>尝试对这个方法下断点，打印它的调用堆栈，看能否看到有用的信息。这里运用到了 lldb+debugserver 远程调试</p>
<p>debugserver 和 lldb 是可以通过无线网络进行连接的，但是为了速度考虑，我们还是通过 USB 进行连接会更好，所以我们先进行端口映射，将越狱设备的 3333 端口和 Mac 电脑的 3333 端口关联。然后都通过访问本机的 3333 端口就可以通过 USB 建立连接了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ iproxy 3333:3333</span><br><span class="line">Creating listening port 3333 <span class="keyword">for</span> device port 3333</span><br><span class="line">waiting <span class="keyword">for</span> connection</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>越狱设备打开包管理器 Sileo 或 Cydia 搜索 debugserver 并安装。安装好之后，我们就可以在 iOS 上运行 debugserver 了。远程登录到越狱设备，然后运行 debugserver 程序附加到微信进程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# debugserver-10 localhost:3333 --attach=WeChat</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-10.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process WeChat...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后再新建一个终端窗口，进入 lldb 交互，进行连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) process connect connect://localhost:3333</span><br><span class="line">Process 11908 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000018b5840f4 libsystem_kernel.dylib`mach_msg_trap + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18b5840f4 &lt;+8&gt;: ret</span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x18b5840f8 &lt;+0&gt;: mov    x16, <span class="comment">#-0x20</span></span><br><span class="line">    0x18b5840fc &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x18b584100 &lt;+8&gt;: ret</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以像在 Xcode 控制台里 po 一样调试微信了。从上面控制台的打印中或者 Reveal 里面，我们可以得到 <code>BaseMsgContentViewController</code> 的内存地址。调用对象的一个隐藏私有方法 <code>__methodDescriptionForClass:</code> 来获取它所有的方法。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) po [0x117dad600 __methodDescriptionForClass:(<span class="built_in">id</span>)[0x117dad600 class]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> BaseMsgContentViewController:</span><br><span class="line">	Class Methods:</span><br><span class="line">		+ (void) reload:(<span class="built_in">id</span>)arg1 sections:(<span class="built_in">id</span>)arg2 withRowAnimation:(long)arg3; (0x118372ef4)</span><br><span class="line">	Properties:</span><br><span class="line">		@property (weak, nonatomic) MMPageSheetAdapter* pageSheetAdapter;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">		@property (retain, nonatomic) MMMsgContentNavBar* tipsNavBar;  (@synthesize tipsNavBar = _tipsNavBar;)</span><br><span class="line">		@property (retain, nonatomic) MMNewMsgContentNavBar* tipsNewNavBar;  (@synthesize tipsNewNavBar = _tipsNewNavBar;)</span><br><span class="line">		@property (retain, nonatomic) MessageTipView* messageTipView;  (@synthesize messageTipView = _messageTipView;)</span><br><span class="line">		@property (retain, nonatomic) UIScreenEdgePanGestureRecognizer* popBackInteractivePopGesture;  (@synthesize popBackInteractivePopGesture = _popBackInteractivePopGesture;)</span><br><span class="line">		@property (retain, nonatomic) UIColor* chatroomBkgColor;  (@synthesize chatroomBkgColor = _chatroomBkgColor;)</span><br><span class="line">		@property (retain, nonatomic) CMessageWrap* locateMsg;  (@synthesize locateMsg = _locateMsg;)</span><br><span class="line">		@property (weak, nonatomic) &lt;BaseMsgContentDelgate&gt;* m_delegate;  (@synthesize m_delegate = m_delegate;)</span><br><span class="line">		@property (weak, nonatomic) &lt;BaseMsgContentInBackgroundThreadDelgate&gt;* m_backgroundThreadDelegate;  (@synthesize m_backgroundThreadDelegate = m_backgroundThreadDelegate;)</span><br><span class="line">		@property (retain, nonatomic) MMInputToolView* toolView;  (@synthesize toolView = _inputToolView;)</span><br><span class="line">		@property (retain, nonatomic) MMTimer* m_LockerTimer;  (@synthesize m_LockerTimer = m_LockerTimer;)</span><br><span class="line">		@property (retain, nonatomic) UIView* m_msgReceivingTipsView;  (@synthesize m_msgReceivingTipsView = m_msgReceivingTipsView;)</span><br><span class="line">		@property (retain, nonatomic) NSMutableArray* m_shareContacts;  (@synthesize m_shareContacts = m_shareContacts;)</span><br><span class="line">		@property (nonatomic) BOOL m_bIsInMainFrame;  (@synthesize m_bIsInMainFrame = _m_bIsInMainFrame;)</span><br><span class="line">		@property (nonatomic) unsigned long m_searchScene;  (@synthesize m_searchScene = m_searchScene;)</span><br><span class="line">		@property (retain, nonatomic) BadRoomLogicController* m_badRoomLogicController;  (@synthesize m_badRoomLogicController = _m_badRoomLogicController;)</span><br><span class="line">		@property (retain, nonatomic) MMRichTextCoverView* richTextCoverView;  (@synthesize richTextCoverView = _richTextCoverView;)</span><br><span class="line">		@property (retain, nonatomic) RichTextView* richTextView;  (@synthesize richTextView = _richTextView;)</span><br><span class="line">		@property (weak, nonatomic) MMInputMsgReferView* msgReferView;  (@synthesize msgReferView = _msgReferView;)</span><br><span class="line">		@property (nonatomic) unsigned int uiMultiSelectMaxCount;  (@synthesize uiMultiSelectMaxCount = _uiMultiSelectMaxCount;)</span><br><span class="line">		@property (nonatomic) unsigned int uiMultiSelectMaxMegaBytes;  (@synthesize uiMultiSelectMaxMegaBytes = _uiMultiSelectMaxMegaBytes;)</span><br><span class="line">		@property (retain, nonatomic) ChatRoomHistoryShareStat* oRoomHistoryStat;  (@synthesize oRoomHistoryStat = _oRoomHistoryStat;)</span><br><span class="line">		@property (retain, nonatomic) UIView* chatRoomDismissedView;  (@synthesize chatRoomDismissedView = _chatRoomDismissedView;)</span><br><span class="line">		@property (nonatomic) BOOL dismissWithoutReset;  (@synthesize dismissWithoutReset = _dismissWithoutReset;)</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">	Instance Methods:</span><br><span class="line">		- (Class) superclass; (0x11838d270)</span><br><span class="line">		- (unsigned long) <span class="built_in">hash</span>; (0x11838d204)</span><br><span class="line">		- (<span class="built_in">id</span>) description; (0x11838d144)</span><br><span class="line">		- (<span class="built_in">id</span>) debugDescription; (0x11838d084)</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		方法太多，后续都省略了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用搜索功能，找到我们需要的方法 addMessageNode ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		- (void) MoreMsgBtnUpdate:(unsigned int)arg1 unReadCount:(unsigned int)arg2; (0x118382ec0)</span><br><span class="line">		- (void) setM_searchScene:(unsigned long)arg1; (0x1183744a0)</span><br><span class="line">		- (void) addNoMoreMessageNode:(<span class="built_in">id</span>)arg1 addMoreMsg:(BOOL)arg2; (0x1183837f4)</span><br><span class="line">		- (void) addMessageNode:(<span class="built_in">id</span>)arg1 layout:(BOOL)arg2 addMoreMsg:(BOOL)arg3; (0x11838347c)</span><br><span class="line">		- (void) updateBanner; (0x11837a644)</span><br><span class="line">		- (long) getTextViewMarkedLength; (0x118385bb8)</span><br><span class="line">		- (void) CancelRecording; (0x11837f898)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面的地址就是方法实现的内存地址。对它下断点，然后让程序继续运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) breakpoint <span class="built_in">set</span> --address 0x11838347c</span><br><span class="line">Breakpoint 1: <span class="built_in">where</span> = redEnveloper.dylib`_logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(BaseMsgContentViewController*, objc_selector*, objc_object*, bool, bool) at BaseMsgContentViewController.xm:491, address = 0x000000011838347c</span><br><span class="line">(lldb) c</span><br><span class="line">Process 12265 resuming</span><br></pre></td></tr></table></figure>

<p>再次发送一条新的消息过来，就可以看到断点被命中了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Process 12265 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000011838347c redEnveloper.dylib` _logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(self=0x0000000128322860, _cmd=&quot;\xa7\xb4\xba\U00000012\xa1%&quot;, arg1=0x000000010f1a96fa, arg2=false, arg3=false)  at BaseMsgContentViewController.xm:491</span></span><br><span class="line">   488 	- (void)onLoadMoreMessage &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   489 	- (void)initHistroyMessageNodeData &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   490 	- (void)replaceMessageNode:(<span class="built_in">id</span>)arg1 withMessageNodeList:(<span class="built_in">id</span>)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">-&gt; 491 	- (void)addMessageNode:(<span class="built_in">id</span>)arg1 layout:(_Bool)arg2 addMoreMsg:(_Bool)arg3 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   492 	- (void)addChatViewModel:(<span class="built_in">id</span>)arg1 addMoreMsg:(_Bool)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   493 	- (void)tryAddTipsNodeForInviteHistory:(<span class="built_in">id</span>)arg1 addMoreMsg:(_Bool)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   494 	- (unsigned int)getNeedAddTimeWithMsgWrap:(<span class="built_in">id</span>)arg1 <span class="keyword">time</span>:(unsigned int)arg2 &#123; %<span class="built_in">log</span>; unsigned int r = %orig; NSLog(@<span class="string">&quot; = %u&quot;</span>, r); <span class="built_in">return</span> r; &#125;</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>奇怪的是，断点怎么跑到了 redEnveloper.dylib 的 _logos_method… 中去了，其实这就是 Theos 的原理，它将我们写的代码制作成一个 dylib 文件，然后在启动目标进程的时候，注入到目标进程中去，所以我们在 tweak 中写的代码才会被执行。而断点断在这里的原因是 BaseMsgContentViewController.xm 中对 BaseMsgContentViewController 的所有方法进行了 hook 。</p>
<p>断点命中后，接下来使用 bt 命令查看调用堆栈信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">  * frame <span class="comment">#0: 0x000000011838347c redEnveloper.dylib` _logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(self=0x0000000128322860, _cmd=&quot;\xa7\xb4\xba\U00000012\xa1%&quot;, arg1=0x000000010f1a96fa, arg2=false, arg3=false)  at BaseMsgContentViewController.xm:491</span></span><br><span class="line">    frame <span class="comment">#1: 0x0000000100f83ac8 WeChat` ___lldb_unnamed_symbol12406  + 800</span></span><br><span class="line">    frame <span class="comment">#2: 0x000000010374b558 WeChat` ___lldb_unnamed_symbol184229  + 64</span></span><br><span class="line">    frame <span class="comment">#3: 0x0000000100f62ee4 WeChat` ___lldb_unnamed_symbol12051  + 624</span></span><br><span class="line">    frame <span class="comment">#4: 0x000000010df9bb70 WeChat` ___lldb_unnamed_symbol875987  + 244</span></span><br><span class="line">    frame <span class="comment">#5: 0x000000010df31348 WeChat` ___lldb_unnamed_symbol874420  + 168</span></span><br><span class="line">    frame <span class="comment">#6: 0x00000001030a7ea8 WeChat` ___lldb_unnamed_symbol157924  + 648</span></span><br><span class="line">    frame <span class="comment">#7: 0x000000010df52fd4 WeChat` ___lldb_unnamed_symbol874880  + 180</span></span><br><span class="line">    frame <span class="comment">#8: 0x000000018c47a690 Foundation` __NSThreadPerformPerform  + 336</span></span><br><span class="line">    frame <span class="comment">#9: 0x000000018b984f1c CoreFoundation` __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__  + 24</span></span><br><span class="line">    frame <span class="comment">#10: 0x000000018b984e9c CoreFoundation` __CFRunLoopDoSource0  + 88</span></span><br><span class="line">    frame <span class="comment">#11: 0x000000018b984784 CoreFoundation` __CFRunLoopDoSources0  + 176</span></span><br><span class="line">    frame <span class="comment">#12: 0x000000018b97f6c0 CoreFoundation` __CFRunLoopRun  + 1004</span></span><br><span class="line">    frame <span class="comment">#13: 0x000000018b97efb4 CoreFoundation` CFRunLoopRunSpecific  + 436</span></span><br><span class="line">    frame <span class="comment">#14: 0x000000018db8179c GraphicsServices` GSEventRunModal  + 104</span></span><br><span class="line">    frame <span class="comment">#15: 0x00000001b8211c38 UIKitCore` UIApplicationMain  + 212</span></span><br><span class="line">    frame <span class="comment">#16: 0x0000000106bc8968 WeChat` ___lldb_unnamed_symbol399385  + 956</span></span><br><span class="line">    frame <span class="comment">#17: 0x000000018b4428e0 libdyld.dylib` start  + 4</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>堆栈中出现了很多 ___lldb_unnamed_symbol 未命名的符号，导致我们无法知道具体的调用关系。有几种方式都可以让我们得到想要的信息。</p>
<ul>
<li><p>第一种：使用调用栈帧中的地址减去当前可执行文件在内存中的地址，就得到了这段代码在 MachO 文件中的位置，然后通过反汇编工具，Hopper，ida，ghidra 等就可以找到这段代码所属的方法是什么了。</p>
</li>
<li><p>第二种：使用 sbt，如果一次 sbt 的结果没有成功，那么多试几次，总会有些成功的。sbt 是这个 LLDB <a href="https://github.com/DerekSelander/LLDB">插件</a>中添加的，按照提示安装之后就有了。</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) sbt</span><br><span class="line">frame <span class="comment">#0 : 0x11838347c redEnveloper.dylib`_logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(BaseMsgContentViewController*, objc_selector*, objc_object*, bool, bool)</span></span><br><span class="line">frame <span class="comment">#1 : 0x100f83ac8 WeChat`-[BaseMsgContentLogicController DidAddMsg:] + 800</span></span><br><span class="line">frame <span class="comment">#2 : 0x10374b558 WeChat`-[RoomContentLogicController DidAddMsg:] + 64</span></span><br><span class="line">frame <span class="comment">#3 : 0x100f62ee4 WeChat`-[BaseMsgContentLogicController OnAddMsg:MsgWrap:] + 624</span></span><br><span class="line">frame <span class="comment">#4 : 0x10df9bb70 WeChat`-[MMExtensionCenter callExtension:selector:block:] + 244</span></span><br><span class="line">frame <span class="comment">#5 : 0x10df31348 WeChat`-[MMContext callExtension:selector:block:] + 168</span></span><br><span class="line">frame <span class="comment">#6 : 0x1030a7ea8 WeChat`-[CMessageMgr MainThreadNotifyToExt:] + 648</span></span><br><span class="line">frame <span class="comment">#7 : 0x10df52fd4 WeChat`___lldb_unnamed_symbol874880 ... unresolved womp womp + 180</span></span><br><span class="line">frame <span class="comment">#8 : 0x18c47a690 Foundation`__NSThreadPerformPerform + 336</span></span><br><span class="line">frame <span class="comment">#9 : 0x18b984f1c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24</span></span><br><span class="line">frame <span class="comment">#10: 0x18b984e9c CoreFoundation`__CFRunLoopDoSource0 + 88</span></span><br><span class="line">frame <span class="comment">#11: 0x18b984784 CoreFoundation`__CFRunLoopDoSources0 + 176</span></span><br><span class="line">frame <span class="comment">#12: 0x18b97f6c0 CoreFoundation`__CFRunLoopRun + 1004</span></span><br><span class="line">frame <span class="comment">#13: 0x18b97efb4 CoreFoundation`CFRunLoopRunSpecific + 436</span></span><br><span class="line">frame <span class="comment">#14: 0x18db8179c GraphicsServices`GSEventRunModal + 104</span></span><br><span class="line">frame <span class="comment">#15: 0x1b8211c38 UIKitCore`UIApplicationMain + 212</span></span><br><span class="line">frame <span class="comment">#16: 0x106bc8968 WeChat`___lldb_unnamed_symbol399385 ... unresolved womp womp + 956</span></span><br><span class="line">frame <span class="comment">#17: 0x18b4428e0 libdyld.dylib`start + 4</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>从调用堆栈中，看到了一个 <code>CMessageMgr</code> 类。从名称来看它叫消息管理者，一定可以从中得到更多信息。继续使用 logify.pl 将 <code>CMessageMgr</code> 类的全部方法进行 hook 并查看打印。会发现消息发送过来的时候，很多方法会执行，但是以下这个方法是比较合适的，因为能拿到消息参数。</p>
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-13_15-21-40.jpg" class="">

<p>最终找到 -[CMessageMgr onNewSyncAddMessage:] 方法。当然不是一定要这个方法，其他任何合适的方法都可以进行抢红包的。定位到收到微信消息的方法之后，自然就是分析如何开红包了，其实从正向开发的经验可以猜测，一定是点击红包的按钮之后，发生网络请求打开红包了。</p>
<h2 id="2-定位打开红包的方法"><a href="#2-定位打开红包的方法" class="headerlink" title="2.定位打开红包的方法"></a>2.定位打开红包的方法</h2><p>这个相对来说简单一点，从 UI 入手。越狱设备点开一个红包，使用 Reveal 查看开按钮，复制按钮的内存地址，如下图:</p>
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-10_10-30-57.png" class="">
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-13_15-34-23.jpg" class="">

<p>我发现新版本的 Reveal 还没有老版本的好用呢，明明老版本的 Reveal 可以显示到具体的拆红包按钮，新版本却只能显示一个整体。</p>
<p>然后使用 lldb+debugserver 进行远程调试：</p>
<p>先远程登录越狱设备，使用 debugserver 附加到微信进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# debugserver-10 localhost:3333 --attach=WeChat</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-10.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process WeChat...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger instructions <span class="keyword">for</span> process 0.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：这里进行了两个端口转发，一个 2222:22，另一个是 3333:3333，所以才能正常运行。<code>iproxy 2222:22 3333:3333</code></p>
</blockquote>
<p>然后进入 lldb 并调试这个按钮的 target 和 action ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) process connect connect://localhost:3333</span><br><span class="line">Process 12437 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000018b5840f4 libsystem_kernel.dylib` mach_msg_trap  + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18b5840f4 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;mach_msg_overwrite_trap:    0x18b5840f8 &lt;+0&gt;: mov    x16, #-0x20</span></span><br><span class="line"><span class="string">    0x18b5840fc &lt;+4&gt;: svc    #0x80</span></span><br><span class="line"><span class="string">    0x18b584100 &lt;+8&gt;: ret</span></span><br><span class="line"><span class="string">libsystem_kernel.dylib&#x27;</span>semaphore_signal_trap:    0x18b584104 &lt;+0&gt;: mov    x16, <span class="comment">#-0x21</span></span><br><span class="line">    0x18b584108 &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x18b58410c &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;semaphore_signal_all_trap:    0x18b584110 &lt;+0&gt;: mov    x16, #-0x22</span></span><br><span class="line"><span class="string">Target 0: (WeChat) stopped.</span></span><br><span class="line"><span class="string">(lldb) po [0x1476a1000 allTargets]</span></span><br><span class="line"><span class="string">&#123;(</span></span><br><span class="line"><span class="string">    &lt;WCRedEnvelopesReceiveHomeView: 0x147693670; frame = (0 0; 320 568); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x2829f1480&gt;&gt;</span></span><br><span class="line"><span class="string">)&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(lldb) po [0x1476a1000 actionsForTarget:0x147693670 forControlEvent:64]</span></span><br><span class="line"><span class="string">&lt;__NSArrayM 0x286397990&gt;(</span></span><br><span class="line"><span class="string">OnOpenRedEnvelopes</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(lldb)</span></span><br></pre></td></tr></table></figure>

<p>找到了 <code>-[WCRedEnvelopesReceiveHomeView OnOpenRedEnvelopes]</code> 方法。找到这个方法就能成功实现抢红包功能了吗？当然没有那么简单。我们在收到微信消息的时候，很可能连聊天页面都没有进入，更不可能存在 <code>WCRedEnvelopesReceiveHomeView</code> 对象了，所以无法调用这个方法。有人会想，我自己创建一个 <code>WCRedEnvelopesReceiveHomeView</code> 对象调用 <code>OnOpenRedEnvelopes</code> 方法能不能行呢。前提是你得知道 <code>WCRedEnvelopesReceiveHomeView</code> 正确的初始化方法啊。微信开发人员在创建 <code>WCRedEnvelopesReceiveHomeView</code> 对象的时候肯定给了其他的参数，你不能认为调用一个 <code>initWithFrame:</code> 方法创建一个 <code>WCRedEnvelopesReceiveHomeView</code> 对象之后就万事大吉了。所以还得继续分析开红包的具体代码。这就需要静态分析反汇编代码了，从汇编代码尝试还原出源码。关于 iOS 的 arm64 汇编的文章，也在准备当中。。。敬请期待</p>
<h2 id="3-静态分析开红包的方法"><a href="#3-静态分析开红包的方法" class="headerlink" title="3.静态分析开红包的方法"></a>3.静态分析开红包的方法</h2><p>定位到开红包的方法之后，需要反编译分析这个方法，看看是如何打开红包的，这就需要用到常见的反编译工具如：IDA Pro，Ghidra，Hopper Disassembler 等。这里以 Hopper 为例:</p>
<img src="/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/Xnip2024-10-10_13-16-08.png" class="">

<p><code>OnOpenRedEnvelopes</code> 方法的倒数第三个 bl 跳转指令，后面指向的是 objc_msgSend 函数，如果知道了它的参数是什么，也就知道了方法最后的走向是什么。所以我们给它下一个断点，但是这个地址 0x10556c8ac 只是在 MachO 文件中的地址，实际内存中的地址，还需要加上 MachO 文件在内存中的首地址，可以使用 <code>image list -o -f WeChat</code> 来获取。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) image list -o -f WeChat</span><br><span class="line">[  0] 0x000000000093c000 /var/containers/Bundle/Application/E51AA5D1-C65C-4E5B-A4AB-34C88E760D49/WeChat.app/WeChat(0x000000010093c000)</span><br></pre></td></tr></table></figure>

<p>接下来将两者相加，就可以用来下内存断点了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) p/x 0x10556c8ac+0x000000000093c000</span><br><span class="line">(long) 0x0000000105ea88ac</span><br><span class="line">(lldb) breakpoint <span class="built_in">set</span> --address 0x0000000105ea88ac</span><br><span class="line">Breakpoint 1: <span class="built_in">where</span> = WeChat`___lldb_unnamed_symbol363752 + 304, address = 0x0000000105ea88ac</span><br><span class="line">(lldb) c</span><br><span class="line">Process 12437 resuming</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>断点下好之后，c 让程序继续执行，然后我们点击开红包按钮，此时断点命中，我们读取寄存器的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Process 12437 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000105ea88ac WeChat` ___lldb_unnamed_symbol363752  + 304</span></span><br><span class="line">WeChat`___lldb_unnamed_symbol363752:</span><br><span class="line">-&gt;  0x105ea88ac &lt;+304&gt;: bl     0x10853ffe4               ; ___lldb_unnamed_symbol518292</span><br><span class="line">    0x105ea88b0 &lt;+308&gt;: mov    x0, x19</span><br><span class="line">    0x105ea88b4 &lt;+312&gt;: bl     0x10853ffcc               ; ___lldb_unnamed_symbol518286</span><br><span class="line">    0x105ea88b8 &lt;+316&gt;: mov    x0, x20</span><br><span class="line">    0x105ea88bc &lt;+320&gt;: ldp    x29, x30, [sp, <span class="comment">#0x60]</span></span><br><span class="line">    0x105ea88c0 &lt;+324&gt;: ldp    x20, x19, [sp, <span class="comment">#0x50]</span></span><br><span class="line">    0x105ea88c4 &lt;+328&gt;: ldp    x22, x21, [sp, <span class="comment">#0x40]</span></span><br><span class="line">    0x105ea88c8 &lt;+332&gt;: ldp    x24, x23, [sp, <span class="comment">#0x30]</span></span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb) register <span class="built_in">read</span> x0</span><br><span class="line">      x0 = 0x0000000281d49a40</span><br><span class="line">(lldb) po 0x0000000281d49a40</span><br><span class="line">&lt;WCRedEnvelopesReceiveControlLogic: 0x281d49a40&gt;</span><br><span class="line"></span><br><span class="line">(lldb) register <span class="built_in">read</span> x1</span><br><span class="line">      x1 = 0x000000010f1c6cc5  <span class="string">&quot;WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes&quot;</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>通过对寄存器的读取，我们得知此时，调用了 <code>-[WCRedEnvelopesReceiveControlLogic WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes]</code> 方法。终于来到了真正开红包的地方了！以及红包相关的逻辑处理的类 <code>WCRedEnvelopesReceiveControlLogic</code>。</p>
<p>继续查看反汇编之后的代码，可以看出这个方法中，拼接了一个字典参数，然后通过调用 <code>OpenRedEnvelopesRequest:</code> 方法发送了请求。</p>
<p>使用 logify.pl 将 <code>WCRedEnvelopesReceiveControlLogic</code> 的所有方法进行 hook，这下我们可以清晰的看到开红包的过程了。在聊天界面点击红包的时候，首先会调用查红包的接口 <code>ReceiverQueryRedEnvelopesRequest:</code> 它返回了一个重要的参数 <code>timingIdentifier</code>，之后显示了开红包的界面，点击开按钮才是开红包的请求 <code>OpenRedEnvelopesRequest:</code>，用到了这个参数。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>此时，我们的需要做的就是将逻辑完善。在收到微信消息的时候，判断是红包消息就发送一个查红包的请求，在它的响应回来的时候，判断是否开了自动抢红包，开了就调用开红包的请求。这就是自动抢红包的完整逻辑了。还有判断是否是红包消息，是否是未拆开的红包等判断逻辑也不用我们自己去猜，微信肯定有它自己的判断，我们只需要找到对应的代码拿过来用就行了，但这都是些小细节了就不再深入了。</p>
<p>最终的完整代码下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCTableViewManager</span></span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMutableDictionary</span> (<span class="title">safeSetObject</span>)</span></span><br><span class="line">- (<span class="type">void</span>)safeSetObject:(<span class="type">id</span>)arg1 forKey:(<span class="type">id</span>)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCBizUtil</span></span></span><br><span class="line">+ (<span class="type">id</span>)dictionaryWithDecodedComponets:(<span class="type">id</span>)arg1 separator:(<span class="type">id</span>)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SKBuiltinBuffer_t</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSData</span> *buffer; <span class="comment">// @dynamic buffer;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> iLen; <span class="comment">// @dynamic iLen;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseRequest</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HongBaoReq</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) BaseRequest *baseRequest; <span class="comment">// @dynamic baseRequest;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> cgiCmd; <span class="comment">// @dynamic cgiCmd;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> outPutType; <span class="comment">// @dynamic outPutType;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">SKBuiltinBuffer_t</span> *reqText; <span class="comment">// @dynamic reqText;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HongBaoRes</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> cgiCmdid; <span class="comment">// @dynamic cgiCmdid;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *errorMsg; <span class="comment">// @dynamic errorMsg;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> errorType; <span class="comment">// @dynamic errorType;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *platMsg; <span class="comment">// @dynamic platMsg;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> platRet; <span class="comment">// @dynamic platRet;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">SKBuiltinBuffer_t</span> *retText; <span class="comment">// @dynamic retText;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CContact</span></span></span><br><span class="line">- (<span class="type">id</span>)getContactDisplayName;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsHeadImgUrl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CContactMgr</span></span></span><br><span class="line">- (<span class="type">id</span>)getSelfContact;</span><br><span class="line">- (<span class="type">id</span>)getContactByNameFromCache:(<span class="type">id</span>)cache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCRedEnvelopesLogicMgr</span></span></span><br><span class="line">- (<span class="type">void</span>)ReceiverQueryRedEnvelopesRequest:(<span class="type">id</span>)arg1;</span><br><span class="line">- (<span class="type">void</span>)OpenRedEnvelopesRequest:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMContext</span></span></span><br><span class="line">+ (<span class="type">id</span>)currentContext;</span><br><span class="line">- (<span class="type">id</span>)getService:(Class)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMMsgLogicManager</span></span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)GetCurrentLogicController;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCPayInfoItem</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_c2cNativeUrl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CMessageWrap</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) WCPayInfoItem *m_oWCPayInfoItem;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsRealChatUsr;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsFromUsr;</span><br><span class="line">- (<span class="type">void</span>)parseWCPayInfoItemIfNeed;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCPayC2CMessageViewModel</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CMessageWrap</span> *messageWrap;</span><br><span class="line">+ (<span class="type">BOOL</span>)canCreateMessageViewModelWithMessageWrap:(<span class="type">id</span>)wrap;</span><br><span class="line">+ (<span class="type">id</span>)createMessageViewModelWithMessageWrap:(<span class="type">id</span>)arg1 contact:(<span class="type">id</span>)arg2 chatContact:(<span class="type">id</span>)arg3;</span><br><span class="line">- (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)bubbleType;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 界面代码</span></span><br><span class="line">%hook WCTableViewManager</span><br><span class="line">- (<span class="type">double</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">UITableViewCell</span> * cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:(<span class="built_in">UITableViewCellStyleDefault</span>) reuseIdentifier:<span class="literal">nil</span>];</span><br><span class="line">        cell.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="keyword">if</span>([indexPath row] == <span class="number">0</span>)&#123;</span><br><span class="line">            cell.textLabel.text = <span class="string">@&quot;自动抢红包&quot;</span>;</span><br><span class="line">            <span class="built_in">UISwitch</span> * switchView = [[<span class="built_in">UISwitch</span> alloc] init];</span><br><span class="line">            switchView.on = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">            [switchView addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(switchChang:) forControlEvents:(<span class="built_in">UIControlEventValueChanged</span>)];</span><br><span class="line">            cell.accessoryView = switchView;</span><br><span class="line">            <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@&quot;/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle/&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>] == <span class="number">1</span>) ? <span class="string">@&quot;locked.png&quot;</span> : <span class="string">@&quot;unlocked.png&quot;</span>;</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br><span class="line">            cell.imageView.image = image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="type">long</span> <span class="type">long</span>)section&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;(section == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)])&#123;</span><br><span class="line">        <span class="keyword">return</span> %orig+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">%new</span><br><span class="line">-(<span class="type">void</span>)switchChang:(<span class="built_in">UISwitch</span> *)switchView&#123;</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:switchView.isOn forKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">    [MSHookIvar&lt;<span class="built_in">UITableView</span> *&gt;(<span class="keyword">self</span>,<span class="string">&quot;_tableView&quot;</span>) reloadData];</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能实现代码</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoGrabRedEnvelopeMgr</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_array;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared;</span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty;</span><br><span class="line">- (<span class="type">void</span>)enqueueDictionary:(<span class="built_in">NSDictionary</span> *)parameter;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dequeueDictionary;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AutoGrabRedEnvelopeMgr</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared&#123;</span><br><span class="line">    <span class="keyword">static</span> AutoGrabRedEnvelopeMgr *mgr = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        mgr = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mgr;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty &#123;</span><br><span class="line">    <span class="keyword">return</span> _array.count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)enqueueDictionary:(<span class="built_in">NSDictionary</span> *)parameter &#123;</span><br><span class="line">    [_array addObject:parameter];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dequeueDictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isEmpty]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dict = [_array firstObject];</span><br><span class="line">        [_array removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初步分析每次收到消息的时候,都会调用到这个方法,那么就可以在这个方法里面进行抢红包;</span></span><br><span class="line">%hook <span class="built_in">CMessageMgr</span></span><br><span class="line">- (<span class="type">void</span>)onNewSyncAddMessage:(<span class="type">id</span>)arg1 &#123; <span class="comment">//CMessageWrap</span></span><br><span class="line">    <span class="comment">// 需要判断一下是否是红包消息,不然每次一有消息过来就去拆红包开红包不合理</span></span><br><span class="line">    <span class="keyword">if</span> ([%c(WCPayC2CMessageViewModel) canCreateMessageViewModelWithMessageWrap:arg1]) &#123; <span class="comment">// 这里确定是红包消息</span></span><br><span class="line">        WCPayC2CMessageViewModel *model = [%c(WCPayC2CMessageViewModel) createMessageViewModelWithMessageWrap:arg1 contact:<span class="literal">nil</span> chatContact:<span class="literal">nil</span>];</span><br><span class="line">        [model.messageWrap parseWCPayInfoItemIfNeed];</span><br><span class="line">        <span class="keyword">if</span> (model.bubbleType == <span class="number">4</span>) &#123; <span class="comment">// 未打开的红包</span></span><br><span class="line">            <span class="keyword">if</span> ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>]) &#123; <span class="comment">// 打开了自动抢红包</span></span><br><span class="line">                <span class="built_in">NSString</span> *m_c2cNativeUrl = model.messageWrap.m_oWCPayInfoItem.m_c2cNativeUrl;</span><br><span class="line">                <span class="built_in">NSUInteger</span> len = [<span class="string">@&quot;wxpay://c2cbizmessagehandler/hongbao/receivehongbao?&quot;</span> length];</span><br><span class="line">                <span class="built_in">NSString</span> * substring = [m_c2cNativeUrl substringFromIndex:len];</span><br><span class="line">                <span class="built_in">NSDictionary</span> * dict = [%c(WCBizUtil) dictionaryWithDecodedComponets:substring separator:<span class="string">@&quot;&amp;&quot;</span>];</span><br><span class="line">                <span class="built_in">NSMutableDictionary</span> * parameter = [%c(<span class="built_in">NSMutableDictionary</span>) dictionary];</span><br><span class="line">                [parameter safeSetObject:<span class="string">@&quot;1&quot;</span> forKey:<span class="string">@&quot;msgType&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:[dict objectForKey:<span class="string">@&quot;sendid&quot;</span>] forKey:<span class="string">@&quot;sendId&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:[dict objectForKey:<span class="string">@&quot;channelid&quot;</span>] forKey:<span class="string">@&quot;channelId&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:m_c2cNativeUrl forKey:<span class="string">@&quot;nativeUrl&quot;</span>];</span><br><span class="line">                MMMsgLogicManager *msgLogicMgr = [[%c(MMContext) currentContext] getService:[%c(MMMsgLogicManager) <span class="keyword">class</span>]];</span><br><span class="line">                <span class="built_in">UIViewController</span> * vc = [msgLogicMgr GetCurrentLogicController];</span><br><span class="line">                <span class="built_in">NSString</span> *inWay;</span><br><span class="line">                <span class="keyword">if</span> (vc == <span class="literal">nil</span> || [vc valueForKey:<span class="string">@&quot;m_contact&quot;</span>] == <span class="literal">nil</span> || ![[vc valueForKey:<span class="string">@&quot;m_contact.isChatroom&quot;</span>] boolValue]) &#123;</span><br><span class="line">                    inWay = <span class="string">@&quot;1&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    inWay = <span class="string">@&quot;0&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                [parameter safeSetObject:inWay forKey:<span class="string">@&quot;inWay&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:<span class="string">@&quot;0&quot;</span> forKey:<span class="string">@&quot;agreeDuty&quot;</span>];</span><br><span class="line">                WCRedEnvelopesLogicMgr *mgr = [[%c(MMContext) currentContext] getService:[%c(WCRedEnvelopesLogicMgr) <span class="keyword">class</span>]];</span><br><span class="line">                [mgr ReceiverQueryRedEnvelopesRequest:[parameter <span class="keyword">copy</span>]];</span><br><span class="line">                [parameter safeSetObject:model.messageWrap.m_nsFromUsr forKey:<span class="string">@&quot;sessionUserName&quot;</span>];</span><br><span class="line">                [AutoGrabRedEnvelopeMgr.shared enqueueDictionary:parameter];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    %orig;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%hook WCRedEnvelopesLogicMgr</span><br><span class="line">- (<span class="type">void</span>)OnWCToHongbaoCommonResponse:(HongBaoRes *)arg1 Request:(HongBaoReq *)arg2&#123;</span><br><span class="line">    %orig;</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *response = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:arg1.retText.buffer options:<span class="built_in">NSJSONReadingMutableContainers</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (arg1.cgiCmdid == <span class="number">3</span>) &#123; <span class="comment">// 表示拆红包,开红包的前一个步骤</span></span><br><span class="line">        <span class="keyword">if</span> (![AutoGrabRedEnvelopeMgr.shared isEmpty] &amp;&amp; [response[<span class="string">@&quot;timingIdentifier&quot;</span>] length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *dic = [AutoGrabRedEnvelopeMgr.shared dequeueDictionary].mutableCopy;</span><br><span class="line">            dic[<span class="string">@&quot;timingIdentifier&quot;</span>] = response[<span class="string">@&quot;timingIdentifier&quot;</span>];</span><br><span class="line">            MMContext *context = [%c(MMContext) currentContext];</span><br><span class="line">            CContactMgr *contactMgr = [context getService:[%c(CContactMgr) <span class="keyword">class</span>]];</span><br><span class="line">            CContact *contact = [contactMgr getSelfContact];</span><br><span class="line">            <span class="built_in">NSString</span> *displayName = [contact getContactDisplayName];</span><br><span class="line">            [dic setObject:displayName forKey:<span class="string">@&quot;nickName&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *headImgUrl = [contact m_nsHeadImgUrl];</span><br><span class="line">            [dic setObject:headImgUrl forKey:<span class="string">@&quot;headImg&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> ([dic objectForKey:<span class="string">@&quot;agreeDuty&quot;</span>]) [dic removeObjectForKey:<span class="string">@&quot;agreeDuty&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> ([dic objectForKey:<span class="string">@&quot;inWay&quot;</span>]) [dic removeObjectForKey:<span class="string">@&quot;inWay&quot;</span>];</span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [<span class="keyword">self</span> OpenRedEnvelopesRequest:dic]; </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>代码完成之后，我们进入终端，cd 到项目的文件夹下，编译打包安装之后，再次进入微信，找到自动抢红包的开关，打开之后，给这个微信账号发送一个红包试试有没有成功！</p>
<p>可以看到实现自动抢红包的 UI 和功能的代码并不是很多，仅仅 200 多行，但是这 200 多行的代码要能自己写出来也是真的挺不容易的。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>微信</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>架构模式</title>
    <url>/2025/06/05/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul>
<li>讲解 MVC、MVVM、MVP 以及你在项目里具体是怎么写的？</li>
<li>你自己用过哪些设计模式？</li>
<li>一般开始做一个项目，你的架构是如何思考的？</li>
</ul>
<h1 id="什么是架构？"><a href="#什么是架构？" class="headerlink" title="什么是架构？"></a>什么是架构？</h1><p>感觉MJ这块讲的不是很好，可能这个确实还是比较抽象，建议多结合ai总结吧。</p>
<p>常见的架构有</p>
<ul>
<li>MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>VIPER</li>
<li>CDD</li>
</ul>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>Apple 官方的 MVC 指的是 Model、View、Controller。Controller 持有 View 和 Model，内部处理协调 View 和 Model 的逻辑。UIKit 框架中的视图框架如 UITableView，UICollectionView 等视图都是典型的 MVC 架构中的 View 层，这些视图不持有任何模型数据。而是在控制器中给视图提供数据。这样的做法让 UIKit 的视图得到了充分的复用。但是这种情况下，Controller 里面的代码会随着业务的增加导致越来越臃肿。因为所有的代码都写在 Controller 里面了。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>View 和 Model 的可重用性高。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>Controller 内的代码会必然越来越多。</li>
</ul>
<h1 id="MVC-变种"><a href="#MVC-变种" class="headerlink" title="MVC-变种"></a>MVC-变种</h1><p>呃，就是 View 持有了 Model，但是 Controller 依旧持有 Model。例子就是一个非常简单的组合视图，APP 图标和底部的名字。新建一个继承自 UIView 的 AppView，让它拥有一个 App 的 Model 属性。。。感觉好鸡肋。意思是按照 Apple 的 MVC 做法，AppView 是不持有 Model 的，但是将其视图暴露给外部。而这种做法就是 AppView 不暴露视图给外部，但是提供一个模型属性暴露给外部。外部给模型赋值就行了。</p>
<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><ul>
<li>Model 模型</li>
<li>View 视图</li>
<li>Presenter 主持者，主持人</li>
</ul>
<p>这里应该贴代码了。。。控制器持有 Presenter。Presenter 也持有控制器，但是是弱引用的。</p>
<p>感觉就是把控制器的一些逻辑移动到 Presenter 里面去了啊。相当于是 Controller 持有 Presenter，而 Presenter 代替 Controller 成为了 View 和 Model 的交流中心。</p>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>看着跟 MVP 一样啊。Presenter 换了个名字而已。。。ViewModel。MJ 说什么双向绑定。。。属性监听？</p>
<p>AppView 持有 ViewModel，ViewModel 然后。。。看不懂</p>
<p>什么 RAC 太重了？又是 KVO 怎么麻烦了？结果直接使用 FBKVOController？</p>
<p>在 AppView 的 ViewModel setter 方法里面，监听 ViewModel 的属性，但是 ViewModel 属性发送变化时，更新 AppView 的视图。</p>
<p>感觉讲的真的还是很勉强。。。最后说什么 VIPER、CDD 都是前面的变种。。。</p>
<h1 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h1><ul>
<li>界面层</li>
<li>业务层</li>
<li>数据层</li>
</ul>
<p>这个讲的更抽象。。。呃，感觉是为了赶紧结课，匆匆了事</p>
<p>NewsService 类提供一个 API 加载数据，内部实现是使用 DBTool 加载本地数据，如果没有本地数据，使用 HPPTTool 加载网络数据。。。这个逻辑也太简单了，到处都是漏洞，首先如果没有本地数据就加载网络数据，那么如果一直没有本地数据就永远加载网络数据去了，这一点可能你会说加载网络数据之后就保存到本地啊，但是保存到本地之后，下次及以后就永远都是使用本地数据不去走网络请求了啊。。。搞不明白，搞这么多层是想干什么</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>这个就是面向对象语言的设计模式了，跟架构模式不相干。。。十分简单的介绍了一下，并没有讲到位。完全没有必要放在这里，而且面向对象语言的设计模式完全可以单开一门课程的。<br>面向对象语言的设计模式，其实是一些特定问题的经过验证的解决方案，经验总结：<br>可以分为三大类</p>
<ul>
<li>创建型模式：</li>
<li>结构型模式：</li>
<li>行为型模式：</li>
</ul>
<p>三分钟讲完面向对象编程语言的设计模式了，还有谁，建议看相关书籍了。。。</p>
]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 iOS 对象模型</title>
    <url>/2025/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-iOS-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>001:<br>讲了 Objective-C 对象的底层是 C 结构体</p>
<h1 id="Objective-C-实例对象"><a href="#Objective-C-实例对象" class="headerlink" title="Objective-C 实例对象"></a>Objective-C 实例对象</h1><p>在日常使用 Objective-C 开发过程中，我们经常会使用 <code>[[NSObject alloc] init]</code> 这样的方式创建一个实例对象，并调用初始化方法。当然实际的情况中可能不是使用 NSObject 类，而是 UIKit 框架中的类，或者是你自定义的子类。实例对象对于我们来说简直是再熟悉不过了，但是各位有没有思考过，对于 <code>NSObject</code> 来说，<code>alloc</code> 方法分配内存，究竟分配了多大的内存空间，分配的内存中存放的又是什么东西，<code>init</code> 方法又究竟初始化了什么东西？如果不是 <code>NSObject</code> 类，而是其他系统框架类，或者我们自定义的类呢？我们先以 <code>NSObject</code> 类为例，分析 <code>alloc</code> 方法究竟是如何分配内存的，分配了多少内存空间，内存中又放的一些什么东西？</p>
<h2 id="NSObject-的实例"><a href="#NSObject-的实例" class="headerlink" title="NSObject 的实例"></a>NSObject 的实例</h2>]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
  <entry>
    <title>记录一个pod install失败的解决方法</title>
    <url>/2018/04/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AApod-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天在网络看到一个 demo,想把它 clone 下来运行一下看看效果,大家都知道一般 clone 下来的项目需要使用 <code>pod install</code> 命令安装一下第三方库的,这个 demo 也不例外;</p>
<p>问题在于这个 demo 的 cocoapods 版本太低了(0.39.0)以至于 Podfile 中有些语法现如今都无法识别…以下截图是执行 <code>pod install</code> 命令之后给出了的错误提示:</p>
<img src="/2018/04/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AApod-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Snip20180416_21.png" class="">

<p>项目的 Podfile 如下:</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;RTPagedCollectionViewLayout_Example&#x27;</span>, :<span class="string">exclusive =&gt;</span> true <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;RTPagedCollectionViewLayout&#x27;</span>, :<span class="string">path =&gt;</span> <span class="string">&#x27;../&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;RTPagedCollectionViewLayout_Tests&#x27;</span>, :<span class="string">exclusive =&gt;</span> true <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;RTPagedCollectionViewLayout&#x27;</span>, :<span class="string">path =&gt;</span> <span class="string">&#x27;../&#x27;</span></span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>大概的意思就是不支持 :exclusive &#x3D;&gt; true语法，在 cocoaPods 1.0 之后 exclusive 语法已经被移除了</p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/4705">这里是Stack Overflow上的解答</a></p>
<p>将相关的代码删除之后,注意<code>,</code>号也要删除;</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;RTPagedCollectionViewLayout_Example&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;RTPagedCollectionViewLayout&#x27;</span>, :<span class="string">path =&gt;</span> <span class="string">&#x27;../&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;RTPagedCollectionViewLayout_Tests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;RTPagedCollectionViewLayout&#x27;</span>, :<span class="string">path =&gt;</span> <span class="string">&#x27;../&#x27;</span></span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>再次执行 <code>pod install</code> 命令,结果如下</p>
<img src="/2018/04/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AApod-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Snip20180416_22.png" class="">

<p>已经安装成功了,给了两个警告⚠️,你可以不用管它,有强迫症的同学可以在 target 前加上 <code>platform :ios, &#39;7.1&#39;</code>,这个 7.1 是你的项目的 Deployment Target…</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">platform :ios, <span class="string">&#x27;7.1&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;RTPagedCollectionViewLayout_Example&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;RTPagedCollectionViewLayout&#x27;</span>, :<span class="string">path =&gt;</span> <span class="string">&#x27;../&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;RTPagedCollectionViewLayout_Tests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;RTPagedCollectionViewLayout&#x27;</span>, :<span class="string">path =&gt;</span> <span class="string">&#x27;../&#x27;</span></span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>再次运行 <code>pod install</code> 完美</p>
<img src="/2018/04/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AApod-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Snip20180416_23.png" class="">

]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><ul>
<li>使用 CADisplayLink、NSTimer 有什么注意点？<ul>
<li>强引用控制器导致控制器，定时器均无法正常释放的问题</li>
<li>依赖 RunLoop，如果 RunLoop 任务繁重可能出现定时器不准时的问题</li>
</ul>
</li>
<li>介绍下内存的几大区域</li>
<li>讲一下你对 iOS 内存管理的理解</li>
<li>autorelease 对象在什么时机会被释放</li>
<li>方法里有局部对象，出了方法后会立即释放吗？</li>
<li>ARC 都帮我们做了什么？</li>
<li>weak 指针的实现原理？</li>
</ul>
<hr>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>在使用 CADisplayLink 或 NSTimer 这类需要添加到 RunLoop 的定时器的时候，需要特别注意的是应用程序的主线程 RunLoop 生命周期是和应用同步的，它是常驻内存的。在这种情况下，如果定时器是重复执行的，就会出现 RunLoop 永远强引用着定时器，如果此时定时器还强引用着控制器，那么不论是否存在循环引用控制器都永远无法释放，即内存泄露。</p>
<blockquote>
<p>⚠️ 观察定时器是否正确释放方法：<br>与一般的类不同，NSTimer 被设计为类簇，它是一个对外的接口类，底层实际创建的并不是 NSTimer 实例，而是 __CFNSTimer 等其他底层类，即使我们新建一个类继承 NSTimer 并重写 dealloc 方法，也无法按预期执行。在运行时会报如下错误：<br><code>*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;*** initialization method -initWithFireDate:interval:target:selector:userInfo:repeats: cannot be sent to an abstract object of class MKTimer: Create a concrete instance!&#39;</code><br>在这种情况下，我们就需要另辟蹊径找到其他能够观察定时器释放的方法了。方法不止有一种，但我这里仅推荐一种方法：使用关联对象，给定时器添加一个关联对象，在关联对象的 dealloc 方法打印信息。这样在定时器释放的时候，我们的关联对象也会被释放，调用它的 dealloc 方法从而可以看到释放的时机。</p>
<p>CADisplayLink 虽然子类化之后运行时创建不会报错，但是调用 <code>+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel</code> 实际返回的实例对象也不是你自定义子类的实例，所以你的 dealloc 方法也不会被调用。依旧需要使用关联对象的方法来观察释放时间。</p>
</blockquote>
<h2 id="控制器无法释放的本质"><a href="#控制器无法释放的本质" class="headerlink" title="控制器无法释放的本质"></a>控制器无法释放的本质</h2><p>以下案例是一个新创建的 iOS 项目，仅对 ViewController 嵌入了一个导航控制器，正是为了演示 ViewController 从导航控制器栈中移除后能不能正常释放。这个案例对于有经验的 iOS 开发者来说应该不需要多说了吧。</p>
<img src="/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Snip20250515_1.png" class="">

<p>然后 ViewController 中的代码如下：</p>
<p>代码1：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，ViewController 对 NSTimer 存在一个强引用，同时 NSTimer 对 target 参数也存在着一个强引用。不过这个强引用隐藏的很深，没有一点的技术深度还真无法验证这个强引用在哪。。。我也在考虑要不要研究并发布出来，不过暂时还是算了，你记住 NSTimer 底层的确强引用着 target 就好了（其实可以通过 Xcode 的内存图看到）。。。但是造成 ViewController 无法释放的真正原因并不是它和定时器循环引用了。<strong>循环引用并不是一定会造成内存泄露。</strong></p>
<p>很多人可能对刚刚那句话不完全相信，那这样吧，我们看代码2，和代码3，看它们能不能解决循环引用的内存泄露？</p>
<p>代码2：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">MKTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:weakself selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码2这种情况并不能改变 NSTimer 内部对 target 的指针的强弱性质，NSTimer 内部对 target 的引用默认就是强的，__weak 根本无法修改 NSTimer 内部的代码实现。__weak 只有在搭配 Block 的时候，才能改变 Block 捕获外部变量时的强弱性质。所以这种写法也根本不可能解决 ViewController 无法释放的问题。</p>
<p>代码3：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">MKTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>如果按照循环引用一定产生内存泄露无法释放的说法的话，那么代码3就一定可以解决 ViewController 无法释放的问题了吧，ViewController 对 NSTimer 是弱引用，NSTimer 对 ViewController 是强引用，并没有产生循环引用啊，但是为什么 ViewController 还是无法释放呢？再看以下代码4：</p>
<p>代码4：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">MKTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码 4 中，ViewController 明明强引用着 NSTimer，而 NSTimer 的 target 也是强引用的。这不是循环引用了吗？怎么这个时候没有导致内存泄露，ViewController 退出之后也能正常释放呢？</p>
<p>其实根本原因是，NSTimer 和 CADisplayLink 这两种定时器都需要添加到 RunLoop 中运行，而且大多数情况下，这些定时器都被添加到了主线程的 RunLoop 中运行，而主线程的 RunLoop 在程序运行过程中一直存在，如果你看过我之前的 RunLoop 文章就会知道，RunLoop 有多种模式，每种模式都有一个定时器数组强引用着定时器，而这些定时器又强引用着控制器。在这种情况下，不论你定时器和控制器循环不循环引用都会导致 ViewController 无法释放。因为始终存在 RunLoop -&gt; 定时器 -&gt; 控制器。</p>
<p>而为什么代码 4 即使循环引用了，却还是能正常释放 ViewController 和 NSTimer 呢？关键在于代码 4 中的定时器不是永远重复的，它只执行一次。这样在定时器执行一次它的方法之后，RunLoop 就会将这个定时器从数组中移除，此时定时器依旧被 ViewController 强引用着，所以引用计数并不会归 0，就不会被释放。但是 RunLoop 移除定时器的时候，定时器必然也会对它强引用着的 ViewController 对象进行一次 release 调用。这个时候，ViewController 释放不释放同样取决于 ViewController 的引用计数是否为 0，如果退出了当前页面，ViewController 没有导航控制器等其他对象强引用着，引用计数归 0 的话，就会被释放内存，ViewController 在释放时也必然对它强引用着的 NSTimer 调用一次 release 操作，这样 NSTimer 也能顺利释放了。如果没有退出当前页面，也没有任何问题，定时器执行完，RunLoop 移除定时器时，定时器也会对它强引用的 ViewController 进行一个 release 操作，这样定时器对 ViewController 的强引用进行的引用计数加 1 操作也减回去了，退出 ViewController 页面的时候，引用着 ViewController 的对象正常内存管理就会导致 ViewController 引用计数减为 0 从而释放 ViewController。</p>
<p>所谓的强引用，弱引用本质并不会对引用计数产生变化，而是强引用的指针，在对它进行赋值的时候，会让该对象的引用计数加 1，而弱引用的指针就不会让指向的对象引用计数加 1。额就这样吧，也不知道有没有说清楚。。。</p>
<p>回到 ViewController 能否正常释放的问题来，在使用 NSTimer、CADisplayLink 这种需要添加到 RunLoop 的定时器时，对于不重复的定时器，还不不太需要操心内存管理问题的。但是对于需要重复的定时器而言，就需要特别注意内存管理问题了，不仅仅是 ViewController 的内存管理，还有定时器的内存管理，首先要保证 ViewController 能正常退出释放，其次 ViewController 在 dealloc 的时候要将定时器 invalidate，否则即使 ViewController 释放了定时器也无法释放。以下是一些解决方法：</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用-weak-和-block-API-解决"><a href="#使用-weak-和-block-API-解决" class="headerlink" title="使用 __weak 和 block API 解决"></a>使用 __weak 和 block API 解决</h3><p>直接看代码吧。。。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        [weakself timerFired:timer];</span><br><span class="line">    &#125;];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用带有 block 的定时器 API 的时候，配合 __weak 的使用，这样 NSTimer 就对 ViewController 不会产生强引用。ViewController 页面退出的时候就正常释放内存了，但是这个时候定时器还在 RunLoop 中，控制器都不存在了，定时器也没有必要继续存在了，就需要在 ViewController 的 dealloc 方法中对定时器调用 invalidate 方法，这个方法会让定时器从 RunLoop 中移除从而让定时器也能接着释放内存。</p>
<h3 id="使用中间层对象解决"><a href="#使用中间层对象解决" class="headerlink" title="使用中间层对象解决"></a>使用中间层对象解决</h3><p>中间层这种思想在软件开发领域好像是一个解决问题的规律，不知道是谁说的，但是的确蛮有道理的。通过使用中间层对象，让定时器强引用中间层对象，中间层弱引用控制器，同时中间层对象将定时器需要调用的方法转发给它弱引用的控制器，这样也能完美解决控制器的释放问题，和定时器的释放问题。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Proxy</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Proxy</span></span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须重写，否则可能会有逻辑错误，甚至导致崩溃的可能。</span></span><br><span class="line"><span class="comment">// 假设有这么一段代码 `[proxy respondsToSelector:@selector(someMethod)]`，本意是想判断 proxy 的 target 能否响应方法的，但是实际运行时只会查看 proxy 能否响应方法。</span></span><br><span class="line"><span class="comment">// 本意是对 Proxy 对象调用的所有方法，都应该交给他的 target 处理。对于一般的方法，就比如 timerFired: ，proxy 对象并没有实现，那么就通过消息转发给到了 target。</span></span><br><span class="line"><span class="comment">// 但是像 respondsToSelector: 这样的元方法因为 Proxy 继承自 NSObject 就并不会被转发给 target 了从而导致了逻辑上的错误，需要在 Proxy 中重写 respondsToSelector: 方法。</span></span><br><span class="line"><span class="comment">// 除了 respondsToSelector: 方法之外，还有其他元方法如 isKindOfClass:、description 等等方法都可能需要做类似得处理。</span></span><br><span class="line"><span class="comment">// 所以推荐继承自 NSProxy 而不是 NSObject，这里使用 NSObject 仅为了演示解决控制器无法释放的问题并不是只能由 NSProxy 的子类来解决。</span></span><br><span class="line">- (<span class="type">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target respondsToSelector:aSelector] || [<span class="variable language_">super</span> respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可能还需覆盖其他方法（如 description、isKindOfClass: 等）</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	Proxy *proxy = [Proxy alloc];</span><br><span class="line">	proxy.target = <span class="keyword">self</span>;</span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:proxy selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">	[<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>除了使用 NSObject 子类的方式，在 iOS 中，这种中间层对象的解决方式还有一个更加推荐的对象，即 NSProxy。对于简单的场景，使用 NSObject 没有什么问题，但是对于更加复杂的场景，以及从性能和安全角度考虑使用 NSProxy 子类会比使用 NSObject 子类更加合适。这种方式不仅仅是对 NSTimer 有效，同样也能解决 CADisplayLink 带来的问题。</p>
<p>在解决 CADisplayLink 和 NSTimer 重复定时器导致的内存问题时，推荐使用 NSProxy 子类而非 NSObject 子类，主要原因如下：</p>
<ol>
<li><p>​​高效的消息转发机制​</p>
<ul>
<li><strong>NSProxy 的纯粹性</strong>​​：NSProxy 是专门为消息转发设计的抽象基类，它本身不实现任何方法（除极少数必要方法外）。所有发送给 NSProxy 对象的消息都会直接进入消息转发流程（forwardInvocation: 和 methodSignatureForSelector:），无需像 NSObject 子类那样先逐级查找方法实现。</li>
<li><strong>NSObject 的冗余步骤</strong>​​：NSObject 子类在消息转发前会经历动态方法解析（resolveInstanceMethod:）和快速转发（forwardingTargetForSelector:）等步骤，导致额外的性能开销。对于高频触发的定时器（如 CADisplayLink 每秒 60 次回调），NSProxy 的短路径转发更高效。</li>
</ul>
</li>
<li><p>​​避免方法冲突与副作用​</p>
<ul>
<li><strong>无方法实现干扰​​</strong>：NSProxy 默认没有实现常见方法（如 respondsToSelector: 或 description），所有消息均被转发到目标对象。而 NSObject 子类可能因自身方法（如 class、isEqual:）导致意外行为，需额外处理这些方法的转发逻辑。</li>
<li><strong>干净的代理角色</strong>​​：NSProxy 作为纯粹的代理，不会因继承 NSObject 的复杂方法体系而产生歧义，确保所有调用都正确传递给目标对象。</li>
</ul>
</li>
<li><p>设计意图的契合性</p>
<ul>
<li><strong>代理模式的天然选择​​</strong>：NSProxy 的设计初衷即为代理对象提供轻量级、专注的转发能力，符合通过中间对象打破循环引用的场景需求。而 NSObject 作为通用基类，承担了更多与对象生命周期、键值观察等无关职责，逻辑上不够契合。</li>
</ul>
</li>
<li><p>减少代码复杂性​</p>
<ul>
<li><strong>简化实现​​</strong>：使用 NSProxy 子类通常只需实现 methodSignatureForSelector: 和 forwardInvocation: 即可完成消息转发。而 NSObject 子类可能需要覆盖更多方法（如 respondsToSelector:）以确保行为正确，增加代码复杂度。</li>
</ul>
</li>
</ol>
<p>使用 NSProxy 子类解决内存问题的示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakProxy</span></span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-GCD-的定时器"><a href="#使用-GCD-的定时器" class="headerlink" title="使用 GCD 的定时器"></a>使用 GCD 的定时器</h3><p>除了以上两种方式，我们知道问题就在于这两种定时器依赖 RunLoop 才能运行。如果使用不依赖 RunLoop 的 GCD 定时器，也可以解决控制器无法释放的问题。而且 RunLoop 本身如果任务过于繁重的话，就可能导致基于 RunLoop 的定时器执行间隔不准确，所以在一些特定的情况下，可以使用 GCD 定时器替代 NSTimer 定时器。但是也并不是说使用 GCD 的定时器就没有内存管理的问题了。该注意的地方还是要注意。</p>
<h4 id="直接使用-GCD-定时器"><a href="#直接使用-GCD-定时器" class="headerlink" title="直接使用 GCD 定时器"></a>直接使用 GCD 定时器</h4><p>完全自己创建 GCD 的定时器需要不少代码，好在 Xcode 的代码块功能已经自带了 GCD 定时器的代码块。输入 <code>dispatch_source</code> 应该会有提示，回车就可以，不过系统自带的这个代码块几个参数不好填。可以复制修改一下为自己的代码块，以下是我修改后的 GCD 定时器代码块。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, &lt;#dispatchQueue#&gt;);</span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, &lt;#afterInSeconds#&gt; * <span class="built_in">NSEC_PER_SEC</span>), &lt;#intervalInSeconds#&gt; * <span class="built_in">NSEC_PER_SEC</span>, &lt;#leewayInSeconds#&gt; * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    &lt;<span class="meta">#code to be executed when timer fires#&gt;</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_activate(timer);</span><br></pre></td></tr></table></figure>

<p>以下是填完参数之后的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// dispatchQueue 这个队列，使用过 GCD 的都不陌生了，主队列，全局并发队列选一个就好</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="comment">// 第一个参数是上面创建的 timer，</span></span><br><span class="line">    <span class="comment">// 第二个参数是定时器第一次调用的时间，这里传的时当前时间的多少秒之后。</span></span><br><span class="line">    <span class="comment">// 第三个参数是调用的时间间隔，单位也改用秒了。</span></span><br><span class="line">    <span class="comment">// 第四个参数是误差，单位也改成秒了，可以填 0，若无需极端精度，建议设置合理误差（如 0.1 * NSEC_PER_SEC），以降低系统负载。</span></span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>), <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,%@&quot;</span>, weakself, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_activate(timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>启动 APP，进入 ViewController 所在页面只看到了打印 <code>-[ViewController viewDidLoad]</code>，这是因为 timer 作为一个局部变量如果没有强引用持有它，ARC 可能在对象超出作用域后释放它，导致定时器提取释放。同时在不需要定时器的时候需要手动调用 <code>dispatch_source_cancel()</code> 取消定时器。所以正确的用法应该如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>), <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,%@&quot;</span>, weakself, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_activate(timer);</span><br><span class="line">    <span class="keyword">self</span>.timer = timer;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>进入页面 2 秒后启动定时器，每间隔 1 秒执行定时器方法，退出页面后控制器能正常释放，定时器也能正常销毁。</p>
<h4 id="封装-GCD-定时器"><a href="#封装-GCD-定时器" class="headerlink" title="封装 GCD 定时器"></a>封装 GCD 定时器</h4><p>直接使用 GCD 可能看起来代码较多，可以自己封装一个小型的定时器工具类，使用 GCD 实现。方便以后使用。以下是源码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MKTimer</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">nonnull</span> <span class="type">void</span> (^)(<span class="type">void</span>))task startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTarget:(<span class="type">id</span>)target selector:(SEL)selector startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async;</span><br><span class="line">+ (<span class="type">void</span>)cancelTimer:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *_GCDTimers;</span><br><span class="line">dispatch_semaphore_t _semaphore;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MKTimer</span></span></span><br><span class="line">+ (<span class="type">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="built_in">MKTimer</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            _GCDTimers = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">            _semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="type">void</span> (^)(<span class="type">void</span>))task startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async &#123;</span><br><span class="line">    <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;task 不能为 nil&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (after &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;after 无法小于 0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (interval &lt;= <span class="number">0</span> &amp;&amp; repeats == <span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;interval 需要大于 0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = async ? dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>) : dispatch_get_main_queue();</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    dispatch_source_set_timer(timer,</span><br><span class="line">                              dispatch_time(DISPATCH_TIME_NOW, after * <span class="built_in">NSEC_PER_SEC</span>),</span><br><span class="line">                              interval * <span class="built_in">NSEC_PER_SEC</span>,</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%zd&quot;</span>, _GCDTimers.count];</span><br><span class="line">    _GCDTimers[key] = timer;</span><br><span class="line">    dispatch_semaphore_signal(_semaphore);</span><br><span class="line">    dispatch_block_t block = ^&#123;</span><br><span class="line">        task();</span><br><span class="line">        <span class="keyword">if</span> (repeats == <span class="literal">NO</span>) &#123;</span><br><span class="line">            [weakself cancelTimer:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dispatch_source_set_event_handler(timer, block);</span><br><span class="line">    dispatch_activate(timer);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTarget:(<span class="type">id</span>)target selector:(SEL)sel startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target || !sel) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(target) <span class="keyword">weak</span> = target;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">weak</span> respondsToSelector:sel]) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">            [<span class="keyword">weak</span> performSelector:sel];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> execTask:block startAfter:after interval:interval repeats:repeats async:async];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)cancelTimer:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    dispatch_source_t timer = _GCDTimers[key];</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">        [_GCDTimers removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(_semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 ViewController 中的使用方式如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">// 使用 Block 的 API</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">self</span>.key = [<span class="built_in">MKTimer</span> execTask:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@&quot;</span>, weakself, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125; startAfter:<span class="number">2</span> interval:<span class="number">1</span> repeats:<span class="literal">YES</span> async:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;   <span class="comment">// 使用 target selector 的 API</span></span><br><span class="line">        <span class="keyword">self</span>.key = [<span class="built_in">MKTimer</span> execTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFired) startAfter:<span class="number">2</span> interval:<span class="number">1</span> repeats:<span class="literal">YES</span> async:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@&quot;</span>, <span class="keyword">self</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="built_in">MKTimer</span> cancelTimer:<span class="keyword">self</span>.key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<hr>
<h1 id="iOS-应用内存布局"><a href="#iOS-应用内存布局" class="headerlink" title="iOS 应用内存布局"></a>iOS 应用内存布局</h1><p>如下图：</p>
<img src="/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Snip20250519_2.png" class="">

<p>可以在 iOS 项目中打印不同类型的变量进行验证。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> d;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj1 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSObject</span> *obj2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;\n&amp;a=%p\n&amp;b=%p\n&amp;c=%p\n&amp;d=%p\n&amp;e=%p\n&amp;f=%p\nstr=%p\nobj1=%p\nobj2=%p\n&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,str,obj1,obj2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>实际打印的结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&amp;a=<span class="number">0x100481250</span></span><br><span class="line">&amp;b=<span class="number">0x10048125c</span></span><br><span class="line">&amp;c=<span class="number">0x100481254</span></span><br><span class="line">&amp;d=<span class="number">0x100481258</span></span><br><span class="line">&amp;e=<span class="number">0x16f98713c</span></span><br><span class="line">&amp;f=<span class="number">0x16f987138</span></span><br><span class="line">str=<span class="number">0x10047c098</span></span><br><span class="line">obj1=<span class="number">0x281c98090</span></span><br><span class="line">obj2=<span class="number">0x281c980b0</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果来看，有些结果会让人有点意外。首先a，b，c，d，str 的地址都能够理解，不论是全局变量，静态变量，还是字符串常量都在一块应该都是在数据区。但是局部变量 e，f 的地址在栈上是应该大于对象 obj1，obj2 所在的堆区地址的。但是这里却出现了堆区地址大于栈区地址的现象很是奇怪。抛开这点不谈，通过两个同区域变量的地址对比，如 e 的地址大于 f 的地址，说明栈的生长方向随着使用在变小是没错的。obj1 的地址小于 obj2 的地址，说明堆的生长方向随着使用在变大也是没错的。</p>
<p>最奇怪的是为什么栈的地址比堆的地址小了？</p>
<p>这里的原因是，iOS 中的一种叫 ASLR 的安全技术导致。</p>
<h2 id="什么是-ASLR-？"><a href="#什么是-ASLR-？" class="headerlink" title="什么是 ASLR ？"></a>什么是 ASLR ？</h2><p><strong>ASLR（Address Space Layout Randomization，地址空间布局随机化）</strong>​​ 是一种操作系统级别的安全技术，核心目的是 ​​<strong>让程序的内存布局变得不可预测​​</strong>，从而增加攻击者利用内存漏洞（如缓冲区溢出）的难度。它通过 ​​<strong>随机化程序内存区域的起始地址</strong>​​ 来实现这一点。</p>
<h2 id="ASLR-的作用原理"><a href="#ASLR-的作用原理" class="headerlink" title="ASLR 的作用原理"></a>ASLR 的作用原理</h2><ol>
<li>传统内存布局的问题<br>  在没有 ASLR 时，程序的代码段、数据段、堆、栈等内存区域的起始地址是固定的。例如：<ul>
<li>代码段总是从 0x100000000 开始。</li>
<li>栈总是从 0x7FFF00000000 开始。<br> 攻击者可以提前知道这些地址，从而精准构造攻击代码。</li>
</ul>
</li>
<li>ASLR 的解决方案<br> ASLR 在程序启动时，为每个内存区域分配一个 ​​随机的基址偏移量​​。例如：<ul>
<li>代码段可能从 0x12345000000 开始。</li>
<li>栈可能从 0x7F12F0000000 开始。<br> 每次运行程序时，这些地址都会变化，攻击者无法提前预测。</li>
</ul>
</li>
</ol>
<h2 id="静态变量的作用域"><a href="#静态变量的作用域" class="headerlink" title="静态变量的作用域"></a>静态变量的作用域</h2><p>先看以下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">    count = <span class="number">2000</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">    [Person sleep];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">    [[Person new] eat];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>然后是 Person 的头文件和实现文件代码：</p>
<p>Person.h</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> count = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)eat;</span><br><span class="line">+ (<span class="type">void</span>)sleep;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>Person.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)eat &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s, %p, %zd&quot;</span>, __func__, &amp;count, count);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)sleep &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s, %p, %zd&quot;</span>, __func__, &amp;count, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 ViewController 的 viewDidLoad 方法中，实际的打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">1000</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">2001</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] +[Person sleep], <span class="number">0x104715e38</span>, <span class="number">1001</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">2001</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] -[Person eat], <span class="number">0x104715e38</span>, <span class="number">1002</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">2001</span></span><br></pre></td></tr></table></figure>

<p>可以看到在 ViewController 中的确可以访问并修改全局静态变量 count。但是在 ViewController 内的修改并不会影响 Person 类中的 count。这是因为 static 全局变量在每个包含它的​​编译单元（实现文件）​​中生成独立副本。作用域仅限于​​当前编译单元​​（文件），对其他文件不可见。</p>
<p>而在头文件声明 static 变量的用法看似“全局”，实际是每个文件独立持有。虽然合法但不推荐使用（容易导致代码冗余和误解）。推荐在实现文件中定义 static 变量，头文件中声明为 extern（若需跨文件访问）。</p>
<hr>
<h1 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h1><h2 id="什么是-Tagged-Pointer"><a href="#什么是-Tagged-Pointer" class="headerlink" title="什么是 Tagged Pointer"></a>什么是 Tagged Pointer</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul>
<li><strong>指针与标记结合</strong>​​：Tagged Pointer 在存储内存地址的同时，利用未使用的位存储额外信息（如类型标签或小型数据）。</li>
<li><strong>目的​​</strong>：减少小对象的内存分配开销，加速类型检查或数据访问。</li>
</ul>
<h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h3><ul>
<li><strong>位利用</strong>​​：在 64 位系统中，指针通常占用 8 字节（即 64 位），但实际地址可能未使用全部高位。这些空闲位用于存储标记。</li>
<li><strong>标记位识别</strong>​​：通常通过特定位（如最低有效位）标识是否为 Tagged Pointer。例如，最低位为 1 表示标记指针，为 0 则为普通指针。</li>
</ul>
<h3 id="3-常见应用场景"><a href="#3-常见应用场景" class="headerlink" title="3.常见应用场景"></a>3.常见应用场景</h3><ul>
<li><strong>小对象优化</strong>​​：如 Objective-C 的 NSNumber 或 NSString，直接将小数值存储在指针中，避免堆内存分配。</li>
<li>​​<strong>类型快速判断</strong>​​：通过标签位区分数据类型，减少动态类型检查的开销。</li>
<li><strong>垃圾回收</strong>​​：辅助垃圾回收器识别指针类型，提升效率。</li>
</ul>
<h3 id="4-计数细节"><a href="#4-计数细节" class="headerlink" title="4.计数细节"></a>4.计数细节</h3><ul>
<li><strong>位分配策略</strong>​​：不同系统&#x2F;语言实现不同。例如，某些系统使用高位存储标签，某些使用低位。</li>
<li><strong>数据存储​​</strong>：若标签指示数据直接存储，剩余位存储实际值（如整数、浮点数）。</li>
<li><strong>内存对齐</strong>​​：确保普通指针地址对齐，使空闲位可预测（如地址总是 4&#x2F;8 字节对齐）。</li>
</ul>
<h3 id="5-优点"><a href="#5-优点" class="headerlink" title="5.优点"></a>5.优点</h3><ul>
<li><strong>内存节省</strong>​​：避免小对象的堆分配，减少内存碎片。</li>
<li><strong>性能提升</strong>​​：减少间接访问（如解引用指针），加速类型检查和数据操作。</li>
<li><strong>​​缓存友好​​</strong>：数据直接存储在指针中，提高缓存局部性。</li>
</ul>
<h3 id="6-限制与挑战​"><a href="#6-限制与挑战​" class="headerlink" title="6.限制与挑战​"></a>6.限制与挑战​</h3><ul>
<li>​​<strong>存储限制​​</strong>：可用位数限制直接存储数据的大小（如 64 位中可能仅存 60 位有效数据）。</li>
<li><strong>兼容性​​</strong>：需确保标记位不与实际地址冲突，依赖运行时或操作系统的内存管理。</li>
<li><strong>调试复杂性</strong>​​：指针值包含元数据，需工具解析以方便调试。</li>
</ul>
<h3 id="7-示例与类比​"><a href="#7-示例与类比​" class="headerlink" title="7.示例与类比​"></a>7.示例与类比​</h3><ul>
<li><strong>Objective-C&#x2F;Swift</strong>​​：使用 Tagged Pointer 优化 NSNumber、NSDate 等对象。</li>
<li><strong>NaN Boxing</strong>​​：类似技术，利用浮点数的 NaN 空间存储类型信息（如JavaScript引擎）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Tagged Pointer 是一种高效利用指针空间的技术，通过在地址中嵌入元数据或数据，优化内存和性能。其实现需精细设计位布局，并确保与系统内存管理的兼容性，广泛应用于动态语言运行时和高效内存管理的场景。</p>
<h2 id="iOS-中的-Tagged-Pointer"><a href="#iOS-中的-Tagged-Pointer" class="headerlink" title="iOS 中的 Tagged Pointer"></a>iOS 中的 Tagged Pointer</h2><p>iOS 的 Tagged Pointer 是在 iOS 7（2013年）中引入的​​，与 iPhone 5s 的 64 位 A7 芯片的发布同步。以下是详细背景和关键点：</p>
<h3 id="1-引入背景"><a href="#1-引入背景" class="headerlink" title="1.引入背景"></a>1.引入背景</h3><ul>
<li>64 位架构的普及​​：<br>  iPhone 5s（2013年）首次搭载 64 位 A7 芯片，iOS 7 开始全面支持 64 位应用。64 位指针的地址空间远超出实际物理内存需求，​​高位空闲的指针位​​为 Tagged Pointer 提供了存储额外数据的空间。</li>
<li>性能优化需求​​：<br>  Apple 希望通过减少小对象（如 NSNumber、NSDate、短 NSString）的堆内存分配和访问开销，提升运行效率。</li>
</ul>
<h3 id="2-技术实现的核心"><a href="#2-技术实现的核心" class="headerlink" title="2.技术实现的核心"></a>2.技术实现的核心</h3><ul>
<li>指针位复用​​：<br>  在 64 位系统中，指针占用 8 字节（64 位），但实际地址通常仅使用低 48 位。​​高位空闲的 16 位​​被用于存储：<ul>
<li>标记位（Tag）​​：标识指针是否为 Tagged Pointer，在 arm64 架构中最高位 1 代表是 Tagged Pointer，非 arm64 架构中最低位 1 代表是 Tagged Pointer。可以在 libobjc.A.dylib 源码中看到。</li>
<li>​​直接数据​​：将小对象的值（如整数、短字符串）直接编码到指针中，避免分配堆内存。</li>
</ul>
</li>
<li>示例：<br>  NSNumber 存储一个小于 2^60 的整数时，直接将数值编码到指针的高 60 位，最低 4 位作为类型标记。</li>
</ul>
<h3 id="3-主要优势"><a href="#3-主要优势" class="headerlink" title="3.主要优势"></a>3.主要优势</h3><ul>
<li>内存效率：<br>  避免频繁分配和释放小对象的内存碎片，减少内存占用。</li>
<li>性能提升​​：<br>  省去堆内存访问（无需解引用指针），提升数据存取速度。</li>
<li>类型判断加速​​：<br>  通过指针的标记位快速识别对象类型（如 NSNumber 或 NSString），减少动态类型检查开销。</li>
</ul>
<h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4.应用场景"></a>4.应用场景</h3><ul>
<li>基础类优化​​：<br>  NSNumber、NSString（短字符串）、NSDate、NSIndexPath 等小对象默认使用 Tagged Pointer。</li>
<li>条件限制​​：<br>  对象的值需满足直接编码到指针中的大小限制（例如 NSNumber 的数值范围受剩余位数约束）。</li>
</ul>
<h3 id="5-开发者注意事项​"><a href="#5-开发者注意事项​" class="headerlink" title="5. 开发者注意事项​"></a>5. 开发者注意事项​</h3><ul>
<li>透明实现​​：<br>  Tagged Pointer 对开发者完全透明，无需修改代码即可享受优化。</li>
<li>调试工具识别​​：<br>  在 Xcode 中，Tagged Pointer 的地址通常显示为特殊格式（如 0xb000000000000013，末尾的 3 表示 NSNumber 类型）。</li>
<li>兼容性​​：<br>  仅限 64 位设备，32 位架构因指针位不足无法使用。</li>
</ul>
<h3 id="6-扩展知识"><a href="#6-扩展知识" class="headerlink" title="6. 扩展知识"></a>6. 扩展知识</h3><ul>
<li>与 Compact Strings 的关系​​：<br>  iOS 15 引入的字符串压缩技术（Compact Strings）进一步优化 NSString，但 Tagged Pointer 是其底层基础之一。</li>
<li>安全影响​​：<br>  Tagged Pointer 的标记位设计需避免与有效地址冲突，否则可能引发内存错误（如早期 iOS 版本曾因混淆标记位导致漏洞）。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>iOS 7 通过引入 ​​Tagged Pointer​​，在 64 位设备上实现了小对象的高效存储，显著提升了内存和性能表现。这一技术至今仍是 iOS 运行时优化的核心机制之一。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>以下两段代码有什么区别？为什么会产生这种这种区别？</p>
<p>代码1：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;helloWorld,areyouOK?&quot;</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码2：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abc&quot;</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码 1 会导致崩溃而代码 2 不会崩溃的原因在于字符串的内存管理方式以及多线程环境下的竞争条件：</p>
<ol>
<li>字符串类型差异<ul>
<li>代码 1 的字符串 @”helloWorld,areyouOK?” 较长，会创建普通的 NSString 对象（堆内存分配），涉及引用计数管理。</li>
<li>代码 2 的字符串 @”abc” 较短，会被优化为 NSTaggedPointerString（标签指针），其值直接存储在指针中，无需引用计数。</li>
</ul>
</li>
<li>多线程竞争条件​​：<ul>
<li>对于普通  NSString 对象（代码1）：每次赋值会触发 retain 新值和 release 旧值的操作。多线程环境下，多个线程同时执行这些非原子操作可能导致：<ul>
<li>旧值被多次 release（过度释放）。</li>
<li>对象引用计数混乱，引发野指针访问（EXC_BAD_ACCESS）。</li>
</ul>
</li>
<li>对于 NSTaggedPointerString（代码2）：赋值仅是指针的原子写入，不涉及引用计数操作，因此无竞争风险。</li>
</ul>
</li>
<li>属性原子性​​：<ul>
<li>name 属性声明为 nonatomic，缺乏锁保护，允许多线程直接访问，加剧了普通对象的内存管理问题。</li>
</ul>
</li>
</ol>
<p>代码 1 因涉及非原子的引用计数操作导致多线程崩溃，而代码 2 的标签指针赋值是原子且无内存管理的，因此安全。解决方法包括使用 atomic 属性、串行队列或同步机制（如 @synchronized）保护属性访问。</p>
<hr>
<h1 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h1><h2 id="什么是-MRC"><a href="#什么是-MRC" class="headerlink" title="什么是 MRC"></a>什么是 MRC</h2><p>在编写 C 语言程序时，我们需要手动对 malloc 创建出来的数据进行内存管理，在合适的时机需要手动 free 释放堆区内存。同样在 iOS 开发中，对象的创建就是在堆区分配的内存，那么当然也需要在合适的时机对对象进行内存的释放。MRC（Manual Reference Counting，手动引用计数）是 iOS 早期手动管理对象内存的核心机制，开发者需要<strong>显式控制对象的生命周期</strong>，通过以下规则和方法实现：</p>
<h3 id="1-引用计数的核心原则"><a href="#1-引用计数的核心原则" class="headerlink" title="1. 引用计数的核心原则"></a>1. 引用计数的核心原则</h3><ul>
<li>每个对象都有一个引用计数（retainCount），初始值为 1（通过 alloc、new、copy 等方法创建的对象）。</li>
<li>当引用计数 retainCount &#x3D; 0 时，对象会被系统立即释放内存（调用 dealloc 方法）。</li>
<li>开发者需要手动调用 retain 增加计数和 release 减少技术来管理所有权。</li>
</ul>
<h3 id="2-关键方法"><a href="#2-关键方法" class="headerlink" title="2. 关键方法"></a>2. 关键方法</h3><ul>
<li><strong>retain</strong><ul>
<li>作用：增加对象的引用计数 retainCount +1。</li>
<li>场景：当需要持有（拥有）一个对象时（如将对象赋值给实例变量或添加到集合中）。</li>
</ul>
</li>
<li><strong>release</strong><ul>
<li>作用：减少对象的引用计数 retainCount -1。</li>
<li>场景：当不再需要对象时调用。若计数减到 0，对象内存被释放。</li>
</ul>
</li>
<li><strong>autorelease</strong><ul>
<li>作用：将对象加入<strong>自动释放池（Autorelease Pool）</strong>，延迟释放（通常在当前 RunLoop 进入休眠前统一调用 release）。</li>
<li>场景：方法返回对象时，避免立即释放（如工厂方法）。</li>
</ul>
</li>
</ul>
<h3 id="3-所有权规则"><a href="#3-所有权规则" class="headerlink" title="3. 所有权规则"></a>3. 所有权规则</h3><ul>
<li>谁创建，谁释放：通过 alloc、new、copy、mutableCopy 创建的对象，需由创建者调用 release。</li>
<li>谁持有，谁释放：通过 retain 或强引用的对象，需调用 release 放弃所有权。</li>
<li>方法命名约定：<ul>
<li>方法名以 alloc、new、copy 开头，返回的对象由调用者负责释放。</li>
<li>其他方法返回的对象默认是 autorelease 的（如 [NSString stringWithFormat:]）。</li>
</ul>
</li>
</ul>
<h3 id="4-常见错误"><a href="#4-常见错误" class="headerlink" title="4. 常见错误"></a>4. 常见错误</h3><ul>
<li>内存泄露：未调用 release，导致对象没有释放，之后也无法再次使用对象。</li>
<li>悬垂指针：过早调用 release 后继续访问对象（导致 BAD_ACCESS 崩溃）。</li>
<li>过度释放：对一个对象多次调用 release（直接崩溃）。</li>
</ul>
<h3 id="5-代码示范"><a href="#5-代码示范" class="headerlink" title="5. 代码示范"></a>5. 代码示范</h3><h4 id="代码1：手动释放不再需要使用的对象"><a href="#代码1：手动释放不再需要使用的对象" class="headerlink" title="代码1：手动释放不再需要使用的对象"></a>代码1：手动释放不再需要使用的对象</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s begin&quot;</span>, __func__);</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    Person *person = [Person new];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    省略中间可能的其他代码。。。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    [person release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s end&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 MRC 环境下，ViewDidLoad 方法中创建了一个 Person 对象，如果不手动调用 release 方法，那么 ViewDidLoad 执行完后这个对象就再也无法访问到了，这就是内存泄露。如果不注意任这样的代码泄露内存，很快就会发现应用内存占用过大而被系统杀死。所以非常有必要将不再需要使用的对象内存正确释放掉，方法就是手动调用 release 方法使其引用计数变为 0。或者再对象创建的时候调用 autorelease 方法加入自动释放池，那么在合适的时机，自动释放池清空的时候，会对池内的对象发送一个 release 消息。</p>
<h4 id="代码2：对象持有其他对象的内存管理"><a href="#代码2：对象持有其他对象的内存管理" class="headerlink" title="代码2：对象持有其他对象的内存管理"></a>代码2：对象持有其他对象的内存管理</h4><p>当 Person 对象持有 Dog 对象的时候，setter 方法改如何实现？<br>在使用 @property 声明属性时候，编译器自动帮我们生成了 setter、getter 和成员变量。那么编译器生成的 setter 方法内是如何管理新旧两个对象内存的？<br>在 MRC 时代，@property 声明属性并不会自动生成 setter、getter 和成员变量，还需要配合 @synthesize 才能生成。但是目前 ARC 已经不再需要使用 @synthesize 了。除此之外，还有两种情况需要使用 @synthesize，一是在协议和分类中的属性，需要使用 @synthesize 显式生成。二是有自定义成员变量名的需求时，因为默认生成的成员变量名是属性名前面加下划线。</p>
<ol>
<li><p>不管37二十一，直接将参数新对象赋值给成员变量？？？</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDog:(Dog *)dog &#123;</span><br><span class="line">	_dog = dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样肯定会出问题的，旧对象没有调用 release，那必然会造成内存泄露。</li>
<li>新对象没有被 retain，那么在这个对象在外部 release 的时候，Person 的 dog 也同步被释放了。应该做到只要 Person 还在内存中，它所拥有的对象就都应该还在内存中。Person 释放的时候，也需要释放它拥有的对象，也就是在 Person 的 dealloc 方法中调用它持有对象的 release 方法。</li>
</ul>
<p> 所以 setter 方法至少需要做的两个操作，对旧的对象调用一次 release，对新的对象调用一次 retain。</p>
</li>
<li><p>经过上面的讨论，那么此时的 setter 方法应该是</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDog:(Dog *)dog &#123;</span><br><span class="line">	[_dog release];</span><br><span class="line">	_dog = [dog <span class="keyword">retain</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这样子就足够完美了吗？还是不行。如果外部多次调用 setDog: 方法，且参数时候同一个对象，那么这个对象有可能被释放了，然后还在继续使用。需要做的是对参数和成员变量进行判断</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDog:(Dog *)dog &#123;</span><br><span class="line">	<span class="keyword">if</span> (_dog != dog) &#123;</span><br><span class="line">		[_dog release];</span><br><span class="line">		_dog = [dog <span class="keyword">retain</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>MRC 要求开发者像“管家”一样精准控制对象生命周期，​​每个 retain 必须对应一个 release​​。虽然灵活，但极易出错。2011 年推出的 ​​ARC（自动引用计数）​​ 通过编译器自动插入 retain&#x2F;release 代码，彻底解放了开发者，成为现代 Objective-C&#x2F;Swift 开发的主流选择。但在维护旧项目或特定场景下，仍需理解 MRC 的原理。ARC 出现之后虽然说不再需要程序员手动管理内存，但是仍然需要注意循环引用可能引起的内存泄露问题。</p>
<hr>
<h1 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h1><p>copy 就是为了复制一个新的对象出来，新对象的属性和值都和原来对象一模一样，但又是两个独立的对象，修改其中一个对象的属性不会影响到另一个对象。在 iOS 中，实现了 NSCopying 协议的类就拥有了 copy 的能力，它返回一个不可变的副本，如 NSURL、NSCachedURLResponse、NSDate 等等。还有一个 NSMutableCopying 协议，实现了这个协议的类就拥有了 mutableCopy 的能力，它返回一个可变类型的副本，如 NSString、NSArray、NSDictionary、NSData 等等。</p>
<p>调用了 copy、mutableCopy 方法返回的对象，同样需要内存管理。这个在刚刚的 MRC 中已经提到过了。在 MRC 环境下需要手动释放，在 ARC 环境下由编译器插入合适的 release 方法。</p>
<ul>
<li>对于不可变的对象，如 NSArray，NSDictionary，NSData <ul>
<li>如果调用 copy 方法返回的是对象本身，引用计数加 1，这种称之为浅拷贝。</li>
<li>如果调用 mutableCopy 方法返回的是新的可变类型的对象，如 NSMutableArray、NSMutableDictionary、NSMutableData，这种称之为深拷贝。</li>
</ul>
</li>
<li>对与可变类型的对象，如 NSMutableArray、NSMutableDictionary、NSMutableData<ul>
<li>如果调用 copy 方法返回的是新的不可变类型的对象，如 NSArray、NSDictionary、NSData。这种也是深拷贝。</li>
<li>如果调用 mutableCopy 方法返回同样类型的新对象。这种也是深拷贝。</li>
</ul>
</li>
</ul>
<p>总结，浅拷贝并没有创建新的对象，而深拷贝创建了新的对象。不可变对象的不可变拷贝是浅拷贝，其余都是深拷贝。</p>
<h2 id="自定义对象的拷贝"><a href="#自定义对象的拷贝" class="headerlink" title="自定义对象的拷贝"></a>自定义对象的拷贝</h2><p>如果一个自己写的类，想要拥有 copy 能力，就需要采用 NSCopying 协议，实现 <code>- (id)copyWithZone:(nullable NSZone *)zone;</code> 方法：</p>
<p>如以下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="type">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Person *person = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    person.name = <span class="keyword">self</span>.name;</span><br><span class="line">    person.age = <span class="keyword">self</span>.age;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%p,%@,%d&quot;</span>,<span class="keyword">self</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *person = [Person new];</span><br><span class="line">    person.name = <span class="string">@&quot;Tom&quot;</span>;</span><br><span class="line">    person.age = <span class="number">18</span>;</span><br><span class="line">    </span><br><span class="line">    Person *person2 = [person <span class="keyword">copy</span>];</span><br><span class="line">    person2.name = <span class="string">@&quot;Jerry&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, person);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, person2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><p>以下代码会有什么问题？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">	Person *person = [Person new];</span><br><span class="line">	person.array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">	[person.array addObject:<span class="string">@&quot;hello&quot;</span>];</span><br><span class="line">	[person.array addObject:<span class="string">@&quot;world&quot;</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码存在一个关键问题：将 ​​NSMutableArray​​ 类型的属性声明为 ​​copy​​，这会导致不可预知的运行时崩溃。以下是具体分析：</p>
<ol>
<li>问题根源：copy 修饰符的副作用<ul>
<li>copy 修饰符的特性：当给属性赋值时，系统会自动对传入的对象调用 copy 方法，生成一个不可变的副本，即使参数对象的确是个可变的对象。</li>
<li>NSMutableArray 的 copy 行为：NSMutableArray 的 copy 方法返回的是 不可变的 NSArray，而非 NSMutableArray。因此，虽然属性声明为 NSMutableArray，但实际存储的是 NSArray。</li>
</ul>
</li>
<li>导致崩溃的原因<ul>
<li>尝试修改不可变数组：在 main 函数中，调用 addObject: 方法时，实际是向一个 NSArray 对象发送 addObject: 消息，而 NSArray 没有 addObject: 方法。这会引发如下运行时错误： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-[__NSArrayI addObject:]: unrecognized selector sent to instance</span><br></pre></td></tr></table></figure>
 程序会因此崩溃。</li>
</ul>
</li>
<li>解决方案<ul>
<li>使用 strong 修饰符：若属性需要保存可变性，应使用 strong（ARC）或 retain（MRC）修饰符： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;</span><br></pre></td></tr></table></figure></li>
<li>若改用 NSArray：如果确实需要 copy 语义，应将属性类型改为 NSArray，并避免修改数组： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *array;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>验证问题的示例 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">person.array = mutableArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际类型是 NSArray，而非 NSMutableArray</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [person.array <span class="keyword">class</span>]); <span class="comment">// 输出 __NSArrayI（不可变数组）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>声明 NSMutableArray 属性时使用 copy 修饰符，会导致实际存储的是不可变数组，后续修改操作会崩溃。应根据需求选择正确的修饰符（strong 或 retain）或调整属性类型（改为 NSArray）。</p>
<hr>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>在 iOS 中，对象的引用计数存储位置从历史的发展角度来看，可以分为以下两个阶段：</p>
<h2 id="1-Non-pointer-isa-出现前的机制"><a href="#1-Non-pointer-isa-出现前的机制" class="headerlink" title="1. Non-pointer isa 出现前的机制"></a>1. Non-pointer isa 出现前的机制</h2><ul>
<li>传统 isa 指针的作用<br>  在 32 位系统或早期的 64 位系统中，对象的 isa 指针仅用于指向类对象的内存地址，不包含其他信息。</li>
<li>引用计数的存储方式<br>  对象的引用计数（retainCount）并不直接存储在对象内存中，而是通过一个全局的 SideTable 结构来维护。这个 SideTable 中的一个成员 RefcountMap refcnts 是一个哈希表，键是对象的地址，值则是对象的引用计数，至于什么是哈希表可以理解为 Objective-C 中的字典，但是比字典更底层更高效。SideTable 中还存在一个成员 spinlock_t slock，这是个自旋锁用来保证对 refcnts 的原子操作。</li>
<li>性能与设计考量：<ul>
<li>优点：避免了为每个对象单独分配存储引用计数的空间（节省内存，尤其是对象未被频繁操作时）。</li>
<li>缺点：每次 retain&#x2F;release 操作都需要访问散列表，可能引发锁竞争和性能损耗。</li>
</ul>
</li>
</ul>
<h2 id="2-Non-pointer-isa-的优化"><a href="#2-Non-pointer-isa-的优化" class="headerlink" title="2. Non-pointer isa 的优化"></a>2. Non-pointer isa 的优化</h2><p>在 64 位系统下，苹果对 isa 指针进行了优化（称为 ​​non-pointer isa​​），将部分内存管理信息直接存储在 isa 指针的冗余比特位中：</p>
<ul>
<li><strong>extra_rc 字段</strong>​​：isa 指针中保留了 ​​19 个比特位​​（不同架构可能略有差异）用于存储额外的引用计数值（extra retain count）。<ul>
<li>之所以叫额外的引用计数，这是因为在 objc4 某个版本之前是通过 extra_rc + 1 的形式返回对象的实际引用计数，即对象默认隐含了 1 个引用计数。</li>
<li>而在最近的版本中直接通过 extra_rc 表示实际引用计数</li>
<li>如果 extra_rc 溢出（即引用计数超过 2^19 -1），则会将溢出的部分转移到 ​​SideTable​​。</li>
</ul>
</li>
</ul>
<p>这种方式减少了全局散列表的访问频率，降低了锁竞争，提高了内存操作效率。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>non-pointer isa 出现前​​：引用计数完全依赖全局散列表（Side Tables）管理。</li>
<li>non-pointer isa 出现后​​：引用计数优先内联到 isa 的冗余位，仅在必要时使用 Side Tables。</li>
</ul>
<p>这种设计使得 iOS 的内存管理在绝大多数场景下（引用计数较小）无需访问全局表，从而显著提升性能。这一优化显著提升了内存访问效率和并发性能，是苹果针对 64 位系统的重要底层优化之一。</p>
<hr>
<h1 id="weak-指针"><a href="#weak-指针" class="headerlink" title="weak 指针"></a>weak 指针</h1><h2 id="weak-指针功能演示"><a href="#weak-指针功能演示" class="headerlink" title="weak 指针功能演示"></a>weak 指针功能演示</h2><p>有以下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p,%s&quot;</span>, <span class="keyword">self</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> Person *person1;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Person *person2;</span><br><span class="line">        </span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person new];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1.person:%@&quot;</span>, person);</span><br><span class="line">        person1 = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1.%@&quot;</span>, person1);</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person new];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2.person:%@&quot;</span>, person);</span><br><span class="line">        person2 = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2.%@&quot;</span>, person2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>person:&lt;Person: <span class="number">0x2821c0f10</span>&gt;</span><br><span class="line"><span class="number">0x2821c0f10</span>,-[Person dealloc]</span><br><span class="line"><span class="number">1.</span>(null)</span><br><span class="line"><span class="number">2.</span>person:&lt;Person: <span class="number">0x2821c0f10</span>&gt;</span><br><span class="line"><span class="number">0x2821c0f10</span>,-[Person dealloc]</span><br></pre></td></tr></table></figure>

<p>从打印的结果可以看到，<code>__weak</code> 修饰的 person1 所指向的对象在释放之后 person1 指向了 nil，所以打印的结果是 null。而 <code>__unsafe_unretained</code> 修饰的 person2 所指向的对象在释放之后依然指向着原来的地方，访问已经被释放的对象内存空间导致了 <code>EXC_BAD_ACCESS</code> 崩溃。</p>
<h2 id="unsafe-unretained-和-weak-的异同"><a href="#unsafe-unretained-和-weak-的异同" class="headerlink" title="__unsafe_unretained 和 __weak 的异同"></a><code>__unsafe_unretained</code> 和 <code>__weak</code> 的异同</h2><p>在 Objective-C 中，<code>__weak</code> 和 <code>__unsafe_unretained</code> 都是用于避免对象强引用的修饰符，但它们在安全性和底层行为上有本质区别。以下是它们的异同点：</p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol>
<li>不增加引用计数<br> 两者都不会增加对象的引用计数（即不持有对象所有权），因此不会阻止对象被释放。</li>
<li>用于打破循环引用<br> 都可以用于解决对象间的循环引用问题（例如在 block 或 delegate 中）。</li>
</ol>
<h3 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a>核心区别</h3><ol>
<li><p>内存管理机制</p>
<table>
<thead>
<tr>
<th></th>
<th><strong><code>__weak</code></strong></th>
<th><strong><code>__unsafe_unretained</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td>安全性</td>
<td>自动置空（对象释放后指针变 nil）</td>
<td>不自动置空（对象释放后指针变为野指针）</td>
</tr>
<tr>
<td>底层实现</td>
<td>依赖运行时库中建立的弱引用表（weak_table）</td>
<td>仅简单存储指针地址，无运行时介入</td>
</tr>
</tbody></table>
</li>
<li><p>使用场景</p>
<table>
<thead>
<tr>
<th><code>__weak</code></th>
<th><code>__unsafe_unretained</code></th>
</tr>
</thead>
<tbody><tr>
<td>需要自动安全的指针（如 delegate）</td>
<td>性能敏感场景，可以避免运行时开销</td>
</tr>
<tr>
<td>常规开发中的弱引用</td>
<td>兼容旧代码（iOS 4之前无 __weak）</td>
</tr>
<tr>
<td>需要避免野指针崩溃的场合</td>
<td>明确知道对象生命周期时的优化手段</td>
</tr>
</tbody></table>
</li>
<li><p>性能差异</p>
<ul>
<li><code>__weak</code> 需要运行时通过弱引用表动态管理指针，有额外的性能开销（注册、清理等）。</li>
<li><code>__weak_unretained</code> 直接存储指针地址，无运行时开销，性能更高。</li>
</ul>
</li>
</ol>
<h3 id="何时使用-unsafe-unretained"><a href="#何时使用-unsafe-unretained" class="headerlink" title="何时使用 __unsafe_unretained ?"></a>何时使用 __unsafe_unretained ?</h3><ol>
<li>兼容旧系统<br> iOS 4 或更早系统不支持 <code>__weak</code> 时，必须使用 <code>__unsafe_unretainde</code>。</li>
<li>性能优化<br> 在需要极致性能的代码中（例如高频调用的循环），避免弱引用表的运行时开销。</li>
<li>与非 Objective-C 对象交互<br> 例如与 CoreFoundation 对象，如 CFArrayRef 交互时，可能直接使用指针地址。</li>
<li>明确对象生命周期<br> 当开发者能严格包装被引用对象的声明周期时（例如单例对象），可安全使用。</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>__weak</th>
<th>__unsafe_unretained</th>
</tr>
</thead>
<tbody><tr>
<td>安全性</td>
<td>✅自动置空</td>
<td>❌野指针风险</td>
</tr>
<tr>
<td>运行时介入</td>
<td>✅依赖 weak_table</td>
<td>❌无介入</td>
</tr>
<tr>
<td>性能开销</td>
<td>较高（注册、清理操作）</td>
<td>无</td>
</tr>
<tr>
<td>适用场景</td>
<td>常规开发</td>
<td>旧系统兼容、性能优化、明确生命周期</td>
</tr>
</tbody></table>
<p>在 iOS 5+ 开发中，优先使用 __weak；仅在必要时（如性能优化或旧代码维护）使用 __unsafe_unretained，并确保完全理解其风险。</p>
<h2 id="weak-底层原理"><a href="#weak-底层原理" class="headerlink" title="weak 底层原理"></a>weak 底层原理</h2><p>Objective-C 中的 weak 实现是​​编译器的代码生成​​与​​运行时的内存管理机制​​协同工作的结果。以下是完整的协作流程：</p>
<h3 id="1-编译器与运行时的协作机制​"><a href="#1-编译器与运行时的协作机制​" class="headerlink" title="1. 编译器与运行时的协作机制​"></a>1. 编译器与运行时的协作机制​</h3><ul>
<li>编译器的作用：<ul>
<li><strong>插入关键函数​​</strong>：在 ARC 环境下，编译器会自动为 __weak 变量生成代码，插入 objc_initWeak（注册弱引用）和 objc_destroyWeak（移除弱引用）等函数调用。</li>
<li><strong>​​管理作用域​​</strong>：根据变量的生命周期（如超出作用域、被重新赋值），编译器决定何时调用这些函数。</li>
</ul>
</li>
<li>运行时的作用：<ul>
<li><strong>维护弱引用表</strong>​​：动态管理全局的弱引用表（Weak Table），记录对象与弱指针的映射关系。</li>
<li><strong>对象释放时的清理​​</strong>：在对象 dealloc 时，遍历弱引用表，将关联的弱指针置 nil。</li>
</ul>
</li>
</ul>
<h3 id="2-完整协作流程示例​"><a href="#2-完整协作流程示例​" class="headerlink" title="2. 完整协作流程示例​"></a>2. 完整协作流程示例​</h3><p>代码示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj = obj; <span class="comment">// 编译器插入 objc_initWeak</span></span><br><span class="line">    <span class="comment">// 使用 weakObj...</span></span><br><span class="line">&#125; <span class="comment">// 编译器插入 objc_destroyWeak</span></span><br></pre></td></tr></table></figure>

<p>编译器生成的伪代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入作用域</span></span><br><span class="line"><span class="built_in">NSObject</span> *obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(new));</span><br><span class="line"><span class="type">id</span> weakObj; <span class="comment">// 栈上的弱指针变量</span></span><br><span class="line">objc_initWeak(&amp;weakObj, obj); <span class="comment">// 注册到运行时弱引用表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出作用域时</span></span><br><span class="line">objc_destroyWeak(&amp;weakObj); <span class="comment">// 从弱引用表移除</span></span><br><span class="line">objc_storeStrong(&amp;obj, <span class="literal">nil</span>); <span class="comment">// 释放强引用</span></span><br></pre></td></tr></table></figure>

<h3 id="3-编译器的关键操作​​"><a href="#3-编译器的关键操作​​" class="headerlink" title="3. 编译器的关键操作​​"></a>3. 编译器的关键操作​​</h3><hr>
<!--

-->

<h1 id="autorelease-底层原理"><a href="#autorelease-底层原理" class="headerlink" title="autorelease 底层原理"></a>autorelease 底层原理</h1><p>autorelease 对象何时释放？</p>
<p>@autoreleasepool {} 这是一个编译器提供的语法糖。</p>
<p>分情况，</p>
<ul>
<li>你手动创建了 Autoreleasepool 的话，当然是在你自己创建的自动释放池释放的时候。</li>
<li>否则就是系统在 RunLoop 的几个时机创建的自动释放池了。</li>
</ul>
<p>通过 Clang rewrite-objc 查看 @Autoreleasepool{} 的底层表示，是个结构体。</p>
<p>220</p>
<p>然后是查看 objc_aureleasePoolPush() 函数和 objc_aureleasePoolPop() 函数的实现。在 objc4 源码里。<br>里面调用了 AutoreleasePoolPage 的方法，这是个 C++ 的类。</p>
<p>每个 AutoreleasePoolPage 实例对象占用 4KB 字节。除了自己的成员需要占用的几十个字节的空间，剩下的空间都用于存放加入了自动释放池的对象。<br>所有 AutoreleasePoolPage 实例对象采用双向链表的结构链接在一起。</p>
<p>@autoreleasepool{} 嵌套是个什么情况？每次都创建新池吗？</p>
<p>有一个私有函数可以查看自动释放池的情况 <code>_objc_autoreleasePoolPrint()</code></p>
<p>RunLoop 与 AutoreleasePool，有一个细节，究竟是在哪个库的哪个函数里面对 RunLoop 添加观察者实现自动释放池的创建和释放的，需要逆向分析出来~是 libobjc.A.dylib 库吗？还是 Foundation 库？</p>
<p>进入 RunLoop 之前创建一个新池 push<br>休眠之前，调用一个 pop，再创建一个新池 push<br>退出 RunLoop 的时候调用一次 pop。<br>现在的问题是，第一次进入 RunLoop 前 push 的池，是休眠前 pop 掉的，还是退出 RunLoop 的时候 pop 掉的？</p>
<p>打印 RunLoop 能看到自动释放池相关的 Observers </p>
<p>方法里面有局部对象，出了方法后会立即释放吗？不一定会，主要还是看对象的引用计数是否变为0，比如局部对象被Block捕获了的话出了方法体也不会被释放。只有等Block释放的时候，Block对它拥有的对象进行 release 的时候可能被释放。也还是要看对象的引用计数。</p>
]]></content>
      <categories>
        <category>iOS 底层原理</category>
      </categories>
  </entry>
</search>
