<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>iOS反调试与反反调试 | masterKing 的博客</title><meta name="author" content="masterKing"><meta name="copyright" content="masterKing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="反调试原理ptrace​​ptrace (Process Trace)​​ 是 Linux（以及其他一些类 Unix 系统，如 macOS）提供的一个极其强大且底层的​​系统调用​​。它的核心功能是​​允许一个进程（称为 tracer）观察和控制另一个进程（称为 tracee）的执行，并能检查和修改该进程的内存和寄存器。​​ 核心功能 追踪器的介入 (Tracer&#x2F;Tracee): 一个">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS反调试与反反调试">
<meta property="og:url" content="https://masterking.github.io/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/index.html">
<meta property="og:site_name" content="masterKing 的博客">
<meta property="og:description" content="反调试原理ptrace​​ptrace (Process Trace)​​ 是 Linux（以及其他一些类 Unix 系统，如 macOS）提供的一个极其强大且底层的​​系统调用​​。它的核心功能是​​允许一个进程（称为 tracer）观察和控制另一个进程（称为 tracee）的执行，并能检查和修改该进程的内存和寄存器。​​ 核心功能 追踪器的介入 (Tracer&#x2F;Tracee): 一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://masterking.github.io/images/iOSReveseEngineeringAndSecurity1.webp">
<meta property="article:published_time" content="2025-06-19T12:07:49.000Z">
<meta property="article:modified_time" content="2025-08-16T05:00:01.459Z">
<meta property="article:author" content="masterKing">
<meta property="article:tag" content="反调试">
<meta property="article:tag" content="反反调试">
<meta property="article:tag" content="小红书">
<meta property="article:tag" content="抖音">
<meta property="article:tag" content="支付宝">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://masterking.github.io/images/iOSReveseEngineeringAndSecurity1.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "iOS反调试与反反调试",
  "url": "https://masterking.github.io/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/",
  "image": "https://masterking.github.io/images/iOSReveseEngineeringAndSecurity1.webp",
  "datePublished": "2025-06-19T12:07:49.000Z",
  "dateModified": "2025-08-16T05:00:01.459Z",
  "author": [
    {
      "@type": "Person",
      "name": "masterKing",
      "url": "https://masterking.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://masterking.github.io/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e6857234b462ad05308d8b79794f0358";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'iOS反调试与反反调试',
  isHighlightShrink: undefined,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient( 135deg, #2c241f, #968282);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/WechatIMG1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/sileorepo/"><i class="fa-fw fas fa-shop"></i><span> sileo 源</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/iOSReveseEngineeringAndSecurity1.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">masterKing 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">iOS反调试与反反调试</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/sileorepo/"><i class="fa-fw fas fa-shop"></i><span> sileo 源</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">iOS反调试与反反调试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-19T12:07:49.000Z" title="发表于 2025-06-19 20:07:49">2025-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-16T05:00:01.459Z" title="更新于 2025-08-16 13:00:01">2025-08-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/iOS-%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8/">iOS 逆向与安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.8k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离上次更新已有&quot;,&quot;messageNext&quot;:&quot;天，文章某些内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-08-16 13:00:01&quot;}" hidden></div><h1 id="反调试原理"><a href="#反调试原理" class="headerlink" title="反调试原理"></a>反调试原理</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>​​ptrace (Process Trace)​​ 是 Linux（以及其他一些类 Unix 系统，如 macOS）提供的一个极其强大且底层的​​系统调用​​。它的核心功能是​​允许一个进程（称为 tracer）观察和控制另一个进程（称为 tracee）的执行，并能检查和修改该进程的内存和寄存器。​​</p>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ol>
<li>追踪器的介入 (Tracer&#x2F;Tracee):<ul>
<li>一个进程（如 gdb, strace）调用 ptrace 并指定 PTRACE_ATTACH 或 PTRACE_TRACEME 来开始追踪另一个目标进程。</li>
<li>被追踪的进程 (tracee) 就进入了特殊的状态。每当发生特定事件（尤其是系统调用或信号传递）时，内核会暂停 (SIGSTOP) tracee 的执行，并通知 tracer。</li>
</ul>
</li>
<li>​​观察和控制执行:<ul>
<li>​​单步执行 (Stepping):​​ Tracer 可以让 tracee 执行一条机器指令 (PTRACE_SINGLESTEP, PTRACE_STEP)，然后再次暂停，让 tracer 有机会检查状态。</li>
<li>​​设置断点:​​ Tracer 可以修改 tracee 的代码（在内存中），通常是通过替换目标地址的指令为一个特殊的陷阱指令（如 int 3）。当 tracee 执行到此处时，会触发一个信号并暂停，交给 tracer 处理。之后 tracer 恢复原指令，并可能继续执行或单步。</li>
<li>​​拦截系统调用:​​<ul>
<li>Tracer 可以要求在 tracee 即将进入系统调用 (PTRACE_SYSCALL) 或刚从系统调用返回时暂停。</li>
<li>strace 工具就是利用这点来打印出 tracee 进行了哪些系统调用以及参数、返回值。</li>
<li>Tracer 甚至可以修改进入系统调用时的寄存器参数（从而改变系统调用行为）或者修改系统调用的返回值。</li>
</ul>
</li>
</ul>
</li>
<li>​​检查和修改内存和寄存器:​​<ul>
<li>Tracer 可以读写 tracee 的内存 (PTRACE_PEEKDATA, PTRACE_POKEDATA)，包括代码段和数据段。</li>
<li>Tracer 可以读写 tracee 的 CPU 寄存器 (PTRACE_GETREGS, PTRACE_SETREGS, PTRACE_GETFPREGS, PTRACE_SETFPREGS)。</li>
</ul>
</li>
<li>处理信号:​<ul>
<li>当有信号要发送给 tracee 时，内核会先暂停 tracee，并通过 wait() 通知 tracer。</li>
<li>​​Tracer 有决定权:​​<ul>
<li>忽略这个信号：不让它传递给 tracee。</li>
<li>将信号传递给 tracee，让它处理。</li>
<li>注入一个自定义的信号给 tracee。</li>
<li>在这个过程中修改信号的行为。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="主要应用场景"><a href="#主要应用场景" class="headerlink" title="主要应用场景"></a>主要应用场景</h3><ol>
<li>​​调试器 (Debuggers):​​ 这是最经典的用途。像 gdb 就是利用 ptrace 来实现设置断点、单步执行、检查变量（内存）、查看寄存器值等核心调试功能。</li>
<li>​​系统调用追踪器 (System Call Tracers):​​ strace 和 ltrace 这些工具完全依赖 ptrace 来拦截进程调用的系统调用和库函数，并打印相关信息，用于诊断和分析程序行为。</li>
<li>​​代码插桩 (Instrumentation):​​ 在运行时修改程序代码或注入代码片段，用于性能分析（Profiling）、测试覆盖率、内存检测（如 AddressSanitizer&#x2F;Valgrind 的部分功能原理）等。</li>
<li>​​沙箱&#x2F;安全工具:​​ 创建受限的执行环境。Tracer 可以监控 tracee 的系统调用，并根据安全策略允许或拒绝某些敏感操作（如访问特定文件、进行网络连接）。</li>
<li>​​进程间控制:​​ 一些特殊场景下需要精细控制另一个进程的执行流。</li>
<li>​​进程注入:​​ 向另一个运行中的进程注入代码或数据。</li>
</ol>
<h3 id="重要特点和注意事项"><a href="#重要特点和注意事项" class="headerlink" title="重要特点和注意事项"></a>重要特点和注意事项</h3><ul>
<li>​​强大而底层:​​ ptrace 给了 tracer 对 tracee 几乎完全的控制权。</li>
<li>​​复杂性:​​ ptrace 接口相对复杂，涉及信号处理、进程状态、内存布局等多个方面，正确使用并不容易。</li>
<li>​​安全性:​​ ptrace 能力强大，通常普通用户只能 ptrace 自己拥有的进程（除非有 CAP_SYS_PTRACE 权限或 YAMA 等安全模块被配置）。恶意使用 ptrace 可被用于攻击或监控其他进程。</li>
<li>​​性能开销:​​ 频繁的 ptrace 操作（如 strace 追踪每个系统调用）会显著降低目标进程的执行速度。</li>
<li>​​不可靠的信号处理:​​ 使用 ptrace 的进程（tracer）在信号处理上需要极其小心，因为 SIGCHLD 等信号的默认行为会被 ptrace 事件干扰。</li>
<li>​​竞争条件:​​ 在设计使用 ptrace 的工具时要特别注意并发和竞争条件。</li>
</ul>
<p>总结:​​ ptrace 是 Linux 系统上一个非常基础的、用于进程间追踪和控制的系统调用。它赋予了调试器 (gdb)、系统调用跟踪器 (strace) 以及其他各种分析、安全和控制工具强大的能力，但同时也非常复杂且需要谨慎使用。理解 ptrace 是深入理解 Linux 下进程执行、调试和系统监控机制的关键。</p>
<h3 id="ptrace-的参数简单介绍"><a href="#ptrace-的参数简单介绍" class="headerlink" title="ptrace 的参数简单介绍"></a>ptrace 的参数简单介绍</h3><p>ptrace 的原型可以在 macOS 中找到，新建一个 macOS 的应用，或者更加简单一点的命令行程序，就可以导入 sys&#x2F;ptrace.h 文件查看函数原型并使用它了。如下图：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250704_2.png" class="">

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SYS_PTRACE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SYS_PTRACE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/appleapiopts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/cdefs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	ePtAttachDeprecated __deprecated_enum_msg(<span class="string">&quot;PT_ATTACH is deprecated. See PT_ATTACHEXC&quot;</span>) = <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_ME     0       <span class="comment">/* child declares it&#x27;s being traced */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_READ_I       1       <span class="comment">/* read word in child&#x27;s I space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_READ_D       2       <span class="comment">/* read word in child&#x27;s D space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_READ_U       3       <span class="comment">/* read word in child&#x27;s user structure */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_WRITE_I      4       <span class="comment">/* write word in child&#x27;s I space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_WRITE_D      5       <span class="comment">/* write word in child&#x27;s D space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_WRITE_U      6       <span class="comment">/* write word in child&#x27;s user structure */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_CONTINUE     7       <span class="comment">/* continue the child */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_KILL         8       <span class="comment">/* kill the child process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_STEP         9       <span class="comment">/* single step the child */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ATTACH       ePtAttachDeprecated     <span class="comment">/* trace some running process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DETACH       11      <span class="comment">/* stop tracing a process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SIGEXC       12      <span class="comment">/* signals as exceptions for current_proc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_THUPDATE     13      <span class="comment">/* signal for thread# */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ATTACHEXC    14      <span class="comment">/* attach to running process with signal exception */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_FORCEQUOTA   30      <span class="comment">/* Enforce quota for root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DENY_ATTACH  31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_FIRSTMACH    32      <span class="comment">/* for machine-specific requests */</span></span></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>     ptrace(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data);</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* !_SYS_PTRACE_H_ */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>_request： 最重要的参数，指定要对目标进程 pid 执行的具体操作类型。常用的 request 包括：<ul>
<li>PT_TRACE_ME：指示本进程希望被其父进程跟踪（通常是调试器启动目标进程时，目标进程主动调用）。</li>
<li>PT_ATTACH: 附着到已运行的 pid 进程上，开始跟踪它。</li>
<li>PT_DETACH: 停止跟踪 pid 目标进程，使其恢复独立运行。</li>
<li>PT_STEP: 设置单步陷阱标志，让目标进程 pid 执行一条指令后暂停。</li>
<li>PT_DENY_ATTACH: 拒绝调试器附加，这正是我们需要传入的参数。</li>
</ul>
</li>
<li>_pid：目标进程的进程 ID。</li>
<li>_addr​​: 内存地址（常用于 READ&#x2F;WRITE DATA，系统调用号过滤器等特定操作）。</li>
<li>_data：指向一个数据缓冲区的指针，其含义取决于 request（如要写入的数据，存储读取数据的结构体地址，信号编号等）。</li>
</ul>
<h3 id="在-iOS-中调用-ptrace-反调试"><a href="#在-iOS-中调用-ptrace-反调试" class="headerlink" title="在 iOS 中调用 ptrace 反调试"></a>在 iOS 中调用 ptrace 反调试</h3><p>在刚刚的 macOS 应用的例子中我们可以直接导入 sys&#x2F;ptrace.h 头文件使用 ptrace 函数。但是到了 iOS 环境是无法直接导入 sys&#x2F;ptrace.h 头文件的，那么自然是无法通过这种方式调用 ptrace 了。但是可以确定的是 iOS 中也的确存在 ptrace 这个函数，只是 iOS 系统没有对外开放。我们可以使用一些绕过限制的方法调用 ptrace。</p>
<h4 id="1-使用-extern"><a href="#1-使用-extern" class="headerlink" title="1. 使用 extern"></a>1. 使用 extern</h4><p>如下图：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250704_3.png" class="">
<p>这样调用之后，使用 Xcode 调试启动 APP 之后就会被断开调试了，也就意味着我们的 APP 现在无法被 lldb 调试器附加了。尝试附加调试会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=demoiOSApp</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process demoiOSApp...</span><br><span class="line">zsh: segmentation fault  debugserver localhost:3333 --attach=demoiOSApp</span><br></pre></td></tr></table></figure>

<p>这种直接使用 ptrace 函数的方式，动态绕过的办法可以使用 fishhook 进行绕过。静态的方法当然是修改汇编指令也可以绕过。以下是使用 fishhook 绕过这种反调试的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;InjectCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;fishhook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*orig_ptrace)(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hook_ptrace(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_request == <span class="number">31</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orig_ptrace(_request, _pid, _addr, _data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">InjectCode</span></span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">struct</span> rebinding one;</span><br><span class="line">        one.name = <span class="string">&quot;ptrace&quot;</span>;</span><br><span class="line">        one.replaced = (<span class="type">void</span>*)&amp;orig_ptrace;</span><br><span class="line">        one.replacement = hook_ptrace;</span><br><span class="line">        <span class="keyword">struct</span> rebinding array[] = &#123;one&#125;;</span><br><span class="line">        rebind_symbols(array, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="2-利用-dlsym"><a href="#2-利用-dlsym" class="headerlink" title="2. 利用 dlsym"></a>2. 利用 dlsym</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> (*ptrace_t)(<span class="type">int</span> _request, pid_t _pid, caddr_t _addr, <span class="type">int</span> _data);</span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="type">void</span> *handle = dlopen(<span class="number">0</span>, RTLD_GLOBAL | RTLD_NOW);</span><br><span class="line">    ptrace_t ptrace = dlsym(handle, <span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">    ptrace(<span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 dlsym 函数动态获取 ptrace 的函数调用。这种方式调用 ptrace 的话，动态的方法就无法使用 fishhook hook ptrace 绕过反调试了，但是可以通过 fishhook hook dlsym 函数的方式绕过，还可以利用 lldb 实现汇编级别的 hook 实现绕过。静态的方法同样是修改汇编指令绕过。</p>
<h4 id="3-使用-syscall-的方式"><a href="#3-使用-syscall-的方式" class="headerlink" title="3. 使用 syscall 的方式"></a>3. 使用 syscall 的方式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    syscall(<span class="number">26</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 syscall 函数，通过传入第一个参数值 26 代表调用的 ptrace 函数，后续的参数就是 ptrace 所需的参数，而 31 正是 PT_DENY_ATTACH。这种方式也无法简单的通过 fishhook 绕过反调试。还可以使用 lldb 进行汇编指令级 hook 实现动态绕过。静态的方式依旧是修改汇编指令。</p>
<h4 id="4-使用内联汇编的方式"><a href="#4-使用内联汇编的方式" class="headerlink" title="4. 使用内联汇编的方式"></a>4. 使用内联汇编的方式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">	</span><br><span class="line">    __asm__ <span class="keyword">volatile</span>(</span><br><span class="line">        <span class="string">&quot;mov x0, #0x1f\n&quot;</span>   <span class="comment">// PT_DENY_ATTACH 的值 (31)</span></span><br><span class="line">        <span class="string">&quot;mov x1, #0x0\n&quot;</span>    <span class="comment">// 第二个参数 (0)</span></span><br><span class="line">        <span class="string">&quot;mov x2, #0x0\n&quot;</span>    <span class="comment">// 第三个参数 (0)</span></span><br><span class="line">        <span class="string">&quot;mov x3, #0x0\n&quot;</span>    <span class="comment">// 第四个参数 (0)</span></span><br><span class="line">        <span class="string">&quot;mov x16, #0x1a\n&quot;</span>  <span class="comment">// ptrace 的系统调用号 (26)</span></span><br><span class="line">        <span class="string">&quot;svc #0x80&quot;</span>         <span class="comment">// 执行系统调用</span></span><br><span class="line">    );</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式调用 ptrace，动态的绕过方式使用 fishhook 肯定是不行的，但是可以使用 lldb 汇编级 hook 绕过。而静态的方式当然依旧是分析并修改汇编代码。</p>
<p>以上 4 种方式都是直接或间接的调用 ptrace 函数来实现反调试。<del>iOS 内核已加强对 ptrace 的管控，非越狱环境下调用受限，开发者需依赖私有 API 或漏洞利用。</del>单一 ptrace 易被破解，通常需结合：</p>
<ul>
<li>sysctl 定期检测​​：轮询进程状态标志位（如 P_TRACED），发现调试则主动退出或相应的处理。</li>
<li>代码混淆​​：隐藏反调试逻辑，增加逆向分析难度。</li>
</ul>
<p>在 macOS&#x2F;iOS 中，ptrace 的核心价值在于​​主动阻断调试器附加​​，但需结合动态加载、系统调用和混淆技术提升可靠性。反调试本质是攻防对抗的持续升级，单一措施不足以保证绝对安全，需多层防护策略。</p>
<h2 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h2><p>sysctl 是一个用于动态配置内核参数的命令行工具同时也是一个可供编程的函数接口，在类 Unix 系统（如 Linux、FreeBSD）及 Apple 生态系统（macOS、iOS）中广泛使用，但不同平台的作用范围和权限限制存在显著差异。以下是具体分析：</p>
<h3 id="类-Unix-系统（Linux-BSD）中的作用​"><a href="#类-Unix-系统（Linux-BSD）中的作用​" class="headerlink" title="类 Unix 系统（Linux&#x2F;BSD）中的作用​"></a>类 Unix 系统（Linux&#x2F;BSD）中的作用​</h3><p>sysctl 通过操作 &#x2F;proc&#x2F;sys&#x2F; 虚拟文件系统实现内核参数的实时调整，无需重启系统。核心功能包括：</p>
<ol>
<li>​​动态调优性能​​<ul>
<li>​​网络优化​​：调整 TCP 连接队列（net.core.somaxconn）、缓冲区大小（net.ipv4.tcp_rmem）、SYN Flood 防御（net.ipv4.tcp_syncookies&#x3D;1）。</li>
<li>​​内存管理​​：控制 Swap 使用倾向（vm.swappiness&#x3D;10）、脏页写回策略（vm.dirty_ratio）。</li>
<li>​​文件系统​​：设置最大文件句柄数（fs.file-max&#x3D;2097152）。</li>
</ul>
</li>
<li>功能启停<ul>
<li>启用 IP 转发（net.ipv4.ip_forward&#x3D;1），将主机配置为路由器。</li>
<li>禁用 ICMP 响应（net.ipv4.icmp_echo_ignore_all&#x3D;1）以提升安全性。</li>
</ul>
</li>
<li>持久化配置<ul>
<li>参数写入 &#x2F;etc&#x2F;sysctl.conf 或 &#x2F;etc&#x2F;sysctl.d&#x2F;*.conf，通过 sysctl -p 加载。</li>
</ul>
</li>
</ol>
<h3 id="macOS-中的特殊性与限制​"><a href="#macOS-中的特殊性与限制​" class="headerlink" title="macOS 中的特殊性与限制​"></a>macOS 中的特殊性与限制​</h3><p>macOS 继承 BSD 的 sysctl 实现，但存在平台差异：</p>
<ol>
<li>配置方式<ul>
<li>默认无 &#x2F;etc&#x2F;sysctl.conf，需手动创建并加载（sudo sysctl -p）。</li>
<li>部分参数需通过 ​​launchd​​ 持久化（如修改 maxfiles 限制需编辑 &#x2F;etc&#x2F;launchd.conf）。</li>
</ul>
</li>
<li>系统完整性保护（SIP）<ul>
<li>macOS Big Sur 及以上版本中，修改核心参数（如 kern.ipc 系列）需​​关闭 SIP​​，否则操作被拦截。</li>
</ul>
</li>
<li>典型用例<ul>
<li>调整 Socket 队列（kern.ipc.somaxconn）、虚拟内存参数（vm.swappiness）。</li>
</ul>
</li>
</ol>
<h3 id="iOS-中的严格限制​"><a href="#iOS-中的严格限制​" class="headerlink" title="iOS 中的严格限制​"></a>iOS 中的严格限制​</h3><p>iOS 对 sysctl 的访问施加了更严格的安全策略：</p>
<ol>
<li>权限封锁<ul>
<li>多数敏感参数（如 kern.boottime）返回 ​​EPERM 错误​​，禁止用户态进程读取。</li>
<li>仅允许少数“白名单”参数（如设备型号、CPU 核心数）通过公有 API 访问。</li>
</ul>
</li>
<li>合法使用场景<ul>
<li>获取设备运行时间（kern.boottime）用于反欺诈检测（如防止日期篡改），但需 Apple 审核批准。</li>
<li>Apple 建议优先使用公开 API（如 NSProcessInfo），并​​避免依赖未文档化的参数​​。</li>
</ul>
</li>
<li>开发风险<ul>
<li>使用私有 sysctl 可能导致 App 审核被拒，因违反“禁止访问私有接口”条款。</li>
</ul>
</li>
</ol>
<h3 id="在-iOS-中使用-sysctl-检测进程是否被调试"><a href="#在-iOS-中使用-sysctl-检测进程是否被调试" class="headerlink" title="在 iOS 中使用 sysctl 检测进程是否被调试"></a>在 iOS 中使用 sysctl 检测进程是否被调试</h3><p>实现代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isBeingDebugged(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">int</span> name[<span class="number">4</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="built_in">CTL_KERN</span>;</span><br><span class="line">    name[<span class="number">1</span>] = KERN_PROC;</span><br><span class="line">    name[<span class="number">2</span>] = KERN_PROC_PID;</span><br><span class="line">    name[<span class="number">3</span>] = getpid();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> kinfo_proc info;</span><br><span class="line">    size_t infoSize = <span class="keyword">sizeof</span>(info);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sysctl(name, <span class="number">4</span>, &amp;info, &amp;infoSize, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sysctl failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((info.kp_proc.p_flag &amp; P_TRACED) != <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isBeingDebugged()) &#123;</span><br><span class="line">        printf(<span class="string">&quot;检测到调试。。。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printf(<span class="string">&quot;没有被调试。。。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种通过调用 sysctl 函数查询当前进程的一些信息来判断是否被附加调试的方式通常可以结合定时器，或者子线程 sleep 的方式来保持长期的运行。在这种情况下，检测到被调试的时候不建议直接退出当前进程如调用 exit、kill 等，这样的处理属于简单粗暴的方式。实际使用中可以根据需求制定其他的处理方式。</p>
<p>如何绕过这种检测呢？动态的方式当然同样可以使用 fishhook 进行绕过检测，但是这个 hook 方法的实现和一般的 hook 方法实现不一样，这个 hook 方法中需要修改 info 的结果，使其表示是否被调试的标志位始终为 0。具体的 hook 代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;InjectCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;fishhook.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*orig_sysctl)(<span class="type">int</span> *, u_int, <span class="type">void</span> *, size_t *oldlenp, <span class="type">void</span> *, size_t newlen);</span><br><span class="line"><span class="type">int</span> hook_sysctl(<span class="type">int</span> * name, u_int namelen,</span><br><span class="line">                <span class="type">void</span> * info, size_t *infosize,</span><br><span class="line">                <span class="type">void</span> * newInfo, size_t newsize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (namelen == <span class="number">4</span> &amp;&amp;</span><br><span class="line">        name[<span class="number">0</span>] == <span class="built_in">CTL_KERN</span> &amp;&amp;</span><br><span class="line">        name[<span class="number">1</span>] == KERN_PROC &amp;&amp;</span><br><span class="line">        name[<span class="number">2</span>] == KERN_PROC_PID &amp;&amp;</span><br><span class="line">        info &amp;&amp;</span><br><span class="line">        infosize &amp;&amp;</span><br><span class="line">        *infosize == <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kinfo_proc)) &#123;</span><br><span class="line">        <span class="type">int</span> ret = orig_sysctl(name, namelen, info, infosize, newInfo, newsize);</span><br><span class="line">        <span class="keyword">struct</span> kinfo_proc *info_ptr = (<span class="keyword">struct</span> kinfo_proc *)info;</span><br><span class="line">        <span class="comment">// 如果 info_ptr-&gt;kp_proc.p_flag 为 1，那么将它变为 0，因为 1 表示有附加调试</span></span><br><span class="line">        <span class="keyword">if</span> (info_ptr &amp;&amp; (info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) != <span class="number">0</span>) &#123;</span><br><span class="line">            info_ptr-&gt;kp_proc.p_flag ^= P_TRACED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orig_sysctl(name, namelen, info, infosize, newInfo, newsize);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">InjectCode</span></span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="keyword">struct</span> rebinding one;</span><br><span class="line">        one.name = <span class="string">&quot;sysctl&quot;</span>;</span><br><span class="line">        one.replaced = (<span class="type">void</span>*)&amp;orig_sysctl;</span><br><span class="line">        one.replacement = hook_sysctl;</span><br><span class="line">        <span class="keyword">struct</span> rebinding array[] = &#123;one&#125;;</span><br><span class="line">        rebind_symbols(array, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>那如何应对 fishhook 这种反反调试呢？当然是不要直接使用 sysctl 这样的函数调用，可以利用 dlsym 动态获取函数实现从而绕过 fishhook，或者使用汇编实现。还有一点值得注意的就是 hook 代码和反 hook 代码的执行顺序问题。</p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><h2 id="如何反制"><a href="#如何反制" class="headerlink" title="如何反制"></a>如何反制</h2><p>总的来说，反制的的手段分为动态的 hook 和静态的修改 MachO 两个方面。</p>
<p>库的先后顺序能影响检测的结果。<br>使用函数指针保存 ptrace，sysctl 地址，使用函数指针调用函数。<br>修改 MachO</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>作者的实战环境是 Mac Pro（macOS 15.3.1），iPhone 8 Plus（iOS 16.7.10）使用 palera1n 的 rootful 越狱。</p>
<h2 id="动态绕过反调试"><a href="#动态绕过反调试" class="headerlink" title="动态绕过反调试"></a>动态绕过反调试</h2><p>这里介绍一个 lldb 插件 <a target="_blank" rel="noopener" href="https://github.com/4ch12dy/xia0LLDB">xia0LLDB</a>。提供了一个 debugme 命令可以 hook ptrace 和 inlinehook svc 来绕过反调试。但是在我的环境 iPhone8Plus iOS16.7.10 中想要成功利用 debugme 绕过 iOS 端最新版小红书还是没那么简单，出了点问题，我们来分析一下为什么。</p>
<h3 id="小红书"><a href="#小红书" class="headerlink" title="小红书"></a>小红书</h3><p>这里以作者编写本文时的 iOS 端小红书最新版本(8.88)为例。我们都知道，小红书是做了 lldb 反调试的。直接启动 APP，然后使用 debugserver 附加调试，肯定是附加不成功的。以下为演示：</p>
<p>APP 在前台时尝试附加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=discover</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process discover...</span><br><span class="line">zsh: segmentation fault  debugserver localhost:3333 --attach=discover</span><br></pre></td></tr></table></figure>

<p>而就算把 APP 杀死，如上划杀掉进程，或者使用 kill，killall 命令干掉 APP 进程，再次附加调试也是无法成功的，因为此时进程并不存在。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=discover</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process discover...</span><br><span class="line">error: failed to attach to process named: <span class="string">&quot;&quot;</span></span><br><span class="line">Exiting.</span><br></pre></td></tr></table></figure>

<p>的确存在一种情况，即使做了反调试也可以成功附加的，那就是应用长时间没有打开过了，也不要打开，但是 ps 查看进程依然存在。这个时候可以使用 <code>--attach</code> 附加成功，对的即使做了反调试也能附加成功，只是在附加成功之后 continue 依然会被断开调试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line">Process 562 resuming</span><br><span class="line">Process 562 exited with status = 45 (0x0000002d)</span><br></pre></td></tr></table></figure>

<p>或许你在网上曾经看到过 backboard 调试​​（通过 backboard 服务启动应用）时，​​在应用代码执行前暂停​​，以便调试器（LLDB）能附加并运行命令。即以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver *:端口号 -x backboard /应用路径</span><br></pre></td></tr></table></figure>

<p>然而，在 lldb 16.0.0 中，并不存在这个选项了。。。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iPhone8plus:~ root#debugserver -x backboard localhost:3333 /private/var/containers/Bundle/Application/AEE569ED-D421-4274-93EA-72456A764135/discover.app/discover</span><br><span class="line">error: invalid TYPE <span class="keyword">for</span> the --launch=TYPE (-x TYPE) option: <span class="string">&#x27;backboard&#x27;</span></span><br><span class="line">Valid values TYPE are:</span><br><span class="line">  auto       Auto-detect the best launch method to use.</span><br><span class="line">  posix      Launch the executable using posix_spawn.</span><br><span class="line">  fork       Launch the executable using fork and <span class="built_in">exec</span>.</span><br></pre></td></tr></table></figure>

<p>此时，可以使用 debugserver 的 –waitfor 选项来实现在目标应用代码执行前暂停，以便 lldb 能附加并运行命令。就是说 backboard 被 –waitfor 替代了。下面是完整的流程：</p>
<ol>
<li><p>确保目标进程不存在：实现的方式有手动上划掉进程，killall -9 进程名，kill pid 等方式</p>
</li>
<li><p>使用 debugserver 的 –waitfor 选项：</p>
<p> 我这里使用了 iproxy 进行了端口映射，将电脑的 3333 端口和手机的 3333 端口关联了起来，所以可以使用 <code>localhost:3333</code> 作为参数。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --waitfor=discover</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Waiting to attach to process discover...</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p>手指点击启动目标 APP </p>
</li>
<li><p>进入 lldb 调试：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line"></span><br><span class="line">           https://github.com/4ch12dy/xia0LLDB</span><br><span class="line">          Welcome to xia0LLDB - Python3 Edition</span><br><span class="line">          ,--.          ,--.  ,--.   ,--.   ,------.  ,-----.</span><br><span class="line">,--.  ,--.`--<span class="string">&#x27; ,--,--. /    \ |  |   |  |   |  .-.  \ |  |) /_</span></span><br><span class="line"><span class="string"> \  `&#x27;</span>  / ,--.<span class="string">&#x27; ,-.  ||  ()  ||  |   |  |   |  |  \  :|  .-.  \</span></span><br><span class="line"><span class="string"> /  /.  \ |  |\ &#x27;</span>-<span class="string">&#x27;  | \    / |  &#x27;</span>--.|  <span class="string">&#x27;--.|  &#x27;</span>--<span class="string">&#x27;  /|  &#x27;</span>--<span class="string">&#x27; /</span></span><br><span class="line"><span class="string">&#x27;</span>--<span class="string">&#x27;  &#x27;</span>--<span class="string">&#x27;`--&#x27;</span> `--`--<span class="string">&#x27;  `--&#x27;</span>  `-----<span class="string">&#x27;`-----&#x27;</span>`-------<span class="string">&#x27; `------&#x27;</span></span><br><span class="line"></span><br><span class="line">[xia0LLDB] * Version: 3.1</span><br><span class="line">[xia0LLDB] + Loading all scripts from /Users/franky/xia0LLDB/src</span><br><span class="line">[xia0LLDB] * Finished</span><br><span class="line">(lldb) process connect connect://localhost:3333 <span class="comment"># 连接到手机建立的 debugserver</span></span><br><span class="line">Process 3166 stopped</span><br><span class="line">* thread <span class="comment">#1, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000118fb6ed0 dyld`dyld4::PrebuiltLoader::isValid(dyld4::RuntimeState const&amp;) const + 520</span></span><br><span class="line">dyld`dyld4::PrebuiltLoader::isValid:</span><br><span class="line">-&gt;  0x118fb6ed0 &lt;+520&gt;: add    w22, w22, <span class="comment">#0x1</span></span><br><span class="line">    0x118fb6ed4 &lt;+524&gt;: cmp    w22, w9</span><br><span class="line">    0x118fb6ed8 &lt;+528&gt;: b.lo   0x118fb6e64    ; &lt;+412&gt;</span><br><span class="line">    0x118fb6edc &lt;+532&gt;: cbz    x8, 0x118fb6f60 ; &lt;+664&gt;</span><br><span class="line">Target 0: (discover) stopped.</span><br><span class="line">(lldb) croc <span class="comment"># 此时处在 dyld`start 方法中，是一个非常早的阶段，很多镜像都没完成加载，CoreFoundation 都没加载，直接使用 debugme 也是会报错的..所以执行这个命令，这个命令里面其实做的事情也很简单，设置了一个 CFBundleGetMainBundle 的断点，然后继续执行会来到断点，然后删掉所有断点，当断点来到 CFBundleGetMainBundle 后，此时所有镜像都加载完成了。后续的 debugme 命令也能成功运行了</span></span><br><span class="line">[*] going to <span class="built_in">env</span> that can run oc script</span><br><span class="line">1 location added to breakpoint 1</span><br><span class="line">[+] now you can exe oc</span><br><span class="line">(lldb) debugme <span class="comment"># 这个命令核心的作用就是对 ptrace 进行 hook，以及对 svc #80 指令进行 hook，这是通过对 APP 镜像文件以及所属的 Framework 的镜像文件的代码段扫描是否存在 svc #80 指令，如果存在就进行 hook。而 hook 的核心实现原理就是新创建一个内存页存放 hook 代码，同时修改原始指令的内存页跳转到 hook 代码中。</span></span><br><span class="line">[*] start patch ptrace funtion to bypass anti debug</span><br><span class="line">[+] ptrace funtion patach <span class="keyword">done</span></span><br><span class="line">[*] start patch svc ins to bypass anti debug</span><br><span class="line">[+] use <span class="string">&quot;target list&quot;</span> to get main module:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/discover</span><br><span class="line">[*] app <span class="built_in">dir</span>:/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/discover</span><br><span class="line">[*] text start:0x0000000104a48000 end:0x0000000111848630</span><br><span class="line">------&gt;  4550367176</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] start hook svc at address:0x10f3917c8</span><br><span class="line">[+] hook svc at address:0x10f3917c8 <span class="keyword">done</span></span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/A.framework/A</span><br><span class="line">[*] text start:0x0000000118eec6d4 end:0x0000000118eeeb90</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/KasaSDK.framework/KasaSDK</span></span><br><span class="line"><span class="string">[*] text start:0x0000000119bb30c0 end:0x000000011a4291e8</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/TXFFmpeg.framework/TXFFmpeg</span><br><span class="line">[*] text start:0x0000000119245dd4 end:0x000000011936f1c8</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/TXSoundTouch.framework/TXSoundTouch</span></span><br><span class="line"><span class="string">[*] text start:0x0000000118f07764 end:0x0000000118f0bcc0</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/F55AF2FB-E18C-4B2A-95D1-9630F579F8FD/discover.app/Frameworks/Tquic.framework/Tquic</span><br><span class="line">[*] text start:0x00000001196b6380 end:0x00000001198378d0</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[x] happy debugging~ kill antiDebug by xia0@2019	</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>从打印结果来看，似乎顺利对 discover 的 svc #80 汇编调用进行了 hook，实现了反调试绕过。然后 continue 之后马上就遇到了 signal SIGSYS 信号。。。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br><span class="line">Process 429 resuming</span><br><span class="line">Process 429 stopped</span><br><span class="line">* thread <span class="comment">#4, queue = &#x27;com.apple.root.user-initiated-qos&#x27;, stop reason = signal SIGSYS</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000010663d140 discover`___lldb_unnamed_symbol272407 + 72</span></span><br><span class="line">discover`___lldb_unnamed_symbol272407:</span><br><span class="line">-&gt;  0x10663d140 &lt;+72&gt;: mov    x8, x0</span><br><span class="line">    0x10663d144 &lt;+76&gt;: cmp    w8, <span class="comment">#0x0</span></span><br><span class="line">    0x10663d148 &lt;+80&gt;: cset   w0, eq</span><br><span class="line">    0x10663d14c &lt;+84&gt;: ldp    x29, x30, [sp, <span class="comment">#0x90]</span></span><br><span class="line">Target 0: (discover) stopped.</span><br><span class="line">(lldb) rr</span><br><span class="line">      x0 = 0x000000000000004e</span><br><span class="line">      x1 = 0x0000000000000000</span><br><span class="line">      x2 = 0x0000000000000000</span><br><span class="line">      x3 = 0x0000000000000000</span><br><span class="line">      x4 = 0x0000000000000000</span><br><span class="line">      x5 = 0x0000000000000000</span><br><span class="line">      x6 = 0x00000002806ede50</span><br><span class="line">      x7 = 0x0000000000000000</span><br><span class="line">      x8 = 0x00000001160b20ee  <span class="string">&quot;/private/var/containers/Shared/SystemGroup/systemgroup.com.apple.mobilegestaltcache/Library/Caches/com.apple.MobileGestalt.plist&quot;</span></span><br><span class="line">      x9 = 0x0000000000000000</span><br><span class="line">     x16 = 0x00000001194c4000</span><br><span class="line">      pc = 0x000000010663d140  discover`___lldb_unnamed_symbol272407 + 72</span><br><span class="line">      lr = 0x000000010663d110  discover`___lldb_unnamed_symbol272407 + 24</span><br><span class="line">      sp = 0x000000016bbe5730</span><br></pre></td></tr></table></figure>

<p>借助 AI 我们很容易知道，SIGSYS 是发生了系统调用异常，也就是系统调用函数出错，传入了一个非法的参数。。。通过读取寄存器 x16 的值可以发现的确不是一个正常的系统调用参数，正常的系统调用参数值在 0~558 左右之内，可以在 syscall.h 头文件查看。那为什么会出现 x16 变成一个巨大的值呢？这就需要对 debugme 进行好好研究一番了。。。实际确实花费了不少时间和功夫。最终发现出问题的地方在对原始指令的修改，跳转到 hook 代码的地方出了一点儿问题。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> ldr x16, <span class="comment">#0x8</span></span><br><span class="line"> br x16</span><br><span class="line"> hook_code_addr_1</span><br><span class="line"> hook_code_addr_2</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="number">50</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">00</span> 02 1f d6 原作者这里使用 x16 跳转,但是目前在小红书最新版本出现了问题,修改了 x16 的值,导致正常的 svc 调用参数超出范围出现 sigsys 异常</span><br><span class="line"><span class="number">51</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">20</span> 02 1F D6 改用这个 x17 跳转,试试看,没问题!</span><br><span class="line">*/</span><br><span class="line">uint8_t patch_data[] = &#123;<span class="number">0x50</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x1f</span>, <span class="number">0xd6</span>, (uint8_t)(new_p&amp;<span class="number">0xff</span>), (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">1</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">2</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">3</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">4</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">5</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">6</span>)&amp;<span class="number">0xff</span>),  (uint8_t)((new_p&gt;&gt;<span class="number">8</span>*<span class="number">7</span>)&amp;<span class="number">0xff</span>)&#125;;</span><br><span class="line"><span class="built_in">int</span> patch_data_size = <span class="number">4</span>*<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>是的，只需要修改 2 个字节，就可以继续使用 xia0LLDB 绕过小红书最新版的反调试了，但是要能知道这 2 个字节在哪，怎么修改还是需要一些的基础的。修改完 debugme.py 之后再次重复前面的步骤进入 lldb 调试，输入 debugme 之后 c (lldb continue 命令的缩写)就能正常运行了。进入页面之后，如果想查看小红书的视图控制器层次结构可以先 process interrupt 中断进程，然后输入 <code>po [[[[UIApplication sharedApplication] keyWindow] rootViewController] _printHierarchy] </code> 就可以查看了。<code>_printHierarchy</code> 是 UIViewController 的私有方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process  interrupt</span><br><span class="line">Process 11823 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000001c6dd5030 libsystem_kernel.dylib` mach_msg2_trap  + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg2_trap:</span><br><span class="line">-&gt;  0x1c6dd5030 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;macx_swapon:    0x1c6dd5034 &lt;+0&gt;: mov    x16, #-0x30 ; =-48</span></span><br><span class="line"><span class="string">    0x1c6dd5038 &lt;+4&gt;: svc    #0x80</span></span><br><span class="line"><span class="string">    0x1c6dd503c &lt;+8&gt;: ret</span></span><br><span class="line"><span class="string">libsystem_kernel.dylib&#x27;</span>macx_swapoff:    0x1c6dd5040 &lt;+0&gt;: mov    x16, <span class="comment">#-0x31 ; =-49</span></span><br><span class="line">    0x1c6dd5044 &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x1c6dd5048 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;thread_get_special_reply_port:    0x1c6dd504c &lt;+0&gt;: mov    x16, #-0x32 ; =-50</span></span><br><span class="line"><span class="string">Target 0: (discover) stopped.</span></span><br><span class="line"><span class="string">(lldb) po [[[[UIApplication sharedApplication] keyWindow] rootViewController] _printHierarchy]</span></span><br><span class="line"><span class="string">&lt;XYPHNavigationViewController 0x12a03a600&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x12af72ca0&gt;</span></span><br><span class="line"><span class="string">   | &lt;XYPHClassicHomeViewController 0x12af703c0&gt;, state: appeared, view: &lt;UIView: 0x12af16c70&gt;</span></span><br><span class="line"><span class="string">   |    | &lt;XYPHHomeTabbarController 0x12d010e00&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x12af77040&gt;</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12d10a000&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x134438da0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYMHomeViewController 0x12a0a2000&gt;, state: appeared, view: &lt;UIView: 0x12aadca60&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    | &lt;XYPageViewController 0x12a04a800&gt;, state: appeared, view: &lt;UIView: 0x13443d850&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    | &lt;XYEXExploreFeedV2ViewController 0x139317af0&gt;, state: appeared, view: &lt;UIView: 0x13931b4e0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    | &lt;XYPageViewController 0x12d194a00&gt;, state: appeared, view: &lt;UIView: 0x13931c760&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    | &lt;XYEXExploreFeedViewController 0x12b896800&gt;, state: appeared, view: &lt;UIView: 0x12aae9d10&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    | &lt;XYEXExploreFeedChannelViewController 0x12a0bd400&gt;, state: appeared, view: &lt;UIView: 0x134441410&gt;</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12b060400&gt;, state: disappeared, view: &lt;UILayoutContainerView: 0x12ae3a270&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYVideoTab.VideoTabFeedInterface 0x134439580&gt;, state: disappeared, view: &lt;UIView: 0x12aad57c0&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12a0fbc00&gt;, state: disappeared, view: &lt;UILayoutContainerView: 0x12ae2e830&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYPMMessageCenterViewController 0x12d069400&gt;, state: disappeared, view: (view not loaded)</span></span><br><span class="line"><span class="string">   |    |    | &lt;XYPHNavigationViewController 0x12a0c4000&gt;, state: disappeared, view: &lt;UILayoutContainerView: 0x12ae2e9d0&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;XYPFProfileViewController 0x12b057800&gt;, state: disappeared, view: (view not loaded)</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果来看，小红书的根控制器层次结构还是有点奇怪的，导航控制器嵌入了 TabbarController，然后 TabbarController 的每个子控制器又是导航控制器。。。</p>
<p>这种方式属于通过 lldb 进行汇编级别的动态 hook 绕过反调试。这种动态的方式无法随时在需要的时候附加到目标进程，因为目标进程的反调试代码已经执行了。优点是不需要对 APP MachO 文件进行修改，不需要重新签名打包安装。后面的抖音反反调试是通过静态修改 MachO 文件内容进行的。</p>
<h3 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h3><p>支付宝最新版 10.7.50 直接使用 xia0LLDB 的 debugme 就可以绕过了，甚至连 svc 指令都没有，但是的确做了反调试。就不多说了。</p>
<h2 id="静态绕过反调试"><a href="#静态绕过反调试" class="headerlink" title="静态绕过反调试"></a>静态绕过反调试</h2><h3 id="抖音"><a href="#抖音" class="headerlink" title="抖音"></a>抖音</h3><p>这里同样以作者写作时的抖音最新版本 34.7.0 为例。如果继续使用 xia0LLDB 对抖音进行反调试绕过的话，首先会发现 xia0LLDB 无法读取到 Aweme 和 AwemeCore 两个 MachO 的代码段地址，扫描结果都是 0 到 0。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(lldb) debugme</span><br><span class="line">[*] start patch ptrace funtion to bypass anti debug</span><br><span class="line">[+] ptrace funtion patach <span class="keyword">done</span></span><br><span class="line">[*] start patch svc ins to bypass anti debug</span><br><span class="line">[+] use <span class="string">&quot;target list&quot;</span> to get main module:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] app <span class="built_in">dir</span>:/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] text start:0x0000000000000000 end:0x0000000000000000</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore</span></span><br><span class="line"><span class="string">[*] text start:0x0000000000000000 end:0x0000000000000000</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/BDLRepairer.framework/BDLRepairer</span><br><span class="line">[*] text start:0x0000000105323e68 end:0x0000000105323ef0</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/ByteRTCNICOExtension.framework/ByteRTCNICOExtension</span></span><br><span class="line"><span class="string">[*] text start:0x00000001053d0000 end:0x0000000105445f74</span></span><br><span class="line"><span class="string">------&gt; &lt;object returned empty description&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] not found svc ins, so don&#x27;</span>t need patch</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这就非常奇怪了，那么先开始分析 MachO 文件，这里可以使用 MachOView 查看 MachO 的 Load Command 发现，要么是不存在 __TEXT,__text 段，要么就是即便存在，但是 size 为 0。这就导致 debugme 根本无法扫描到代码段内存地址范围。但是会发现存在一个额外的 __BD_TEXT,__text 段，这个段里面都是汇编代码，看来抖音是在这里做了一定的防护。首先是 Aweme 的分析</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_1.png" class="">

<p>然后是 AwemeCore 的分析：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_2.png" class="">

<p>到此我们可以重新查看 debugme 的扫描代码段的代码 get_text_segment() 方法，新增以下逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(ncmds--) &#123;</span><br><span class="line">     /* go through <span class="built_in">all</span> load command to find __TEXT segment*/</span><br><span class="line">     struct load_command * lcp = (struct load_command *)((uint8_t*)header + x_offset);</span><br><span class="line">     x_offset += lcp-&gt;cmdsize;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(lcp-&gt;cmd == LC_SEGMENT_64) &#123;</span><br><span class="line">         struct segment_command_64 * curSegment = (struct segment_command_64 *)lcp;</span><br><span class="line">         struct section_64* curSection = (struct section_64*)((uint8_t*)curSegment + sizeof(struct segment_command_64));</span><br><span class="line">         </span><br><span class="line">         // check current section of segment <span class="keyword">is</span> __TEXT?</span><br><span class="line">         <span class="keyword">if</span>(!strcmp(curSection-&gt;segname, <span class="string">&quot;__TEXT&quot;</span>) &amp;&amp; !strcmp(curSection-&gt;sectname, <span class="string">&quot;__text&quot;</span>) &amp;&amp; curSection-&gt;size != <span class="number">0</span>)&#123;</span><br><span class="line">             uint64_t memAddr = curSection-&gt;addr;</span><br><span class="line">            </span><br><span class="line">             textStart = memAddr + (uint64_t)_dyld_get_image_vmaddr_slide(image_index);</span><br><span class="line">             textEnd = textStart + curSection-&gt;size;</span><br><span class="line">             /*</span><br><span class="line">             [retStr appendString:@<span class="string">&quot; &quot;</span>];</span><br><span class="line">             [retStr appendString:(<span class="built_in">id</span>)[@(textStart) stringValue]];</span><br><span class="line">             [retStr appendString:@<span class="string">&quot; , &quot;</span>];</span><br><span class="line">             [retStr appendString:(<span class="built_in">id</span>)[@(textEnd) stringValue]];</span><br><span class="line">             */</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         /*</span><br><span class="line">         针对 Aweme 中 __TEXT,__text 不存在或者即使存在也没有大小的情况这里增加使用 __BD_TEXT,__text </span><br><span class="line">         虽然 svc 指令都找到了,但是依旧无法绕过反调试,还需要进一步分析...初步分析是hook代码破坏了原始代码的结构。。。这里还是先注释了吧</span><br><span class="line">*/</span><br><span class="line">         <span class="keyword">if</span> (!strcmp(curSection-&gt;segname, <span class="string">&quot;__BD_TEXT&quot;</span>) &amp;&amp; !strcmp(curSection-&gt;sectname, <span class="string">&quot;__text&quot;</span>) &amp;&amp; curSection-&gt;size != <span class="number">0</span>) &#123;</span><br><span class="line">             uint64_t memAddr = curSection-&gt;addr;</span><br><span class="line">             textStart = memAddr + (uint64_t)_dyld_get_image_vmaddr_slide(image_index);</span><br><span class="line">             textEnd = textStart + curSection-&gt;size;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样就能在使用 debugme 的时候扫描到代码段了，而且扫描出来的 svc 指令调用的地方可真不少。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) debugme</span><br><span class="line">[*] start patch ptrace funtion to bypass anti debug</span><br><span class="line">[+] ptrace funtion patach <span class="keyword">done</span></span><br><span class="line">[*] start patch svc ins to bypass anti debug</span><br><span class="line">[+] use <span class="string">&quot;target list&quot;</span> to get main module:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] app <span class="built_in">dir</span>:/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app</span><br><span class="line">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Aweme</span><br><span class="line">[*] text start:0x0000000104d90000 end:0x0000000104d97e08</span><br><span class="line">------&gt; &lt;object returned empty description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] not found svc ins, so don<span class="string">&#x27;t need patch</span></span><br><span class="line"><span class="string">[*] search svc from:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore</span></span><br><span class="line"><span class="string">[*] text start:0x0000000139638000 end:0x0000000157814b1c</span></span><br><span class="line"><span class="string">------&gt;  5258500616 5258500744 5399496488 5399652708 5399653492 5399660936 5399665264 5399668140 5399668572 5399679616 5399679704 5399679720 5399679856 5399680700 5399683596 5399683628 5399683644 5399683660 5399727432 5399727576 5399728352 5399728584 5399729028 5399729760 5399730068 5399730552 5399730736 5399730840 5399730976 5399731080 5399731340 5399746168 5399764228 5399767088 5399780608 5399840652 5399841164 5399842344 5399875652 5399877380 5399877512 5399877768 5399877900 5399878792 5399878924 5399879272 5399879400 5399879996 5399880120 5399880548 5399880672 5399883864 5399884032 5399885580 5399886116 5399886248 5399886500 5399888308 5399891000 5399900344 5399900936 5399901060 5399901300 5399901432 5399916064 5399916236 5399917056 5399917196 5399920256 5399920804 5399927376 5399934216 5399948220 5399948480 5399950216 5399968700 5399968868 5399969008 5399969316 5399969456 5399969956 5399970808 5399970920 5399971064 5399971196 5399972004 5399973804 5399974480 5399975036 5399975156 5399975680 5399977044 5399977332 5399977912 5399978976 5399979096 5399980092 5400014396 5400045444 5400046372 5400077856 5400092792 5400117400 5400117832 5400123672 5400130960 5400132620 5400144476 5400150292 5400157820 5400159948 5400172524 5400173176 5400181328 5400248688 5400248832 5400250696 5400254644 5400260284 5400300644 5400306152 5400320308 5400362148 5400362616 5400369700 5400370396 5400372020 5400372704 5400374128 5400383844 5400461880 5400462020 5435622100 5435622120 5435622140 5435622160 5435622180 5435622200 5435622220 5535057976 5535058272</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x1396e5a08</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x1396e5a08 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x1396e5a88</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x1396e5a88 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x141d5c728</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x141d5c728 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x141d82964</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x141d82964 done</span></span><br><span class="line"><span class="string">[*] start hook svc at address:0x141d82c74</span></span><br><span class="line"><span class="string">[+] hook svc at address:0x141d82c74 done</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>svc 指令地址是扫描出来了，但结果还是无法成功绕过反调试。初步分析是 hook 代码破坏了原始汇编代码的结构，这么多地方（估计100到200个左右）一个个分析起来头都要炸了。。。我们还是另辟蹊径吧。既然这种动态 hook 的方式比较困难，我们就尝试静态分析一番。</p>
<p>首先 Aweme 的大小就很奇怪，只有 178 KB，这显然不是一个正常的应用应该有的大小，打开 hooper 分析一番。可执行文件的 MachO 都存在着入口函数，分析入口函数汇编代码：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_3.png" class="">

<p>直接无条件跳转到 <code>imp___stubs__awemeMain</code> 去了，双击跟进去。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_4.png" class="">

<p>这里的汇编显示，br 到寄存器 x16，而寄存器 x16 又是从 <code>_awemeMain</code> 加载的。那么继续双击 <code>_awemeMain</code> 就发现了它是一个声明在 <code>@rpath/AwemeCore.framework/AwemeCore</code> 的函数。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_5.png" class="">

<p>这下就可以确定了抖音的 APP 包下的 Aweme 只是一个壳，真正的主程序代码全部都写在了一个 AwemeCore 的 Framework 下。那么接下来要做的就是继续分析 AwemeCore 这个文件。但是这个文件太大了，629.9 MB，作者的电脑使用 hopper 完全吃不消这个文件。没关系，反汇编工具那么多，电脑升级不了就换个工具试试，作者这里使用的是 Ghidra。</p>
<p>使用 Ghidra 搜索 <code>_awemeMain</code>，可以看到关联的汇编代码，可以看到一个很熟悉的 svc 指令调用。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_6.png" class="">

<p>参数分别是 x0 &#x3D; 26, x1 &#x3D; 31。在 sys&#x2F;syscall.h 头文件中可以看到 26 是 SYS_ptrace 调用，而 SYS_ptrace 的参数 31 则是 PT_DENY_ATTACH 正是反调试的系统调用。</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_7.png" class="">

<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_8.png" class="">

<p>入口函数就是一个反调试，那么我们就先干掉这个反调试试试看。使用 nop 指令替换 svc 指令，使用方法是选择 svc 指令所在的行，右键 patch instruction 输入 nop 就完成了，如下：</p>
<img src="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/Snip20250625_9.png" class="">

<p>完成替换之后，我们重新导出可执行文件，步骤是 File -&gt; Export Program。格式选择 original file，记得勾选 Export User Byte Modifications 不然修改没有保存。保存之后我们替换 iPhone 上的 AwemeCore，可以备份一下原始的 AwemeCore。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iPhone8plus:/private/var/containers/Bundle/Application/4D2A141E-A8E7-429D-AF16-47DEBE3E01C1/Aweme.app/Frameworks/AwemeCore.framework root# <span class="built_in">ls</span></span><br><span class="line">AwemeCore  AwemeCoreBackup  Info.plist  SC_Info/  _CodeSignature/</span><br></pre></td></tr></table></figure>

<p>这个时候我们可以重启手机一下 iPhone，因为有可能 APP 的 Framework 会被缓存下来，导致没有使用我们修改后的 AwemeCore 文件。重启之后，再次使用 debugserver+lldb 远程调试会发现可以成功附加调试了~~~</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iPhone8plus:~ root# debugserver localhost:3333 --attach=Aweme</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-16.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process Aweme...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) pcc</span><br><span class="line">Process 3322 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000001c9ca5030 libsystem_kernel.dylib` mach_msg2_trap  + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg2_trap:</span><br><span class="line">-&gt;  0x1c9ca5030 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;macx_swapon:    0x1c9ca5034 &lt;+0&gt;: mov    x16, #-0x30 ; =-48</span></span><br><span class="line"><span class="string">    0x1c9ca5038 &lt;+4&gt;: svc    #0x80</span></span><br><span class="line"><span class="string">    0x1c9ca503c &lt;+8&gt;: ret</span></span><br><span class="line"><span class="string">libsystem_kernel.dylib&#x27;</span>macx_swapoff:    0x1c9ca5040 &lt;+0&gt;: mov    x16, <span class="comment">#-0x31 ; =-49</span></span><br><span class="line">    0x1c9ca5044 &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x1c9ca5048 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;thread_get_special_reply_port:    0x1c9ca504c &lt;+0&gt;: mov    x16, #-0x32 ; =-50</span></span><br><span class="line"><span class="string">Target 0: (Aweme) stopped.</span></span><br><span class="line"><span class="string">(lldb) pvc</span></span><br><span class="line"><span class="string">&lt;AWENormalModeTabBarController 0x104a56600&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x11c53c320&gt;</span></span><br><span class="line"><span class="string">   | &lt;AWEBaseRootNavigationController 0x103a7e800&gt;, state: appeared, view: &lt;UILayoutContainerView: 0x11c593240&gt;</span></span><br><span class="line"><span class="string">   |    | &lt;AWEFeedRootViewController 0x107b22140&gt;, state: appeared, view: &lt;UIView: 0x107a1bc00&gt;</span></span><br><span class="line"><span class="string">   |    |    | &lt;AWEFeedContainerViewController 0x10902fe00&gt;, state: appeared, view: &lt;UIView: 0x10126ecb0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    | &lt;AWEFeedSlidingViewController 0x103a7a600&gt;, state: appeared, view: &lt;UIView: 0x11c4e38d0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    | &lt;AWEHPXTabChannelViewController 0x10128de70&gt;, state: appeared, view: &lt;UIView: 0x11c5cf180&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    | &lt;AWEHPChannelPageViewController 0x104a7ca00&gt;, state: appeared, view: &lt;UIView: 0x11c5843c0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    | &lt;AWEFeedTableViewController 0x104aef200&gt;, state: appeared, view: &lt;UIView: 0x11c5cd5a0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    | &lt;AWEFeedCellViewController 0x104e7c000&gt;, state: appeared, view: &lt;UIView: 0x107512080&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    | &lt;RichContentContainerViewController 0x104c4da00&gt;, state: appeared, view: &lt;UIView: 0x1075ab1b0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    |    | &lt;AWEFriendsImpl.RichContentNewListViewController 0x104e98200&gt;, state: appeared, view: &lt;UIView: 0x107538cc0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    |    |    | &lt;AWEAwemePlayVideoViewController 0x103b0d000&gt;, state: appeared, view: &lt;UIView: 0x11c4cca20&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    |    |    | &lt;AWEPlayInteractionViewController 0x104e4fa00&gt;, state: appeared, view: &lt;UIView: 0x10751d0e0&gt;</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    | &lt;AWEFeedCellViewController 0x103d4f400&gt;, state: disappeared, view: &lt;UIView: 0x107b4a010&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    | &lt;AWEDPlayerFeedPlayerViewController 0x1248d0c00&gt;, state: disappeared, view: &lt;UIView: 0x1075cac30&gt; not in the window</span></span><br><span class="line"><span class="string">   |    |    |    |    |    |    |    |    | &lt;AWEPlayInteractionViewController 0x103dc4000&gt;, state: disappeared, view: &lt;UIView: 0x11c54abd0&gt; not in the window</span></span><br><span class="line"><span class="string">   + &lt;DUXAlertDialog 0x103c54600&gt;, state: appeared, view: &lt;UIView: 0x125382f80&gt;, presented with: &lt;DUXAlertDialogPresentationController: 0x125011af0&gt;</span></span><br><span class="line"><span class="string">(lldb)  </span></span><br></pre></td></tr></table></figure>

<p>到此，我们就通过修改 MachO 文件的汇编指令实现了反调试绕过。其实一般来说，在 iOS 平台，对二进制的修改之后需要重新进行签名才能正常运行，但是经过实践证明，iOS 系统在启动 APP 的时候，应该只会对 APP 包内的第一层文件进行签名验证，而不会递归验证它的子目录，比如我们这里修改了 Framework 下的某个 MachO。如果修改的是 Aweme 的二进制文件，这个毫无疑问哪怕只要是改了一个字节都无法通过签名验证，肯定是无法启动的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://masterking.github.io">masterKing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://masterking.github.io/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/">https://masterking.github.io/2025/06/19/iOS反调试与反反调试/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://masterking.github.io" target="_blank">masterKing 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/">反调试</a><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/">反反调试</a><a class="post-meta__tags" href="/tags/%E5%B0%8F%E7%BA%A2%E4%B9%A6/">小红书</a><a class="post-meta__tags" href="/tags/%E6%8A%96%E9%9F%B3/">抖音</a><a class="post-meta__tags" href="/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/">支付宝</a></div><div class="post-share"><div class="social-share" data-image="/images/iOSReveseEngineeringAndSecurity1.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/08/Category/" title="Category"><img class="cover" src="/images/iOS_low-level_principles.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Category</div></div><div class="info-2"><div class="info-item-1">分类诞生的历史Objective-C 的分类（Category）语法并非随语言初始版本一同出现，而是随着语言发展逐步引入的重要特性。以下是关键时间线和技术背景分析： Objective-C 由 Brad Cox 和 Tom Love 在 1980 年代初基于 C 语言开发，旨在添加 Smalltalk 风格的面向对象特性。初始版本（1981年）​​ 仅包含核心的面向对象机制（如类、继承、消息...</div></div></div></a><a class="pagination-related" href="/2025/07/29/KVC/" title="KVC"><img class="cover" src="/images/iOS_low-level_principles.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">KVC</div></div><div class="info-2"><div class="info-item-1">我不知道有多少人像本人一样，n 年来查看过不知道多少次这个 KVC 文档，但是每次通篇读下来总是会遇到读不懂的地方，总是莫名其妙的出现一个章节完全不知道在讲什么东西，不论是用传统的 Google 翻译或者目前主流的 AI 翻译翻译了，也还是会遇到读起来狗屁不通的情况。  其实根本原因是原始文档就有问题，东拼西凑的一坨屎，有歧义，导致不论你是直译还是意译都是让人摸不着头脑的翻译，只能根据上下文...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86"><span class="toc-text">反调试原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ptrace"><span class="toc-text">ptrace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">主要应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">重要特点和注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptrace-%E7%9A%84%E5%8F%82%E6%95%B0%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">ptrace 的参数简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-iOS-%E4%B8%AD%E8%B0%83%E7%94%A8-ptrace-%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-text">在 iOS 中调用 ptrace 反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-extern"><span class="toc-text">1. 使用 extern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8-dlsym"><span class="toc-text">2. 利用 dlsym</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-syscall-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">3. 使用 syscall 的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">4. 使用内联汇编的方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysctl"><span class="toc-text">sysctl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-Unix-%E7%B3%BB%E7%BB%9F%EF%BC%88Linux-BSD%EF%BC%89%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E2%80%8B"><span class="toc-text">类 Unix 系统（Linux&#x2F;BSD）中的作用​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#macOS-%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7%E4%B8%8E%E9%99%90%E5%88%B6%E2%80%8B"><span class="toc-text">macOS 中的特殊性与限制​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS-%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E9%99%90%E5%88%B6%E2%80%8B"><span class="toc-text">iOS 中的严格限制​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-iOS-%E4%B8%AD%E4%BD%BF%E7%94%A8-sysctl-%E6%A3%80%E6%B5%8B%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E8%A2%AB%E8%B0%83%E8%AF%95"><span class="toc-text">在 iOS 中使用 sysctl 检测进程是否被调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#syscall"><span class="toc-text">syscall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%8D%E5%88%B6"><span class="toc-text">如何反制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-text">动态绕过反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BA%A2%E4%B9%A6"><span class="toc-text">小红书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E4%BB%98%E5%AE%9D"><span class="toc-text">支付宝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-text">静态绕过反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E9%9F%B3"><span class="toc-text">抖音</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/images/iOSReveseEngineeringAndSecurity1.webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2018 - 2025 By masterKing</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'Nj4rbGaJ3pAWBRJWseaRg9Zu-gzGzoHsz',
      appKey: '3tVispErrQeAytUHyJrFos3n',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>