<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>内存管理 | masterKing 的博客</title><meta name="author" content="masterKing"><meta name="copyright" content="masterKing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="相关面试题 使用 CADisplayLink、NSTimer 有什么注意点？ 强引用控制器导致控制器，定时器均无法正常释放的问题 依赖 RunLoop，如果 RunLoop 任务繁重可能出现定时器不准时的问题   介绍下内存的几大区域 讲一下你对 iOS 内存管理的理解 autorelease 对象在什么时机会被释放 方法里有局部对象，出了方法后会立即释放吗？ ARC 都帮我们做了什么？ weak">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="https://masterking.github.io/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="masterKing 的博客">
<meta property="og:description" content="相关面试题 使用 CADisplayLink、NSTimer 有什么注意点？ 强引用控制器导致控制器，定时器均无法正常释放的问题 依赖 RunLoop，如果 RunLoop 任务繁重可能出现定时器不准时的问题   介绍下内存的几大区域 讲一下你对 iOS 内存管理的理解 autorelease 对象在什么时机会被释放 方法里有局部对象，出了方法后会立即释放吗？ ARC 都帮我们做了什么？ weak">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://masterking.github.io/images/iOS_low-level_principles.webp">
<meta property="article:published_time" content="2025-05-14T21:51:38.000Z">
<meta property="article:modified_time" content="2025-05-26T12:41:02.688Z">
<meta property="article:author" content="masterKing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://masterking.github.io/images/iOS_low-level_principles.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "内存管理",
  "url": "https://masterking.github.io/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",
  "image": "https://masterking.github.io/images/iOS_low-level_principles.webp",
  "datePublished": "2025-05-14T21:51:38.000Z",
  "dateModified": "2025-05-26T12:41:02.688Z",
  "author": [
    {
      "@type": "Person",
      "name": "masterKing",
      "url": "https://masterking.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://masterking.github.io/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e6857234b462ad05308d8b79794f0358";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内存管理',
  isHighlightShrink: undefined,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient( 135deg, #2c241f, #968282);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/WechatIMG1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/sileorepo/"><i class="fa-fw fas fa-shop"></i><span> sileo 源</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/iOS_low-level_principles.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">masterKing 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">内存管理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/sileorepo/"><i class="fa-fw fas fa-shop"></i><span> sileo 源</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-14T21:51:38.000Z" title="发表于 2025-05-15 05:51:38">2025-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-26T12:41:02.688Z" title="更新于 2025-05-26 20:41:02">2025-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS 底层原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.9k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离上次更新已有&quot;,&quot;messageNext&quot;:&quot;天，文章某些内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-05-26 20:41:02&quot;}" hidden></div><h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><ul>
<li>使用 CADisplayLink、NSTimer 有什么注意点？<ul>
<li>强引用控制器导致控制器，定时器均无法正常释放的问题</li>
<li>依赖 RunLoop，如果 RunLoop 任务繁重可能出现定时器不准时的问题</li>
</ul>
</li>
<li>介绍下内存的几大区域</li>
<li>讲一下你对 iOS 内存管理的理解</li>
<li>autorelease 对象在什么时机会被释放</li>
<li>方法里有局部对象，出了方法后会立即释放吗？</li>
<li>ARC 都帮我们做了什么？</li>
<li>weak 指针的实现原理？</li>
</ul>
<hr>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>在使用 CADisplayLink 或 NSTimer 这类需要添加到 RunLoop 的定时器的时候，需要特别注意的是应用程序的主线程 RunLoop 生命周期是和应用同步的，它是常驻内存的。在这种情况下，如果定时器是重复执行的，就会出现 RunLoop 永远强引用着定时器，如果此时定时器还强引用着控制器，那么不论是否存在循环引用控制器都永远无法释放，即内存泄露。</p>
<blockquote>
<p>⚠️ 观察定时器是否正确释放方法：<br>与一般的类不同，NSTimer 被设计为类簇，它是一个对外的接口类，底层实际创建的并不是 NSTimer 实例，而是 __CFNSTimer 等其他底层类，即使我们新建一个类继承 NSTimer 并重写 dealloc 方法，也无法按预期执行。在运行时会报如下错误：<br><code>*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;*** initialization method -initWithFireDate:interval:target:selector:userInfo:repeats: cannot be sent to an abstract object of class MKTimer: Create a concrete instance!&#39;</code><br>在这种情况下，我们就需要另辟蹊径找到其他能够观察定时器释放的方法了。方法不止有一种，但我这里仅推荐一种方法：使用关联对象，给定时器添加一个关联对象，在关联对象的 dealloc 方法打印信息。这样在定时器释放的时候，我们的关联对象也会被释放，调用它的 dealloc 方法从而可以看到释放的时机。</p>
<p>CADisplayLink 虽然子类化之后运行时创建不会报错，但是调用 <code>+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel</code> 实际返回的实例对象也不是你自定义子类的实例，所以你的 dealloc 方法也不会被调用。依旧需要使用关联对象的方法来观察释放时间。</p>
</blockquote>
<h2 id="控制器无法释放的本质"><a href="#控制器无法释放的本质" class="headerlink" title="控制器无法释放的本质"></a>控制器无法释放的本质</h2><p>以下案例是一个新创建的 iOS 项目，仅对 ViewController 嵌入了一个导航控制器，正是为了演示 ViewController 从导航控制器栈中移除后能不能正常释放。这个案例对于有经验的 iOS 开发者来说应该不需要多说了吧。</p>
<img src="/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Snip20250515_1.png" class="">

<p>然后 ViewController 中的代码如下：</p>
<p>代码1：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，ViewController 对 NSTimer 存在一个强引用，同时 NSTimer 对 target 参数也存在着一个强引用。不过这个强引用隐藏的很深，没有一点的技术深度还真无法验证这个强引用在哪。。。我也在考虑要不要研究并发布出来，不过暂时还是算了，你记住 NSTimer 底层的确强引用着 target 就好了（其实可以通过 Xcode 的内存图看到）。。。但是造成 ViewController 无法释放的真正原因并不是它和定时器循环引用了。<strong>循环引用并不是一定会造成内存泄露。</strong></p>
<p>很多人可能对刚刚那句话不完全相信，那这样吧，我们看代码2，和代码3，看它们能不能解决循环引用的内存泄露？</p>
<p>代码2：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">MKTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:weakself selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码2这种情况并不能改变 NSTimer 内部对 target 的指针的强弱性质，NSTimer 内部对 target 的引用默认就是强的，__weak 根本无法修改 NSTimer 内部的代码实现。__weak 只有在搭配 Block 的时候，才能改变 Block 捕获外部变量时的强弱性质。所以这种写法也根本不可能解决 ViewController 无法释放的问题。</p>
<p>代码3：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">MKTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>如果按照循环引用一定产生内存泄露无法释放的说法的话，那么代码3就一定可以解决 ViewController 无法释放的问题了吧，ViewController 对 NSTimer 是弱引用，NSTimer 对 ViewController 是强引用，并没有产生循环引用啊，但是为什么 ViewController 还是无法释放呢？再看以下代码4：</p>
<p>代码4：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	<span class="comment">// 这种情况下，当前控制器从导航控制器栈中移除时能正常释放吗？</span></span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">MKTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码 4 中，ViewController 明明强引用着 NSTimer，而 NSTimer 的 target 也是强引用的。这不是循环引用了吗？怎么这个时候没有导致内存泄露，ViewController 退出之后也能正常释放呢？</p>
<p>其实根本原因是，NSTimer 和 CADisplayLink 这两种定时器都需要添加到 RunLoop 中运行，而且大多数情况下，这些定时器都被添加到了主线程的 RunLoop 中运行，而主线程的 RunLoop 在程序运行过程中一直存在，如果你看过我之前的 RunLoop 文章就会知道，RunLoop 有多种模式，每种模式都有一个定时器数组强引用着定时器，而这些定时器又强引用着控制器。在这种情况下，不论你定时器和控制器循环不循环引用都会导致 ViewController 无法释放。因为始终存在 RunLoop -&gt; 定时器 -&gt; 控制器。</p>
<p>而为什么代码 4 即使循环引用了，却还是能正常释放 ViewController 和 NSTimer 呢？关键在于代码 4 中的定时器不是永远重复的，它只执行一次。这样在定时器执行一次它的方法之后，RunLoop 就会将这个定时器从数组中移除，此时定时器依旧被 ViewController 强引用着，所以引用计数并不会归 0，就不会被释放。但是 RunLoop 移除定时器的时候，定时器必然也会对它强引用着的 ViewController 对象进行一次 release 调用。这个时候，ViewController 释放不释放同样取决于 ViewController 的引用计数是否为 0，如果退出了当前页面，ViewController 没有导航控制器等其他对象强引用着，引用计数归 0 的话，就会被释放内存，ViewController 在释放时也必然对它强引用着的 NSTimer 调用一次 release 操作，这样 NSTimer 也能顺利释放了。如果没有退出当前页面，也没有任何问题，定时器执行完，RunLoop 移除定时器时，定时器也会对它强引用的 ViewController 进行一个 release 操作，这样定时器对 ViewController 的强引用进行的引用计数加 1 操作也减回去了，退出 ViewController 页面的时候，引用着 ViewController 的对象正常内存管理就会导致 ViewController 引用计数减为 0 从而释放 ViewController。</p>
<p>所谓的强引用，弱引用本质并不会对引用计数产生变化，而是强引用的指针，在对它进行赋值的时候，会让该对象的引用计数加 1，而弱引用的指针就不会让指向的对象引用计数加 1。额就这样吧，也不知道有没有说清楚。。。</p>
<p>回到 ViewController 能否正常释放的问题来，在使用 NSTimer、CADisplayLink 这种需要添加到 RunLoop 的定时器时，对于不重复的定时器，还不不太需要操心内存管理问题的。但是对于需要重复的定时器而言，就需要特别注意内存管理问题了，不仅仅是 ViewController 的内存管理，还有定时器的内存管理，首先要保证 ViewController 能正常退出释放，其次 ViewController 在 dealloc 的时候要将定时器 invalidate，否则即使 ViewController 释放了定时器也无法释放。以下是一些解决方法：</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用-weak-和-block-API-解决"><a href="#使用-weak-和-block-API-解决" class="headerlink" title="使用 __weak 和 block API 解决"></a>使用 __weak 和 block API 解决</h3><p>直接看代码吧。。。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        [weakself timerFired:timer];</span><br><span class="line">    &#125;];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用带有 block 的定时器 API 的时候，配合 __weak 的使用，这样 NSTimer 就对 ViewController 不会产生强引用。ViewController 页面退出的时候就正常释放内存了，但是这个时候定时器还在 RunLoop 中，控制器都不存在了，定时器也没有必要继续存在了，就需要在 ViewController 的 dealloc 方法中对定时器调用 invalidate 方法，这个方法会让定时器从 RunLoop 中移除从而让定时器也能接着释放内存。</p>
<h3 id="使用中间层对象解决"><a href="#使用中间层对象解决" class="headerlink" title="使用中间层对象解决"></a>使用中间层对象解决</h3><p>中间层这种思想在软件开发领域好像是一个解决问题的规律，不知道是谁说的，但是的确蛮有道理的。通过使用中间层对象，让定时器强引用中间层对象，中间层弱引用控制器，同时中间层对象将定时器需要调用的方法转发给它弱引用的控制器，这样也能完美解决控制器的释放问题，和定时器的释放问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Proxy</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Proxy</span></span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须重写，否则可能会有逻辑错误，甚至导致崩溃的可能。</span></span><br><span class="line"><span class="comment">// 假设有这么一段代码 `[proxy respondsToSelector:@selector(someMethod)]`，本意是想判断 proxy 的 target 能否响应方法的，但是实际运行时只会查看 proxy 能否响应方法。</span></span><br><span class="line"><span class="comment">// 本意是对 Proxy 对象调用的所有方法，都应该交给他的 target 处理。对于一般的方法，就比如 timerFired: ，proxy 对象并没有实现，那么就通过消息转发给到了 target。</span></span><br><span class="line"><span class="comment">// 但是像 respondsToSelector: 这样的元方法因为 Proxy 继承自 NSObject 就并不会被转发给 target 了从而导致了逻辑上的错误，需要在 Proxy 中重写 respondsToSelector: 方法。</span></span><br><span class="line"><span class="comment">// 除了 respondsToSelector: 方法之外，还有其他元方法如 isKindOfClass:、description 等等方法都可能需要做类似得处理。</span></span><br><span class="line"><span class="comment">// 所以推荐继承自 NSProxy 而不是 NSObject，这里使用 NSObject 仅为了演示解决控制器无法释放的问题并不是只能由 NSProxy 的子类来解决。</span></span><br><span class="line">- (<span class="type">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target respondsToSelector:aSelector] || [<span class="variable language_">super</span> respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可能还需覆盖其他方法（如 description、isKindOfClass: 等）</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerDeallocWatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerDeallocWatcher</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;定时器已释放&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">	[<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">	Proxy *proxy = [Proxy alloc];</span><br><span class="line">	proxy.target = <span class="keyword">self</span>;</span><br><span class="line">	<span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:proxy selector:<span class="keyword">@selector</span>(timerFired:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">	objc_setAssociatedObject(<span class="keyword">self</span>.timer, <span class="string">&quot;kTimerDeallocWatcherKey&quot;</span>, [TimerDeallocWatcher new], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">	[<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>除了使用 NSObject 子类的方式，在 iOS 中，这种中间层对象的解决方式还有一个更加推荐的对象，即 NSProxy。对于简单的场景，使用 NSObject 没有什么问题，但是对于更加复杂的场景，以及从性能和安全角度考虑使用 NSProxy 子类会比使用 NSObject 子类更加合适。这种方式不仅仅是对 NSTimer 有效，同样也能解决 CADisplayLink 带来的问题。</p>
<p>在解决 CADisplayLink 和 NSTimer 重复定时器导致的内存问题时，推荐使用 NSProxy 子类而非 NSObject 子类，主要原因如下：</p>
<ol>
<li><p>​​高效的消息转发机制​</p>
<ul>
<li><strong>NSProxy 的纯粹性</strong>​​：NSProxy 是专门为消息转发设计的抽象基类，它本身不实现任何方法（除极少数必要方法外）。所有发送给 NSProxy 对象的消息都会直接进入消息转发流程（forwardInvocation: 和 methodSignatureForSelector:），无需像 NSObject 子类那样先逐级查找方法实现。</li>
<li><strong>NSObject 的冗余步骤</strong>​​：NSObject 子类在消息转发前会经历动态方法解析（resolveInstanceMethod:）和快速转发（forwardingTargetForSelector:）等步骤，导致额外的性能开销。对于高频触发的定时器（如 CADisplayLink 每秒 60 次回调），NSProxy 的短路径转发更高效。</li>
</ul>
</li>
<li><p>​​避免方法冲突与副作用​</p>
<ul>
<li><strong>无方法实现干扰​​</strong>：NSProxy 默认没有实现常见方法（如 respondsToSelector: 或 description），所有消息均被转发到目标对象。而 NSObject 子类可能因自身方法（如 class、isEqual:）导致意外行为，需额外处理这些方法的转发逻辑。</li>
<li><strong>干净的代理角色</strong>​​：NSProxy 作为纯粹的代理，不会因继承 NSObject 的复杂方法体系而产生歧义，确保所有调用都正确传递给目标对象。</li>
</ul>
</li>
<li><p>设计意图的契合性</p>
<ul>
<li><strong>代理模式的天然选择​​</strong>：NSProxy 的设计初衷即为代理对象提供轻量级、专注的转发能力，符合通过中间对象打破循环引用的场景需求。而 NSObject 作为通用基类，承担了更多与对象生命周期、键值观察等无关职责，逻辑上不够契合。</li>
</ul>
</li>
<li><p>减少代码复杂性​</p>
<ul>
<li><strong>简化实现​​</strong>：使用 NSProxy 子类通常只需实现 methodSignatureForSelector: 和 forwardInvocation: 即可完成消息转发。而 NSObject 子类可能需要覆盖更多方法（如 respondsToSelector:）以确保行为正确，增加代码复杂度。</li>
</ul>
</li>
</ol>
<p>使用 NSProxy 子类解决内存问题的示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakProxy</span></span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.target respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-GCD-的定时器"><a href="#使用-GCD-的定时器" class="headerlink" title="使用 GCD 的定时器"></a>使用 GCD 的定时器</h3><p>除了以上两种方式，我们知道问题就在于这两种定时器依赖 RunLoop 才能运行。如果使用不依赖 RunLoop 的 GCD 定时器，也可以解决控制器无法释放的问题。而且 RunLoop 本身如果任务过于繁重的话，就可能导致基于 RunLoop 的定时器执行间隔不准确，所以在一些特定的情况下，可以使用 GCD 定时器替代 NSTimer 定时器。但是也并不是说使用 GCD 的定时器就没有内存管理的问题了。该注意的地方还是要注意。</p>
<h4 id="直接使用-GCD-定时器"><a href="#直接使用-GCD-定时器" class="headerlink" title="直接使用 GCD 定时器"></a>直接使用 GCD 定时器</h4><p>完全自己创建 GCD 的定时器需要不少代码，好在 Xcode 的代码块功能已经自带了 GCD 定时器的代码块。输入 <code>dispatch_source</code> 应该会有提示，回车就可以，不过系统自带的这个代码块几个参数不好填。可以复制修改一下为自己的代码块，以下是我修改后的 GCD 定时器代码块。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, &lt;#dispatchQueue#&gt;);</span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, &lt;#afterInSeconds#&gt; * <span class="built_in">NSEC_PER_SEC</span>), &lt;#intervalInSeconds#&gt; * <span class="built_in">NSEC_PER_SEC</span>, &lt;#leewayInSeconds#&gt; * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    &lt;<span class="meta">#code to be executed when timer fires#&gt;</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_activate(timer);</span><br></pre></td></tr></table></figure>

<p>以下是填完参数之后的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// dispatchQueue 这个队列，使用过 GCD 的都不陌生了，主队列，全局并发队列选一个就好</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="comment">// 第一个参数是上面创建的 timer，</span></span><br><span class="line">    <span class="comment">// 第二个参数是定时器第一次调用的时间，这里传的时当前时间的多少秒之后。</span></span><br><span class="line">    <span class="comment">// 第三个参数是调用的时间间隔，单位也改用秒了。</span></span><br><span class="line">    <span class="comment">// 第四个参数是误差，单位也改成秒了，可以填 0，若无需极端精度，建议设置合理误差（如 0.1 * NSEC_PER_SEC），以降低系统负载。</span></span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>), <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,%@&quot;</span>, weakself, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_activate(timer);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>启动 APP，进入 ViewController 所在页面只看到了打印 <code>-[ViewController viewDidLoad]</code>，这是因为 timer 作为一个局部变量如果没有强引用持有它，ARC 可能在对象超出作用域后释放它，导致定时器提取释放。同时在不需要定时器的时候需要手动调用 <code>dispatch_source_cancel()</code> 取消定时器。所以正确的用法应该如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>), <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,%@&quot;</span>, weakself, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_activate(timer);</span><br><span class="line">    <span class="keyword">self</span>.timer = timer;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>进入页面 2 秒后启动定时器，每间隔 1 秒执行定时器方法，退出页面后控制器能正常释放，定时器也能正常销毁。</p>
<h4 id="封装-GCD-定时器"><a href="#封装-GCD-定时器" class="headerlink" title="封装 GCD 定时器"></a>封装 GCD 定时器</h4><p>直接使用 GCD 可能看起来代码较多，可以自己封装一个小型的定时器工具类，使用 GCD 实现。方便以后使用。以下是源码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MKTimer</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="keyword">nonnull</span> <span class="type">void</span> (^)(<span class="type">void</span>))task startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTarget:(<span class="type">id</span>)target selector:(SEL)selector startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async;</span><br><span class="line">+ (<span class="type">void</span>)cancelTimer:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *_GCDTimers;</span><br><span class="line">dispatch_semaphore_t _semaphore;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MKTimer</span></span></span><br><span class="line">+ (<span class="type">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="built_in">MKTimer</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            _GCDTimers = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">            _semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTask:(<span class="type">void</span> (^)(<span class="type">void</span>))task startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async &#123;</span><br><span class="line">    <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;task 不能为 nil&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (after &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;after 无法小于 0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (interval &lt;= <span class="number">0</span> &amp;&amp; repeats == <span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;interval 需要大于 0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = async ? dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>) : dispatch_get_main_queue();</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    dispatch_source_set_timer(timer,</span><br><span class="line">                              dispatch_time(DISPATCH_TIME_NOW, after * <span class="built_in">NSEC_PER_SEC</span>),</span><br><span class="line">                              interval * <span class="built_in">NSEC_PER_SEC</span>,</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%zd&quot;</span>, _GCDTimers.count];</span><br><span class="line">    _GCDTimers[key] = timer;</span><br><span class="line">    dispatch_semaphore_signal(_semaphore);</span><br><span class="line">    dispatch_block_t block = ^&#123;</span><br><span class="line">        task();</span><br><span class="line">        <span class="keyword">if</span> (repeats == <span class="literal">NO</span>) &#123;</span><br><span class="line">            [weakself cancelTimer:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dispatch_source_set_event_handler(timer, block);</span><br><span class="line">    dispatch_activate(timer);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)execTarget:(<span class="type">id</span>)target selector:(SEL)sel startAfter:(<span class="built_in">NSTimeInterval</span>)after interval:(<span class="built_in">NSTimeInterval</span>)interval repeats:(<span class="type">BOOL</span>)repeats async:(<span class="type">BOOL</span>)async &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target || !sel) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(target) <span class="keyword">weak</span> = target;</span><br><span class="line">    <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">weak</span> respondsToSelector:sel]) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">            [<span class="keyword">weak</span> performSelector:sel];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> execTask:block startAfter:after interval:interval repeats:repeats async:async];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)cancelTimer:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    dispatch_source_t timer = _GCDTimers[key];</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timer);</span><br><span class="line">        [_GCDTimers removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(_semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 ViewController 中的使用方式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">// 使用 Block 的 API</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">self</span>.key = [<span class="built_in">MKTimer</span> execTask:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@&quot;</span>, weakself, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125; startAfter:<span class="number">2</span> interval:<span class="number">1</span> repeats:<span class="literal">YES</span> async:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;   <span class="comment">// 使用 target selector 的 API</span></span><br><span class="line">        <span class="keyword">self</span>.key = [<span class="built_in">MKTimer</span> execTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFired) startAfter:<span class="number">2</span> interval:<span class="number">1</span> repeats:<span class="literal">YES</span> async:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)timerFired&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@&quot;</span>, <span class="keyword">self</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="built_in">MKTimer</span> cancelTimer:<span class="keyword">self</span>.key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<hr>
<h1 id="iOS-应用内存布局"><a href="#iOS-应用内存布局" class="headerlink" title="iOS 应用内存布局"></a>iOS 应用内存布局</h1><p>如下图：</p>
<img src="/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Snip20250519_2.png" class="">

<p>可以在 iOS 项目中打印不同类型的变量进行验证。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> d;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj1 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSObject</span> *obj2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;\n&amp;a=%p\n&amp;b=%p\n&amp;c=%p\n&amp;d=%p\n&amp;e=%p\n&amp;f=%p\nstr=%p\nobj1=%p\nobj2=%p\n&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,str,obj1,obj2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>实际打印的结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;a=<span class="number">0x100481250</span></span><br><span class="line">&amp;b=<span class="number">0x10048125c</span></span><br><span class="line">&amp;c=<span class="number">0x100481254</span></span><br><span class="line">&amp;d=<span class="number">0x100481258</span></span><br><span class="line">&amp;e=<span class="number">0x16f98713c</span></span><br><span class="line">&amp;f=<span class="number">0x16f987138</span></span><br><span class="line">str=<span class="number">0x10047c098</span></span><br><span class="line">obj1=<span class="number">0x281c98090</span></span><br><span class="line">obj2=<span class="number">0x281c980b0</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果来看，有些结果会让人有点意外。首先a，b，c，d，str 的地址都能够理解，不论是全局变量，静态变量，还是字符串常量都在一块应该都是在数据区。但是局部变量 e，f 的地址在栈上是应该大于对象 obj1，obj2 所在的堆区地址的。但是这里却出现了堆区地址大于栈区地址的现象很是奇怪。抛开这点不谈，通过两个同区域变量的地址对比，如 e 的地址大于 f 的地址，说明栈的生长方向随着使用在变小是没错的。obj1 的地址小于 obj2 的地址，说明堆的生长方向随着使用在变大也是没错的。</p>
<p>最奇怪的是为什么栈的地址比堆的地址小了？</p>
<p>这里的原因是，iOS 中的一种叫 ASLR 的安全技术导致。</p>
<h2 id="什么是-ASLR-？"><a href="#什么是-ASLR-？" class="headerlink" title="什么是 ASLR ？"></a>什么是 ASLR ？</h2><p><strong>ASLR（Address Space Layout Randomization，地址空间布局随机化）</strong>​​ 是一种操作系统级别的安全技术，核心目的是 ​​<strong>让程序的内存布局变得不可预测​​</strong>，从而增加攻击者利用内存漏洞（如缓冲区溢出）的难度。它通过 ​​<strong>随机化程序内存区域的起始地址</strong>​​ 来实现这一点。</p>
<h2 id="ASLR-的作用原理"><a href="#ASLR-的作用原理" class="headerlink" title="ASLR 的作用原理"></a>ASLR 的作用原理</h2><ol>
<li>传统内存布局的问题<br>  在没有 ASLR 时，程序的代码段、数据段、堆、栈等内存区域的起始地址是固定的。例如：<ul>
<li>代码段总是从 0x100000000 开始。</li>
<li>栈总是从 0x7FFF00000000 开始。<br> 攻击者可以提前知道这些地址，从而精准构造攻击代码。</li>
</ul>
</li>
<li>ASLR 的解决方案<br> ASLR 在程序启动时，为每个内存区域分配一个 ​​随机的基址偏移量​​。例如：<ul>
<li>代码段可能从 0x12345000000 开始。</li>
<li>栈可能从 0x7F12F0000000 开始。<br> 每次运行程序时，这些地址都会变化，攻击者无法提前预测。</li>
</ul>
</li>
</ol>
<h2 id="静态变量的作用域"><a href="#静态变量的作用域" class="headerlink" title="静态变量的作用域"></a>静态变量的作用域</h2><p>先看以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">    count = <span class="number">2000</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">    [Person sleep];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">    [[Person new] eat];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p %zd&quot;</span>, &amp;count, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>然后是 Person 的头文件和实现文件代码：</p>
<p>Person.h</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> count = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)eat;</span><br><span class="line">+ (<span class="type">void</span>)sleep;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>Person.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)eat &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s, %p, %zd&quot;</span>, __func__, &amp;count, count);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)sleep &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s, %p, %zd&quot;</span>, __func__, &amp;count, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 ViewController 的 viewDidLoad 方法中，实际的打印结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">1000</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">2001</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] +[Person sleep], <span class="number">0x104715e38</span>, <span class="number">1001</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">2001</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] -[Person eat], <span class="number">0x104715e38</span>, <span class="number">1002</span></span><br><span class="line">demoiOSApp[<span class="number">26641</span>:<span class="number">23464211</span>] <span class="number">0x104715fc0</span> <span class="number">2001</span></span><br></pre></td></tr></table></figure>

<p>可以看到在 ViewController 中的确可以访问并修改全局静态变量 count。但是在 ViewController 内的修改并不会影响 Person 类中的 count。这是因为 static 全局变量在每个包含它的​​编译单元（实现文件）​​中生成独立副本。作用域仅限于​​当前编译单元​​（文件），对其他文件不可见。</p>
<p>而在头文件声明 static 变量的用法看似“全局”，实际是每个文件独立持有。虽然合法但不推荐使用（容易导致代码冗余和误解）。推荐在实现文件中定义 static 变量，头文件中声明为 extern（若需跨文件访问）。</p>
<hr>
<h1 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h1><h2 id="什么是-Tagged-Pointer"><a href="#什么是-Tagged-Pointer" class="headerlink" title="什么是 Tagged Pointer"></a>什么是 Tagged Pointer</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul>
<li><strong>指针与标记结合</strong>​​：Tagged Pointer 在存储内存地址的同时，利用未使用的位存储额外信息（如类型标签或小型数据）。</li>
<li><strong>目的​​</strong>：减少小对象的内存分配开销，加速类型检查或数据访问。</li>
</ul>
<h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2.实现原理"></a>2.实现原理</h3><ul>
<li><strong>位利用</strong>​​：在 64 位系统中，指针通常占用 8 字节（即 64 位），但实际地址可能未使用全部高位。这些空闲位用于存储标记。</li>
<li><strong>标记位识别</strong>​​：通常通过特定位（如最低有效位）标识是否为 Tagged Pointer。例如，最低位为 1 表示标记指针，为 0 则为普通指针。</li>
</ul>
<h3 id="3-常见应用场景"><a href="#3-常见应用场景" class="headerlink" title="3.常见应用场景"></a>3.常见应用场景</h3><ul>
<li><strong>小对象优化</strong>​​：如 Objective-C 的 NSNumber 或 NSString，直接将小数值存储在指针中，避免堆内存分配。</li>
<li>​​<strong>类型快速判断</strong>​​：通过标签位区分数据类型，减少动态类型检查的开销。</li>
<li><strong>垃圾回收</strong>​​：辅助垃圾回收器识别指针类型，提升效率。</li>
</ul>
<h3 id="4-计数细节"><a href="#4-计数细节" class="headerlink" title="4.计数细节"></a>4.计数细节</h3><ul>
<li><strong>位分配策略</strong>​​：不同系统&#x2F;语言实现不同。例如，某些系统使用高位存储标签，某些使用低位。</li>
<li><strong>数据存储​​</strong>：若标签指示数据直接存储，剩余位存储实际值（如整数、浮点数）。</li>
<li><strong>内存对齐</strong>​​：确保普通指针地址对齐，使空闲位可预测（如地址总是 4&#x2F;8 字节对齐）。</li>
</ul>
<h3 id="5-优点"><a href="#5-优点" class="headerlink" title="5.优点"></a>5.优点</h3><ul>
<li><strong>内存节省</strong>​​：避免小对象的堆分配，减少内存碎片。</li>
<li><strong>性能提升</strong>​​：减少间接访问（如解引用指针），加速类型检查和数据操作。</li>
<li><strong>​​缓存友好​​</strong>：数据直接存储在指针中，提高缓存局部性。</li>
</ul>
<h3 id="6-限制与挑战​"><a href="#6-限制与挑战​" class="headerlink" title="6.限制与挑战​"></a>6.限制与挑战​</h3><ul>
<li>​​<strong>存储限制​​</strong>：可用位数限制直接存储数据的大小（如 64 位中可能仅存 60 位有效数据）。</li>
<li><strong>兼容性​​</strong>：需确保标记位不与实际地址冲突，依赖运行时或操作系统的内存管理。</li>
<li><strong>调试复杂性</strong>​​：指针值包含元数据，需工具解析以方便调试。</li>
</ul>
<h3 id="7-示例与类比​"><a href="#7-示例与类比​" class="headerlink" title="7.示例与类比​"></a>7.示例与类比​</h3><ul>
<li><strong>Objective-C&#x2F;Swift</strong>​​：使用 Tagged Pointer 优化 NSNumber、NSDate 等对象。</li>
<li><strong>NaN Boxing</strong>​​：类似技术，利用浮点数的 NaN 空间存储类型信息（如JavaScript引擎）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Tagged Pointer 是一种高效利用指针空间的技术，通过在地址中嵌入元数据或数据，优化内存和性能。其实现需精细设计位布局，并确保与系统内存管理的兼容性，广泛应用于动态语言运行时和高效内存管理的场景。</p>
<h2 id="iOS-中的-Tagged-Pointer"><a href="#iOS-中的-Tagged-Pointer" class="headerlink" title="iOS 中的 Tagged Pointer"></a>iOS 中的 Tagged Pointer</h2><p>iOS 的 Tagged Pointer 是在 iOS 7（2013年）中引入的​​，与 iPhone 5s 的 64 位 A7 芯片的发布同步。以下是详细背景和关键点：</p>
<h3 id="1-引入背景"><a href="#1-引入背景" class="headerlink" title="1.引入背景"></a>1.引入背景</h3><ul>
<li>64 位架构的普及​​：<br>  iPhone 5s（2013年）首次搭载 64 位 A7 芯片，iOS 7 开始全面支持 64 位应用。64 位指针的地址空间远超出实际物理内存需求，​​高位空闲的指针位​​为 Tagged Pointer 提供了存储额外数据的空间。</li>
<li>性能优化需求​​：<br>  Apple 希望通过减少小对象（如 NSNumber、NSDate、短 NSString）的堆内存分配和访问开销，提升运行效率。</li>
</ul>
<h3 id="2-技术实现的核心"><a href="#2-技术实现的核心" class="headerlink" title="2.技术实现的核心"></a>2.技术实现的核心</h3><ul>
<li>指针位复用​​：<br>  在 64 位系统中，指针占用 8 字节（64 位），但实际地址通常仅使用低 48 位。​​高位空闲的 16 位​​被用于存储：<ul>
<li>标记位（Tag）​​：标识指针是否为 Tagged Pointer，在 arm64 架构中最高位 1 代表是 Tagged Pointer，非 arm64 架构中最低位 1 代表是 Tagged Pointer。可以在 libobjc.A.dylib 源码中看到。</li>
<li>​​直接数据​​：将小对象的值（如整数、短字符串）直接编码到指针中，避免分配堆内存。</li>
</ul>
</li>
<li>示例：<br>  NSNumber 存储一个小于 2^60 的整数时，直接将数值编码到指针的高 60 位，最低 4 位作为类型标记。</li>
</ul>
<h3 id="3-主要优势"><a href="#3-主要优势" class="headerlink" title="3.主要优势"></a>3.主要优势</h3><ul>
<li>内存效率：<br>  避免频繁分配和释放小对象的内存碎片，减少内存占用。</li>
<li>性能提升​​：<br>  省去堆内存访问（无需解引用指针），提升数据存取速度。</li>
<li>类型判断加速​​：<br>  通过指针的标记位快速识别对象类型（如 NSNumber 或 NSString），减少动态类型检查开销。</li>
</ul>
<h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4.应用场景"></a>4.应用场景</h3><ul>
<li>基础类优化​​：<br>  NSNumber、NSString（短字符串）、NSDate、NSIndexPath 等小对象默认使用 Tagged Pointer。</li>
<li>条件限制​​：<br>  对象的值需满足直接编码到指针中的大小限制（例如 NSNumber 的数值范围受剩余位数约束）。</li>
</ul>
<h3 id="5-开发者注意事项​"><a href="#5-开发者注意事项​" class="headerlink" title="5. 开发者注意事项​"></a>5. 开发者注意事项​</h3><ul>
<li>透明实现​​：<br>  Tagged Pointer 对开发者完全透明，无需修改代码即可享受优化。</li>
<li>调试工具识别​​：<br>  在 Xcode 中，Tagged Pointer 的地址通常显示为特殊格式（如 0xb000000000000013，末尾的 3 表示 NSNumber 类型）。</li>
<li>兼容性​​：<br>  仅限 64 位设备，32 位架构因指针位不足无法使用。</li>
</ul>
<h3 id="6-扩展知识"><a href="#6-扩展知识" class="headerlink" title="6. 扩展知识"></a>6. 扩展知识</h3><ul>
<li>与 Compact Strings 的关系​​：<br>  iOS 15 引入的字符串压缩技术（Compact Strings）进一步优化 NSString，但 Tagged Pointer 是其底层基础之一。</li>
<li>安全影响​​：<br>  Tagged Pointer 的标记位设计需避免与有效地址冲突，否则可能引发内存错误（如早期 iOS 版本曾因混淆标记位导致漏洞）。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>iOS 7 通过引入 ​​Tagged Pointer​​，在 64 位设备上实现了小对象的高效存储，显著提升了内存和性能表现。这一技术至今仍是 iOS 运行时优化的核心机制之一。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>以下两段代码有什么区别？为什么会产生这种这种区别？</p>
<p>代码1：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;helloWorld,areyouOK?&quot;</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码2：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abc&quot;</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>代码 1 会导致崩溃而代码 2 不会崩溃的原因在于字符串的内存管理方式以及多线程环境下的竞争条件：</p>
<ol>
<li>字符串类型差异<ul>
<li>代码 1 的字符串 @”helloWorld,areyouOK?” 较长，会创建普通的 NSString 对象（堆内存分配），涉及引用计数管理。</li>
<li>代码 2 的字符串 @”abc” 较短，会被优化为 NSTaggedPointerString（标签指针），其值直接存储在指针中，无需引用计数。</li>
</ul>
</li>
<li>多线程竞争条件​​：<ul>
<li>对于普通  NSString 对象（代码1）：每次赋值会触发 retain 新值和 release 旧值的操作。多线程环境下，多个线程同时执行这些非原子操作可能导致：<ul>
<li>旧值被多次 release（过度释放）。</li>
<li>对象引用计数混乱，引发野指针访问（EXC_BAD_ACCESS）。</li>
</ul>
</li>
<li>对于 NSTaggedPointerString（代码2）：赋值仅是指针的原子写入，不涉及引用计数操作，因此无竞争风险。</li>
</ul>
</li>
<li>属性原子性​​：<ul>
<li>name 属性声明为 nonatomic，缺乏锁保护，允许多线程直接访问，加剧了普通对象的内存管理问题。</li>
</ul>
</li>
</ol>
<p>代码 1 因涉及非原子的引用计数操作导致多线程崩溃，而代码 2 的标签指针赋值是原子且无内存管理的，因此安全。解决方法包括使用 atomic 属性、串行队列或同步机制（如 @synchronized）保护属性访问。</p>
<hr>
<h1 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h1><h2 id="什么是-MRC"><a href="#什么是-MRC" class="headerlink" title="什么是 MRC"></a>什么是 MRC</h2><p>在编写 C 语言程序时，我们需要手动对 malloc 创建出来的数据进行内存管理，在合适的时机需要手动 free 释放堆区内存。同样在 iOS 开发中，对象的创建就是在堆区分配的内存，那么当然也需要在合适的时机对对象进行内存的释放。MRC（Manual Reference Counting，手动引用计数）是 iOS 早期手动管理对象内存的核心机制，开发者需要<strong>显式控制对象的生命周期</strong>，通过以下规则和方法实现：</p>
<h3 id="1-引用计数的核心原则"><a href="#1-引用计数的核心原则" class="headerlink" title="1. 引用计数的核心原则"></a>1. 引用计数的核心原则</h3><ul>
<li>每个对象都有一个引用计数（retainCount），初始值为 1（通过 alloc、new、copy 等方法创建的对象）。</li>
<li>当引用计数 retainCount &#x3D; 0 时，对象会被系统立即释放内存（调用 dealloc 方法）。</li>
<li>开发者需要手动调用 retain 增加计数和 release 减少技术来管理所有权。</li>
</ul>
<h3 id="2-关键方法"><a href="#2-关键方法" class="headerlink" title="2. 关键方法"></a>2. 关键方法</h3><ul>
<li><strong>retain</strong><ul>
<li>作用：增加对象的引用计数 retainCount +1。</li>
<li>场景：当需要持有（拥有）一个对象时（如将对象赋值给实例变量或添加到集合中）。</li>
</ul>
</li>
<li><strong>release</strong><ul>
<li>作用：减少对象的引用计数 retainCount -1。</li>
<li>场景：当不再需要对象时调用。若计数减到 0，对象内存被释放。</li>
</ul>
</li>
<li><strong>autorelease</strong><ul>
<li>作用：将对象加入<strong>自动释放池（Autorelease Pool）</strong>，延迟释放（通常在当前 RunLoop 进入休眠前统一调用 release）。</li>
<li>场景：方法返回对象时，避免立即释放（如工厂方法）。</li>
</ul>
</li>
</ul>
<h3 id="3-所有权规则"><a href="#3-所有权规则" class="headerlink" title="3. 所有权规则"></a>3. 所有权规则</h3><ul>
<li>谁创建，谁释放：通过 alloc、new、copy、mutableCopy 创建的对象，需由创建者调用 release。</li>
<li>谁持有，谁释放：通过 retain 或强引用的对象，需调用 release 放弃所有权。</li>
<li>方法命名约定：<ul>
<li>方法名以 alloc、new、copy 开头，返回的对象由调用者负责释放。</li>
<li>其他方法返回的对象默认是 autorelease 的（如 [NSString stringWithFormat:]）。</li>
</ul>
</li>
</ul>
<h3 id="4-常见错误"><a href="#4-常见错误" class="headerlink" title="4. 常见错误"></a>4. 常见错误</h3><ul>
<li>内存泄露：未调用 release，导致对象没有释放，之后也无法再次使用对象。</li>
<li>悬垂指针：过早调用 release 后继续访问对象（导致 BAD_ACCESS 崩溃）。</li>
<li>过度释放：对一个对象多次调用 release（直接崩溃）。</li>
</ul>
<h3 id="5-代码示范"><a href="#5-代码示范" class="headerlink" title="5. 代码示范"></a>5. 代码示范</h3><h4 id="代码1：手动释放不再需要使用的对象"><a href="#代码1：手动释放不再需要使用的对象" class="headerlink" title="代码1：手动释放不再需要使用的对象"></a>代码1：手动释放不再需要使用的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    [<span class="variable language_">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s begin&quot;</span>, __func__);</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    Person *person = [Person new];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    省略中间可能的其他代码。。。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    [person release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s end&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 MRC 环境下，ViewDidLoad 方法中创建了一个 Person 对象，如果不手动调用 release 方法，那么 ViewDidLoad 执行完后这个对象就再也无法访问到了，这就是内存泄露。如果不注意任这样的代码泄露内存，很快就会发现应用内存占用过大而被系统杀死。所以非常有必要将不再需要使用的对象内存正确释放掉，方法就是手动调用 release 方法使其引用计数变为 0。或者再对象创建的时候调用 autorelease 方法加入自动释放池，那么在合适的时机，自动释放池清空的时候，会对池内的对象发送一个 release 消息。</p>
<h4 id="代码2：对象持有其他对象的内存管理"><a href="#代码2：对象持有其他对象的内存管理" class="headerlink" title="代码2：对象持有其他对象的内存管理"></a>代码2：对象持有其他对象的内存管理</h4><p>当 Person 对象持有 Dog 对象的时候，setter 方法改如何实现？<br>在使用 @property 声明属性时候，编译器自动帮我们生成了 setter、getter 和成员变量。那么编译器生成的 setter 方法内是如何管理新旧两个对象内存的？<br>在 MRC 时代，@property 声明属性并不会自动生成 setter、getter 和成员变量，还需要配合 @synthesize 才能生成。但是目前 ARC 已经不再需要使用 @synthesize 了。除此之外，还有两种情况需要使用 @synthesize，一是在协议和分类中的属性，需要使用 @synthesize 显式生成。二是有自定义成员变量名的需求时，因为默认生成的成员变量名是属性名前面加下划线。</p>
<ol>
<li><p>不管37二十一，直接将参数新对象赋值给成员变量？？？</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDog:(Dog *)dog &#123;</span><br><span class="line">	_dog = dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样肯定会出问题的，旧对象没有调用 release，那必然会造成内存泄露。</li>
<li>新对象没有被 retain，那么在这个对象在外部 release 的时候，Person 的 dog 也同步被释放了。应该做到只要 Person 还在内存中，它所拥有的对象就都应该还在内存中。Person 释放的时候，也需要释放它拥有的对象，也就是在 Person 的 dealloc 方法中调用它持有对象的 release 方法。</li>
</ul>
<p> 所以 setter 方法至少需要做的两个操作，对旧的对象调用一次 release，对新的对象调用一次 retain。</p>
</li>
<li><p>经过上面的讨论，那么此时的 setter 方法应该是</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDog:(Dog *)dog &#123;</span><br><span class="line">	[_dog release];</span><br><span class="line">	_dog = [dog <span class="keyword">retain</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这样子就足够完美了吗？还是不行。如果外部多次调用 setDog: 方法，且参数时候同一个对象，那么这个对象有可能被释放了，然后还在继续使用。需要做的是对参数和成员变量进行判断</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDog:(Dog *)dog &#123;</span><br><span class="line">	<span class="keyword">if</span> (_dog != dog) &#123;</span><br><span class="line">		[_dog release];</span><br><span class="line">		_dog = [dog <span class="keyword">retain</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>MRC 要求开发者像“管家”一样精准控制对象生命周期，​​每个 retain 必须对应一个 release​​。虽然灵活，但极易出错。2011 年推出的 ​​ARC（自动引用计数）​​ 通过编译器自动插入 retain&#x2F;release 代码，彻底解放了开发者，成为现代 Objective-C&#x2F;Swift 开发的主流选择。但在维护旧项目或特定场景下，仍需理解 MRC 的原理。ARC 出现之后虽然说不再需要程序员手动管理内存，但是仍然需要注意循环引用可能引起的内存泄露问题。</p>
<hr>
<h1 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h1><p>copy 就是为了复制一个新的对象出来，新对象的属性和值都和原来对象一模一样，但又是两个独立的对象，修改其中一个对象的属性不会影响到另一个对象。在 iOS 中，实现了 NSCopying 协议的类就拥有了 copy 的能力，它返回一个不可变的副本，如 NSURL、NSCachedURLResponse、NSDate 等等。还有一个 NSMutableCopying 协议，实现了这个协议的类就拥有了 mutableCopy 的能力，它返回一个可变类型的副本，如 NSString、NSArray、NSDictionary、NSData 等等。</p>
<p>调用了 copy、mutableCopy 方法返回的对象，同样需要内存管理。这个在刚刚的 MRC 中已经提到过了。在 MRC 环境下需要手动释放，在 ARC 环境下由编译器插入合适的 release 方法。</p>
<ul>
<li>对于不可变的对象，如 NSArray，NSDictionary，NSData <ul>
<li>如果调用 copy 方法返回的是对象本身，引用计数加 1，这种称之为浅拷贝。</li>
<li>如果调用 mutableCopy 方法返回的是新的可变类型的对象，如 NSMutableArray、NSMutableDictionary、NSMutableData，这种称之为深拷贝。</li>
</ul>
</li>
<li>对与可变类型的对象，如 NSMutableArray、NSMutableDictionary、NSMutableData<ul>
<li>如果调用 copy 方法返回的是新的不可变类型的对象，如 NSArray、NSDictionary、NSData。这种也是深拷贝。</li>
<li>如果调用 mutableCopy 方法返回同样类型的新对象。这种也是深拷贝。</li>
</ul>
</li>
</ul>
<p>总结，浅拷贝并没有创建新的对象，而深拷贝创建了新的对象。不可变对象的不可变拷贝是浅拷贝，其余都是深拷贝。</p>
<h2 id="自定义对象的拷贝"><a href="#自定义对象的拷贝" class="headerlink" title="自定义对象的拷贝"></a>自定义对象的拷贝</h2><p>如果一个自己写的类，想要拥有 copy 能力，就需要采用 NSCopying 协议，实现 <code>- (id)copyWithZone:(nullable NSZone *)zone;</code> 方法：</p>
<p>如以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="type">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    Person *person = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">    person.name = <span class="keyword">self</span>.name;</span><br><span class="line">    person.age = <span class="keyword">self</span>.age;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%p,%@,%d&quot;</span>,<span class="keyword">self</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *person = [Person new];</span><br><span class="line">    person.name = <span class="string">@&quot;Tom&quot;</span>;</span><br><span class="line">    person.age = <span class="number">18</span>;</span><br><span class="line">    </span><br><span class="line">    Person *person2 = [person <span class="keyword">copy</span>];</span><br><span class="line">    person2.name = <span class="string">@&quot;Jerry&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, person);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, person2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><p>以下代码会有什么问题？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">	Person *person = [Person new];</span><br><span class="line">	person.array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">	[person.array addObject:<span class="string">@&quot;hello&quot;</span>];</span><br><span class="line">	[person.array addObject:<span class="string">@&quot;world&quot;</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码存在一个关键问题：将 ​​NSMutableArray​​ 类型的属性声明为 ​​copy​​，这会导致不可预知的运行时崩溃。以下是具体分析：</p>
<ol>
<li>问题根源：copy 修饰符的副作用<ul>
<li>copy 修饰符的特性：当给属性赋值时，系统会自动对传入的对象调用 copy 方法，生成一个不可变的副本，即使参数对象的确是个可变的对象。</li>
<li>NSMutableArray 的 copy 行为：NSMutableArray 的 copy 方法返回的是 不可变的 NSArray，而非 NSMutableArray。因此，虽然属性声明为 NSMutableArray，但实际存储的是 NSArray。</li>
</ul>
</li>
<li>导致崩溃的原因<ul>
<li>尝试修改不可变数组：在 main 函数中，调用 addObject: 方法时，实际是向一个 NSArray 对象发送 addObject: 消息，而 NSArray 没有 addObject: 方法。这会引发如下运行时错误： <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[__NSArrayI addObject:]: unrecognized selector sent to instance</span><br></pre></td></tr></table></figure>
 程序会因此崩溃。</li>
</ul>
</li>
<li>解决方案<ul>
<li>使用 strong 修饰符：若属性需要保存可变性，应使用 strong（ARC）或 retain（MRC）修饰符： <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;</span><br></pre></td></tr></table></figure></li>
<li>若改用 NSArray：如果确实需要 copy 语义，应将属性类型改为 NSArray，并避免修改数组： <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *array;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>验证问题的示例 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">person.array = mutableArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际类型是 NSArray，而非 NSMutableArray</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [person.array <span class="keyword">class</span>]); <span class="comment">// 输出 __NSArrayI（不可变数组）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>声明 NSMutableArray 属性时使用 copy 修饰符，会导致实际存储的是不可变数组，后续修改操作会崩溃。应根据需求选择正确的修饰符（strong 或 retain）或调整属性类型（改为 NSArray）。</p>
<hr>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>在 iOS 中，对象的引用计数存储位置从历史的发展角度来看，可以分为以下两个阶段：</p>
<h2 id="1-Non-pointer-isa-出现前的机制"><a href="#1-Non-pointer-isa-出现前的机制" class="headerlink" title="1. Non-pointer isa 出现前的机制"></a>1. Non-pointer isa 出现前的机制</h2><ul>
<li>传统 isa 指针的作用<br>  在 32 位系统或早期的 64 位系统中，对象的 isa 指针仅用于指向类对象的内存地址，不包含其他信息。</li>
<li>引用计数的存储方式<br>  对象的引用计数（retainCount）并不直接存储在对象内存中，而是通过一个全局的 SideTable 结构来维护。这个 SideTable 中的一个成员 RefcountMap refcnts 是一个哈希表，键是对象的地址，值则是对象的引用计数，至于什么是哈希表可以理解为 Objective-C 中的字典，但是比字典更底层更高效。SideTable 中还存在一个成员 spinlock_t slock，这是个自旋锁用来保证对 refcnts 的原子操作。</li>
<li>性能与设计考量：<ul>
<li>优点：避免了为每个对象单独分配存储引用计数的空间（节省内存，尤其是对象未被频繁操作时）。</li>
<li>缺点：每次 retain&#x2F;release 操作都需要访问散列表，可能引发锁竞争和性能损耗。</li>
</ul>
</li>
</ul>
<h2 id="2-Non-pointer-isa-的优化"><a href="#2-Non-pointer-isa-的优化" class="headerlink" title="2. Non-pointer isa 的优化"></a>2. Non-pointer isa 的优化</h2><p>在 64 位系统下，苹果对 isa 指针进行了优化（称为 ​​non-pointer isa​​），将部分内存管理信息直接存储在 isa 指针的冗余比特位中：</p>
<ul>
<li><strong>extra_rc 字段</strong>​​：isa 指针中保留了 ​​19 个比特位​​（不同架构可能略有差异）用于存储额外的引用计数值（extra retain count）。<ul>
<li>之所以叫额外的引用计数，这是因为在 objc4 某个版本之前是通过 extra_rc + 1 的形式返回对象的实际引用计数，即对象默认隐含了 1 个引用计数。</li>
<li>而在最近的版本中直接通过 extra_rc 表示实际引用计数</li>
<li>如果 extra_rc 溢出（即引用计数超过 2^19 -1），则会将溢出的部分转移到 ​​SideTable​​。</li>
</ul>
</li>
</ul>
<p>这种方式减少了全局散列表的访问频率，降低了锁竞争，提高了内存操作效率。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>non-pointer isa 出现前​​：引用计数完全依赖全局散列表（Side Tables）管理。</li>
<li>non-pointer isa 出现后​​：引用计数优先内联到 isa 的冗余位，仅在必要时使用 Side Tables。</li>
</ul>
<p>这种设计使得 iOS 的内存管理在绝大多数场景下（引用计数较小）无需访问全局表，从而显著提升性能。这一优化显著提升了内存访问效率和并发性能，是苹果针对 64 位系统的重要底层优化之一。</p>
<hr>
<h1 id="weak-指针"><a href="#weak-指针" class="headerlink" title="weak 指针"></a>weak 指针</h1><h2 id="weak-指针功能演示"><a href="#weak-指针功能演示" class="headerlink" title="weak 指针功能演示"></a>weak 指针功能演示</h2><p>有以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p,%s&quot;</span>, <span class="keyword">self</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> Person *person1;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Person *person2;</span><br><span class="line">        </span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person new];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;1.person:%@&quot;</span>, person);</span><br><span class="line">        person1 = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1.%@&quot;</span>, person1);</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        Person *person = [Person new];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;2.person:%@&quot;</span>, person);</span><br><span class="line">        person2 = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2.%@&quot;</span>, person2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>person:&lt;Person: <span class="number">0x2821c0f10</span>&gt;</span><br><span class="line"><span class="number">0x2821c0f10</span>,-[Person dealloc]</span><br><span class="line"><span class="number">1.</span>(null)</span><br><span class="line"><span class="number">2.</span>person:&lt;Person: <span class="number">0x2821c0f10</span>&gt;</span><br><span class="line"><span class="number">0x2821c0f10</span>,-[Person dealloc]</span><br></pre></td></tr></table></figure>

<p>从打印的结果可以看到，<code>__weak</code> 修饰的 person1 所指向的对象在释放之后 person1 指向了 nil，所以打印的结果是 null。而 <code>__unsafe_unretained</code> 修饰的 person2 所指向的对象在释放之后依然指向着原来的地方，访问已经被释放的对象内存空间导致了 <code>EXC_BAD_ACCESS</code> 崩溃。</p>
<h2 id="unsafe-unretained-和-weak-的异同"><a href="#unsafe-unretained-和-weak-的异同" class="headerlink" title="__unsafe_unretained 和 __weak 的异同"></a><code>__unsafe_unretained</code> 和 <code>__weak</code> 的异同</h2><p>在 Objective-C 中，<code>__weak</code> 和 <code>__unsafe_unretained</code> 都是用于避免对象强引用的修饰符，但它们在安全性和底层行为上有本质区别。以下是它们的异同点：</p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol>
<li>不增加引用计数<br> 两者都不会增加对象的引用计数（即不持有对象所有权），因此不会阻止对象被释放。</li>
<li>用于打破循环引用<br> 都可以用于解决对象间的循环引用问题（例如在 block 或 delegate 中）。</li>
</ol>
<h3 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a>核心区别</h3><ol>
<li><p>内存管理机制</p>
<table>
<thead>
<tr>
<th></th>
<th><strong><code>__weak</code></strong></th>
<th><strong><code>__unsafe_unretained</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td>安全性</td>
<td>自动置空（对象释放后指针变 nil）</td>
<td>不自动置空（对象释放后指针变为野指针）</td>
</tr>
<tr>
<td>底层实现</td>
<td>依赖运行时库中建立的弱引用表（weak_table）</td>
<td>仅简单存储指针地址，无运行时介入</td>
</tr>
</tbody></table>
</li>
<li><p>使用场景</p>
<table>
<thead>
<tr>
<th><code>__weak</code></th>
<th><code>__unsafe_unretained</code></th>
</tr>
</thead>
<tbody><tr>
<td>需要自动安全的指针（如 delegate）</td>
<td>性能敏感场景，可以避免运行时开销</td>
</tr>
<tr>
<td>常规开发中的弱引用</td>
<td>兼容旧代码（iOS 4之前无 __weak）</td>
</tr>
<tr>
<td>需要避免野指针崩溃的场合</td>
<td>明确知道对象生命周期时的优化手段</td>
</tr>
</tbody></table>
</li>
<li><p>性能差异</p>
<ul>
<li><code>__weak</code> 需要运行时通过弱引用表动态管理指针，有额外的性能开销（注册、清理等）。</li>
<li><code>__weak_unretained</code> 直接存储指针地址，无运行时开销，性能更高。</li>
</ul>
</li>
</ol>
<h3 id="何时使用-unsafe-unretained"><a href="#何时使用-unsafe-unretained" class="headerlink" title="何时使用 __unsafe_unretained ?"></a>何时使用 __unsafe_unretained ?</h3><ol>
<li>兼容旧系统<br> iOS 4 或更早系统不支持 <code>__weak</code> 时，必须使用 <code>__unsafe_unretainde</code>。</li>
<li>性能优化<br> 在需要极致性能的代码中（例如高频调用的循环），避免弱引用表的运行时开销。</li>
<li>与非 Objective-C 对象交互<br> 例如与 CoreFoundation 对象，如 CFArrayRef 交互时，可能直接使用指针地址。</li>
<li>明确对象生命周期<br> 当开发者能严格包装被引用对象的声明周期时（例如单例对象），可安全使用。</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>__weak</th>
<th>__unsafe_unretained</th>
</tr>
</thead>
<tbody><tr>
<td>安全性</td>
<td>✅自动置空</td>
<td>❌野指针风险</td>
</tr>
<tr>
<td>运行时介入</td>
<td>✅依赖 weak_table</td>
<td>❌无介入</td>
</tr>
<tr>
<td>性能开销</td>
<td>较高（注册、清理操作）</td>
<td>无</td>
</tr>
<tr>
<td>适用场景</td>
<td>常规开发</td>
<td>旧系统兼容、性能优化、明确生命周期</td>
</tr>
</tbody></table>
<p>在 iOS 5+ 开发中，优先使用 __weak；仅在必要时（如性能优化或旧代码维护）使用 __unsafe_unretained，并确保完全理解其风险。</p>
<h2 id="weak-底层原理"><a href="#weak-底层原理" class="headerlink" title="weak 底层原理"></a>weak 底层原理</h2><p>Objective-C 中的 weak 实现是​​编译器的代码生成​​与​​运行时的内存管理机制​​协同工作的结果。以下是完整的协作流程：</p>
<h3 id="1-编译器与运行时的协作机制​"><a href="#1-编译器与运行时的协作机制​" class="headerlink" title="1. 编译器与运行时的协作机制​"></a>1. 编译器与运行时的协作机制​</h3><ul>
<li>编译器的作用：<ul>
<li><strong>插入关键函数​​</strong>：在 ARC 环境下，编译器会自动为 __weak 变量生成代码，插入 objc_initWeak（注册弱引用）和 objc_destroyWeak（移除弱引用）等函数调用。</li>
<li><strong>​​管理作用域​​</strong>：根据变量的生命周期（如超出作用域、被重新赋值），编译器决定何时调用这些函数。</li>
</ul>
</li>
<li>运行时的作用：<ul>
<li><strong>维护弱引用表</strong>​​：动态管理全局的弱引用表（Weak Table），记录对象与弱指针的映射关系。</li>
<li><strong>对象释放时的清理​​</strong>：在对象 dealloc 时，遍历弱引用表，将关联的弱指针置 nil。</li>
</ul>
</li>
</ul>
<h3 id="2-完整协作流程示例​"><a href="#2-完整协作流程示例​" class="headerlink" title="2. 完整协作流程示例​"></a>2. 完整协作流程示例​</h3><p>代码示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj = obj; <span class="comment">// 编译器插入 objc_initWeak</span></span><br><span class="line">    <span class="comment">// 使用 weakObj...</span></span><br><span class="line">&#125; <span class="comment">// 编译器插入 objc_destroyWeak</span></span><br></pre></td></tr></table></figure>

<p>编译器生成的伪代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入作用域</span></span><br><span class="line"><span class="built_in">NSObject</span> *obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(new));</span><br><span class="line"><span class="type">id</span> weakObj; <span class="comment">// 栈上的弱指针变量</span></span><br><span class="line">objc_initWeak(&amp;weakObj, obj); <span class="comment">// 注册到运行时弱引用表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出作用域时</span></span><br><span class="line">objc_destroyWeak(&amp;weakObj); <span class="comment">// 从弱引用表移除</span></span><br><span class="line">objc_storeStrong(&amp;obj, <span class="literal">nil</span>); <span class="comment">// 释放强引用</span></span><br></pre></td></tr></table></figure>

<h3 id="3-编译器的关键操作​​"><a href="#3-编译器的关键操作​​" class="headerlink" title="3. 编译器的关键操作​​"></a>3. 编译器的关键操作​​</h3><hr>
<!--

-->

<h1 id="autorelease-底层原理"><a href="#autorelease-底层原理" class="headerlink" title="autorelease 底层原理"></a>autorelease 底层原理</h1><p>autorelease 对象何时释放？</p>
<p>@autoreleasepool {} 这是一个编译器提供的语法糖。</p>
<p>分情况，</p>
<ul>
<li>你手动创建了 Autoreleasepool 的话，当然是在你自己创建的自动释放池释放的时候。</li>
<li>否则就是系统在 RunLoop 的几个时机创建的自动释放池了。</li>
</ul>
<p>通过 Clang rewrite-objc 查看 @Autoreleasepool{} 的底层表示，是个结构体。</p>
<p>220</p>
<p>然后是查看 objc_aureleasePoolPush() 函数和 objc_aureleasePoolPop() 函数的实现。在 objc4 源码里。<br>里面调用了 AutoreleasePoolPage 的方法，这是个 C++ 的类。</p>
<p>每个 AutoreleasePoolPage 实例对象占用 4KB 字节。除了自己的成员需要占用的几十个字节的空间，剩下的空间都用于存放加入了自动释放池的对象。<br>所有 AutoreleasePoolPage 实例对象采用双向链表的结构链接在一起。</p>
<p>@autoreleasepool{} 嵌套是个什么情况？每次都创建新池吗？</p>
<p>有一个私有函数可以查看自动释放池的情况 <code>_objc_autoreleasePoolPrint()</code></p>
<p>RunLoop 与 AutoreleasePool，有一个细节，究竟是在哪个库的哪个函数里面对 RunLoop 添加观察者实现自动释放池的创建和释放的，需要逆向分析出来~是 libobjc.A.dylib 库吗？还是 Foundation 库？</p>
<p>进入 RunLoop 之前创建一个新池 push<br>休眠之前，调用一个 pop，再创建一个新池 push<br>退出 RunLoop 的时候调用一次 pop。<br>现在的问题是，第一次进入 RunLoop 前 push 的池，是休眠前 pop 掉的，还是退出 RunLoop 的时候 pop 掉的？</p>
<p>打印 RunLoop 能看到自动释放池相关的 Observers </p>
<p>方法里面有局部对象，出了方法后会立即释放吗？不一定会，主要还是看对象的引用计数是否变为0，比如局部对象被Block捕获了的话出了方法体也不会被释放。只有等Block释放的时候，Block对它拥有的对象进行 release 的时候可能被释放。也还是要看对象的引用计数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://masterking.github.io">masterKing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://masterking.github.io/2025/05/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">https://masterking.github.io/2025/05/15/内存管理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://masterking.github.io" target="_blank">masterKing 的博客</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/iOS_low-level_principles.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/09/Runloop/" title="Runloop"><img class="cover" src="/images/iOS_low-level_principles.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Runloop</div></div><div class="info-2"><div class="info-item-1">      引出 RunLoop在学习 C 语言的时候，一般的命令行程序运行之后会马上结束。如果想要让程序不直接退出，而是一直等待用户的输入，并根据用户的输入决定是否退出程序，那就得加一个循环实现了。如以下这个简单的 C 程序： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;st...</div></div></div></a><a class="pagination-related" href="/2025/05/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><img class="cover" src="/images/iOS_low-level_principles.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">多线程</div></div><div class="info-2"><div class="info-item-1">相关面试题 你理解的多线程？ iOS 中的多线程方案有哪几种？你更倾向于哪一种？ 你在项目中用过 GCD 吗？ GCD 的队列类型 说一下 OperationQueue 和 GCD 的区别，以及各自的优势 线程安全的处理手段有哪些？ Objective-C 你了解的锁有哪些？在你回答基础上进行二次提问： 自旋锁和互斥锁对比？ 使用以上锁需要注意哪些？ 用 C&#x2F;C++&#x2F;Ob...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">相关面试题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">控制器无法释放的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-weak-%E5%92%8C-block-API-%E8%A7%A3%E5%86%B3"><span class="toc-text">使用 __weak 和 block API 解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E5%B1%82%E5%AF%B9%E8%B1%A1%E8%A7%A3%E5%86%B3"><span class="toc-text">使用中间层对象解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-GCD-%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">使用 GCD 的定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-GCD-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">直接使用 GCD 定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-GCD-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">封装 GCD 定时器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS-%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">iOS 应用内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ASLR-%EF%BC%9F"><span class="toc-text">什么是 ASLR ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASLR-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-text">ASLR 的作用原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">静态变量的作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tagged-Pointer"><span class="toc-text">Tagged Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Tagged-Pointer"><span class="toc-text">什么是 Tagged Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2.实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.常见应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%A1%E6%95%B0%E7%BB%86%E8%8A%82"><span class="toc-text">4.计数细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E7%82%B9"><span class="toc-text">5.优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%99%90%E5%88%B6%E4%B8%8E%E6%8C%91%E6%88%98%E2%80%8B"><span class="toc-text">6.限制与挑战​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%A4%BA%E4%BE%8B%E4%B8%8E%E7%B1%BB%E6%AF%94%E2%80%8B"><span class="toc-text">7.示例与类比​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS-%E4%B8%AD%E7%9A%84-Tagged-Pointer"><span class="toc-text">iOS 中的 Tagged Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E8%83%8C%E6%99%AF"><span class="toc-text">1.引入背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-text">2.技术实现的核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF"><span class="toc-text">3.主要优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BC%80%E5%8F%91%E8%80%85%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E2%80%8B"><span class="toc-text">5. 开发者注意事项​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-text">6. 扩展知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MRC"><span class="toc-text">MRC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MRC"><span class="toc-text">什么是 MRC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99"><span class="toc-text">1. 引用计数的核心原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95"><span class="toc-text">2. 关键方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-text">3. 所有权规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-text">4. 常见错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E8%8C%83"><span class="toc-text">5. 代码示范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811%EF%BC%9A%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">代码1：手动释放不再需要使用的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%8C%81%E6%9C%89%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">代码2：对象持有其他对象的内存管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#copy"><span class="toc-text">copy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-text">自定义对象的拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">引用计数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Non-pointer-isa-%E5%87%BA%E7%8E%B0%E5%89%8D%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-text">1. Non-pointer isa 出现前的机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Non-pointer-isa-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">2. Non-pointer isa 的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#weak-%E6%8C%87%E9%92%88"><span class="toc-text">weak 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-%E6%8C%87%E9%92%88%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA"><span class="toc-text">weak 指针功能演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-unretained-%E5%92%8C-weak-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">__unsafe_unretained 和 __weak 的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-text">核心区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-unsafe-unretained"><span class="toc-text">何时使用 __unsafe_unretained ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">weak 底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6%E2%80%8B"><span class="toc-text">1. 编译器与运行时的协作机制​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E6%95%B4%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B%E2%80%8B"><span class="toc-text">2. 完整协作流程示例​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%85%B3%E9%94%AE%E6%93%8D%E4%BD%9C%E2%80%8B%E2%80%8B"><span class="toc-text">3. 编译器的关键操作​​</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#autorelease-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">autorelease 底层原理</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/images/iOS_low-level_principles.webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2018 - 2025 By masterKing</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'Nj4rbGaJ3pAWBRJWseaRg9Zu-gzGzoHsz',
      appKey: '3tVispErrQeAytUHyJrFos3n',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>