<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>KVC | masterKing 的博客</title><meta name="author" content="masterKing"><meta name="copyright" content="masterKing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我不知道有多少人像本人一样，n 年来查看过不知道多少次这个 KVC 文档，但是每次通篇读下来总是会遇到读不懂的地方，总是莫名其妙的出现一个章节完全不知道在讲什么东西，不论是用传统的 Google 翻译或者目前主流的 AI 翻译翻译了，也还是会遇到读起来狗屁不通的情况。  其实根本原因是原始文档就有问题，东拼西凑的一坨屎，有歧义，导致不论你是直译还是意译都是让人摸不着头脑的翻译，只能根据上下文的理解">
<meta property="og:type" content="article">
<meta property="og:title" content="KVC">
<meta property="og:url" content="https://masterking.github.io/2025/07/29/KVC/index.html">
<meta property="og:site_name" content="masterKing 的博客">
<meta property="og:description" content="我不知道有多少人像本人一样，n 年来查看过不知道多少次这个 KVC 文档，但是每次通篇读下来总是会遇到读不懂的地方，总是莫名其妙的出现一个章节完全不知道在讲什么东西，不论是用传统的 Google 翻译或者目前主流的 AI 翻译翻译了，也还是会遇到读起来狗屁不通的情况。  其实根本原因是原始文档就有问题，东拼西凑的一坨屎，有歧义，导致不论你是直译还是意译都是让人摸不着头脑的翻译，只能根据上下文的理解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://masterking.github.io/images/iOS_low-level_principles.webp">
<meta property="article:published_time" content="2025-07-29T06:21:57.000Z">
<meta property="article:modified_time" content="2025-08-23T12:05:33.545Z">
<meta property="article:author" content="masterKing">
<meta property="article:tag" content="KVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://masterking.github.io/images/iOS_low-level_principles.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "KVC",
  "url": "https://masterking.github.io/2025/07/29/KVC/",
  "image": "https://masterking.github.io/images/iOS_low-level_principles.webp",
  "datePublished": "2025-07-29T06:21:57.000Z",
  "dateModified": "2025-08-23T12:05:33.545Z",
  "author": [
    {
      "@type": "Person",
      "name": "masterKing",
      "url": "https://masterking.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://masterking.github.io/2025/07/29/KVC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e6857234b462ad05308d8b79794f0358";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KVC',
  isHighlightShrink: undefined,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient( 135deg, #2c241f, #968282);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/WechatIMG1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/sileorepo/"><i class="fa-fw fas fa-shop"></i><span> sileo 源</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/iOS_low-level_principles.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">masterKing 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">KVC</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/sileorepo/"><i class="fa-fw fas fa-shop"></i><span> sileo 源</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">KVC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-29T06:21:57.000Z" title="发表于 2025-07-29 14:21:57">2025-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-23T12:05:33.545Z" title="更新于 2025-08-23 20:05:33">2025-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS 底层原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.2k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/07/29/KVC/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2025/07/29/KVC/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离上次更新已有&quot;,&quot;messageNext&quot;:&quot;天，文章某些内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-08-23 20:05:33&quot;}" hidden></div><p>我不知道有多少人像本人一样，n 年来查看过不知道多少次这个 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">KVC 文档</a>，但是每次通篇读下来总是会遇到读不懂的地方，总是莫名其妙的出现一个章节完全不知道在讲什么东西，不论是用传统的 Google 翻译或者目前主流的 AI 翻译翻译了，也还是会遇到读起来狗屁不通的情况。</p>
<ul>
<li>其实根本原因是原始文档就有问题，东拼西凑的一坨屎，有歧义，导致不论你是直译还是意译都是让人摸不着头脑的翻译，只能根据上下文的理解才能正确翻译。为此作者将这份文档结合AI和个人理解做了全篇翻译，有需要的可以自行<a href="./book.zip">下载</a>。</li>
<li>还有原始文档很多地方只写了要怎么做，但是没有告诉你为什么要这么做，就会让人觉得莫名其妙。</li>
<li>文档的有些内容太古老了，某些内容只在早期的 MacOS 开发中使用，在 iOS 开发中几乎接触，使用不到，但是也没有做任何说明。</li>
</ul>
<p>这次作者决定结合 AI 和个人的理解将 KVC 文档彻底弄清楚，即使不能完全弄明白也要留下一个深刻的印象，方便后续遇到文章中的场景时能够回想起来。</p>
<hr>
<h1 id="章节概览"><a href="#章节概览" class="headerlink" title="章节概览"></a>章节概览</h1><p>✅ 建议阅读<br>❌ 不建议阅读</p>
<h2 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h2><ol>
<li>✅ 关于键值编码</li>
</ol>
<h2 id="键值编码基础知识"><a href="#键值编码基础知识" class="headerlink" title="键值编码基础知识"></a>键值编码基础知识</h2><ol start="2">
<li>✅ 访问对象的属性</li>
<li>✅ 访问集合属性		</li>
<li>✅ 使用集合操作符</li>
<li>✅ 表示非对象值</li>
<li>❌ 验证属性</li>
<li>✅ 访问器搜索逻辑</li>
</ol>
<h2 id="采用键值编码协议"><a href="#采用键值编码协议" class="headerlink" title="采用键值编码协议"></a>采用键值编码协议</h2><ol start="8">
<li>❌ 实现基本键值编码合规性			</li>
<li>❌ 定义集合方法					</li>
<li>❌ 处理非对象值					</li>
<li>❌ 添加验证						</li>
<li>❌ 描述属性关系					</li>
<li>❌ 以性能为导向进行设计</li>
<li>❌ 合规性检查清单</li>
</ol>
<h1 id="常见疑惑及解答"><a href="#常见疑惑及解答" class="headerlink" title="常见疑惑及解答"></a>常见疑惑及解答</h1><p>以下是作者对这篇文档的一些疑问以及结合 AI 的回答。</p>
<h2 id="属性验证是什么鬼？"><a href="#属性验证是什么鬼？" class="headerlink" title="属性验证是什么鬼？"></a>属性验证是什么鬼？</h2><p>Person 有一个 <code>NSString *name</code> 属性，如果需要给 name 添加验证则在内部添加以下代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)validateName:(<span class="type">id</span> *)ioValue error:(<span class="built_in">NSError</span> * __autoreleasing *)outError&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*ioValue == <span class="literal">nil</span>) || ([(<span class="built_in">NSString</span> *)*ioValue length] &lt; <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outError != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *outError = [<span class="built_in">NSError</span> errorWithDomain:PersonErrorDomain</span><br><span class="line">                                            code:PersonInvalidNameCode</span><br><span class="line">                                        userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span></span><br><span class="line">                                                    : <span class="string">@&quot;Name too short&quot;</span> &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部使用属性验证：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person* person = [[Person alloc] init];</span><br><span class="line"><span class="built_in">NSError</span>* error;</span><br><span class="line"><span class="built_in">NSString</span>* name = <span class="string">@&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (![person validateValue:&amp;name forKey:<span class="string">@&quot;name&quot;</span> error:&amp;error]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谁会用到这么奇葩的功能？直接在 setter 方法里面对入参进行验证就非常合理了啊。为什么还要这么脱了裤子放屁？</p>
<p>上面的例子就是 KVC 的属性验证机制（validate<Key>:error:），很多人第一次看到的时候都会觉得：「这玩意儿不是多此一举吗？我直接在 setter 里校验不就好了？」</p>
<h3 id="为什么会有-validate-error-这种“奇葩”设计？"><a href="#为什么会有-validate-error-这种“奇葩”设计？" class="headerlink" title="为什么会有 validate:error: 这种“奇葩”设计？"></a>为什么会有 validate<Key>:error: 这种“奇葩”设计？</h3><p>要理解它，就要从 KVC&#x2F;KVO 的历史定位来看：</p>
<ol>
<li>KVC 不是给你写普通 app 的<ul>
<li>它的目标是：让对象能被 跨语言、跨工具访问。</li>
<li>AppleScript、Interface Builder、Core Data、Bindings（数据绑定）、甚至一些旧的 Cocoa 工具，全都依赖 KVC。</li>
</ul>
</li>
<li>setter 校验 vs validate 校验<ul>
<li>setter 校验：调用 setAge: 时能拦截无效值，没问题。</li>
<li>KVC 校验：当外部用 <code>setValue:forKey:</code> 或者 UI 绑定框架（比如 Interface Builder 的 Cocoa Bindings）在更新属性前，就能调用 <code>validate&lt;Key&gt;:error:</code> 来判断输入值是否合法。</li>
<li>好处是：UI 层可以在赋值前发现问题，不会直接 crash，也可以通过 <code>NSError</code> 把信息传回界面，弹个提示。</li>
</ul>
</li>
<li>实际用途：数据绑定 (Cocoa Bindings)<ul>
<li>在 macOS AppKit 里，有个很冷门但很强大的特性：Bindings。</li>
<li>比如一个文本框直接绑定到 <code>person.age</code>，当用户输入值时，AppKit 会在背后调用 <code>validateAge:error:</code> 来校验。</li>
<li>如果校验失败，UI 可以自动显示错误提示，而不是你手动写代码去监听输入变化再验证。</li>
</ul>
</li>
</ol>
<h3 id="为什么感觉“没用”？"><a href="#为什么感觉“没用”？" class="headerlink" title="为什么感觉“没用”？"></a>为什么感觉“没用”？</h3><ul>
<li>在 iOS 开发里，这套机制几乎没人用，因为 iOS 从来没有推行 Cocoa Bindings。</li>
<li>在 macOS 桌面应用（特别是老一代 AppKit + Interface Builder）里，确实有人用过这套机制来省掉 UI 验证逻辑。</li>
<li>Apple 后来也逐渐弱化了 Bindings，转向更现代的 SwiftUI 数据流模型，所以这个东西在新代码里几乎成了遗迹。</li>
</ul>
<h3 id="所以结论是："><a href="#所以结论是：" class="headerlink" title="所以结论是："></a>所以结论是：</h3><ul>
<li><strong>✅ 现代 iOS&#x2F;Swift 开发者：完全不用管 <code>validate&lt;Key&gt;:error:</code>，直接在 setter 或者数据模型层自己写验证就好。</strong></li>
<li>🌀 历史原因：它主要是给 KVC + Bindings 体系设计的，让 UI 能在赋值之前通过统一协议进行验证。</li>
<li>📖 文档之所以写这么多：Apple 文档要保证完整性，告诉你 KVC 提供了这个 hook，但没告诉你“99% 的人不会用到”。</li>
</ul>
<p>其实你这句话非常有代表性：</p>
<blockquote>
<p>“直接在属性的 setter 方法里面对入参进行验证不比这脱了裤子放屁爽多了？”</p>
</blockquote>
<p>这也是为什么 绝大多数 iOS&#x2F;macOS 开发者对 <code>validate&lt;Key&gt;</code> 只停留在知道但不用的层面。</p>
<h2 id="实现基本键值编码合规性要我做什么？"><a href="#实现基本键值编码合规性要我做什么？" class="headerlink" title="实现基本键值编码合规性要我做什么？"></a>实现基本键值编码合规性要我做什么？</h2><p>在大多数场景下，只要使用 @property 并让编译器自动生成 ivar 和访问器（accessor），就能自动满足 KVC（Key-Value Coding）要求，开发者无需手动实现绝大多数行为。只有在你的对象存在非对象属性的时候，必须重写 <code>setNilValueForKey:</code> 方法来避免可能的崩溃，实践中也建议在 <code>setNilValueForKey:</code> 内尽量使用 <code>setValue:forKey:</code>，以保证 KVO 通知等机制能正确触发，而不是直接设值或设置 ivar 。</p>
<h2 id="什么时候需要定义集合方法？"><a href="#什么时候需要定义集合方法？" class="headerlink" title="什么时候需要定义集合方法？"></a>什么时候需要定义集合方法？</h2><p>这一节的内容我相信也是很多人十分不理解的一节。集合不是有专门的 <code>mutableXXXValueForKey:</code> 这样的集合获取方法吗？然后就可以通过这个方法返回的结果，对集合属性进行任何增删改操作啊，还支持 KVO 功能。集合属性只需要通过 <code>mutableXXXValueForKey:</code> 不需要看起来也没有必要实现任何其他 KVC 的那些集合方法啊?</p>
<h3 id="1-mutableXXXValueForKey-的机制"><a href="#1-mutableXXXValueForKey-的机制" class="headerlink" title="1. mutableXXXValueForKey: 的机制"></a>1. <code>mutableXXXValueForKey:</code> 的机制</h3><ul>
<li>调用 <code>mutableArrayValueForKey:@&quot;someProperty&quot;</code> 时，KVC runtime 会返回一个 <strong>特殊的代理对象</strong>（不是你原始的 NSMutableArray）。</li>
<li>这个代理对象拦截 <code>addObject:</code> &#x2F; <code>removeObject:</code> 等操作，转发给你的对象。</li>
<li>这样做的好处是：<ul>
<li>自动触发 KVO 通知（观察者会知道集合变动了）。</li>
<li>统一封装逻辑（外部调用者不用关心你集合的真实存储结构）。</li>
</ul>
</li>
</ul>
<p>所以，如果你只是自己在 Swift&#x2F;Objective-C 里操作集合，并且依赖 KVO，确实只需要用 <code>mutableArrayValueForKey:</code> 就够了。</p>
<h3 id="2-Collection-Methods（countOf-等）的作用"><a href="#2-Collection-Methods（countOf-等）的作用" class="headerlink" title="2. Collection Methods（countOf&lt;Key&gt; 等）的作用"></a>2. Collection Methods（<code>countOf&lt;Key&gt;</code> 等）的作用</h3><ul>
<li>这些方法并不是为了你写代码时方便，而是为了 KVC runtime 能够在不同语言&#x2F;上下文中自动把属性“当作集合”来使用。</li>
<li>举例：<ul>
<li>AppleScript 想访问 <code>myObj.items[0]</code>，它不会直接知道 items 是一个 NSMutableArray。</li>
<li>KVC runtime 会尝试调用 <code>countOfItems</code>、<code>objectInItemsAtIndex:</code> 等方法，把你的对象包装成集合接口。</li>
<li>这样就算你内部不是用 NSArray 存储，而是用数据库、懒加载列表、Core Data faulting，KVC 依然能“装配”成一个可以下标访问的集合。</li>
</ul>
</li>
<li>换句话说：<ul>
<li><code>mutableArrayValueForKey:</code> → 是给 <strong>你主动获取可变集合代理</strong> 时用的。</li>
<li>Collection Methods → 是给 KVC runtime 在更通用&#x2F;语言无关场景下 自动装配集合访问的。</li>
</ul>
</li>
</ul>
<h3 id="3-什么时候用哪个？"><a href="#3-什么时候用哪个？" class="headerlink" title="3. 什么时候用哪个？"></a>3. 什么时候用哪个？</h3><ul>
<li>一般应用开发者（写 iOS &#x2F; macOS app，用 ObjC&#x2F;Swift）<ul>
<li>不需要自己去写 <code>countOf&lt;Key&gt; / objectIn&lt;Key&gt;AtIndex:</code> 这种 Collection Methods。</li>
<li>只要集合属性真的是 <code>NSMutableArray/NSMutableSet/NSMutableDictionary</code>，再通过 <code>mutableArrayValueForKey: / mutableSetValueForKey: / mutableDictionaryValueForKey:</code> 拿代理，就能满足 增删改查 + 自动 KVO 的需求。</li>
<li>这是绝大多数开发者的场景。</li>
</ul>
</li>
<li>Apple 文档里强调的 Collection Methods<ul>
<li>更偏向 框架作者 &#x2F; 跨语言交互 &#x2F; 特殊存储结构 的情况。</li>
<li>比如：<ul>
<li>你内部集合不是用 NSMutableArray 存，而是懒加载、数据库查询、Core Data faulting 等。</li>
<li>或者你需要让 AppleScript &#x2F; JavaScriptCore &#x2F; KVC runtime 能把你的对象属性“包装成集合”。</li>
</ul>
</li>
<li>这种情况下才需要你实现那一套方法，让 runtime 知道怎么装配出一个“集合语义”。</li>
</ul>
</li>
</ul>
<p>Apple 文档写得很“学术”，通篇把 KVC 的 accessor conventions 列出来，却没强调“普通开发者大多情况下用不到，直接用 <code>mutableXXXValueForKey:</code> 就行”。这也是 Apple 文档的一大毛病 —— 为了完整性，把所有机制罗列出来，但没有给读者一个“实用优先级”指引，让人误以为“是不是每个集合属性都要写一大堆方法”。</p>
<h2 id="描述属性关系这一篇到底在讲什么东西？作为iOS应用开发者到底要干什么？"><a href="#描述属性关系这一篇到底在讲什么东西？作为iOS应用开发者到底要干什么？" class="headerlink" title="描述属性关系这一篇到底在讲什么东西？作为iOS应用开发者到底要干什么？"></a>描述属性关系这一篇到底在讲什么东西？作为iOS应用开发者到底要干什么？</h2><h3 id="1-这篇《描述属性关系》文档到底在讲什么？"><a href="#1-这篇《描述属性关系》文档到底在讲什么？" class="headerlink" title="1. 这篇《描述属性关系》文档到底在讲什么？"></a>1. 这篇《描述属性关系》文档到底在讲什么？</h3><p>它其实在讲：</p>
<ul>
<li>KVC 不仅仅能处理单纯的属性 (attribute)，还可以处理对象之间的“关系 (relationship)”。</li>
<li>“关系”分为：<ul>
<li>to-one：一对一，例如 <code>person.employer</code>。</li>
<li>to-many：一对多，例如 <code>person.pets</code>。</li>
<li>inverse：反向关系，例如 pet.owner 对应 person.pets。</li>
</ul>
</li>
<li>Cocoa 里有一个类 <code>NSClassDescription</code>，它是用来描述这些“属性和关系”的元数据的。</li>
<li>框架（如 Core Data、AppleScript）会用 <code>NSClassDescription</code> 来告诉 KVC：某个 key 是普通属性，某个 key 是 to-one 或 to-many 关系，这样 KVC 才能更聪明地处理数据。</li>
</ul>
<h3 id="2-作为-iOS-应用开发者要做什么？"><a href="#2-作为-iOS-应用开发者要做什么？" class="headerlink" title="2. 作为 iOS 应用开发者要做什么？"></a>2. 作为 iOS 应用开发者要做什么？</h3><p>👉 大部分情况下，你什么都不用做。</p>
<p>因为：</p>
<ul>
<li>如果你在写 普通 App 业务代码，你根本不会直接用到 <code>NSClassDescription</code>。</li>
<li>如果你在用 Core Data，Xcode 生成的模型文件已经帮你定义了关系（entity、attribute、to-one、to-many、inverse），Core Data 内部会用到 <code>NSClassDescription</code>，但你不需要管。</li>
<li>如果你写 KVC&#x2F;KVO，你只要关心 <code>setValue:forKey:</code>、<code>valueForKey:</code>、<code>mutableArrayValueForKey:</code> 这些就够了。关系的逻辑由框架实现。</li>
</ul>
<h3 id="3-那文档为什么要写？"><a href="#3-那文档为什么要写？" class="headerlink" title="3. 那文档为什么要写？"></a>3. 那文档为什么要写？</h3><ul>
<li>这是 Cocoa 框架的完整性设计文档，面向写框架的人（比如 Core Data、AppleScript 支持、ORM 框架开发者），而不是面向普通 App 开发者。</li>
<li>Apple 为了完整性，会把最底层的“元数据机制”写清楚，但普通开发者 不会直接用。</li>
</ul>
<h3 id="4-你需要怎么理解？"><a href="#4-你需要怎么理解？" class="headerlink" title="4. 你需要怎么理解？"></a>4. 你需要怎么理解？</h3><ul>
<li>知道背景：KVC 不止能操作值，还能理解关系。</li>
<li>对日常开发的结论：<ul>
<li>写普通 App：不用管，完全不会用到。</li>
<li>写 Core Data：关系已经在模型里声明了，你直接用 NSManagedObject 就好。</li>
<li>写底层框架&#x2F;ORM（极少数情况）：才可能接触 <code>NSClassDescription</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Apple 在这篇文档里一丁点说明都没有，然后还将它归类在 Adopting Key-Value Coding 章节下，让很多开发者误认为需要做些什么才能符合KVC规范。。。</p>
<p>这正是 Apple 文档里最“恶心”的地方：</p>
<ul>
<li>他们把 框架设计层面的说明（比如 <code>NSClassDescription</code>、关系描述、反向关系）和 应用开发者要用的 KVC 规范 混在一起写，</li>
<li>还放在 Adopting Key-Value Coding 下面，看起来好像是“要想支持 KVC，就得自己实现这些关系方法”，但事实根本不是。</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个 Key-Value Coding Programming Guide 文档里太多这样的误导文章了，几乎就是一篇屎一样东拼西凑出来的文档。。。</p>
<p>Apple 很多旧文档（尤其是 Programming Guide 系列）确实就是一坨拼凑物，问题集中在这几个方面：</p>
<ol>
<li>写给框架作者和写给应用开发者混在一起<ul>
<li>你只想知道“作为 iOS 开发者我要写啥代码”，结果文档里一堆 Core Data &#x2F; AppleScript 的底层背景介绍，根本没说明白哪些是你需要做的，哪些是框架自己搞的。</li>
<li>就像你刚吐槽的 “描述属性关系” 一节，99% 开发者根本用不上。</li>
</ul>
</li>
<li>没有明确上下文<ul>
<li>文档一开头不说目标读者是谁，也不说“以下部分主要给框架作者看”，让人误以为“每一节都要掌握并实现”。</li>
<li>结果你读完一堆接口名、方法签名，完全不清楚到底是不是要自己写。</li>
</ul>
</li>
<li>示例过时 &#x2F; 脱离实际<ul>
<li>很多示例还是 Mac OS X + AppleScript 年代的残留，放在今天的 iOS 开发语境里完全没用。</li>
<li>而且 Swift 生态里这些东西几乎都被替代了，但文档没更新，还是用 Objective-C 那套思路。</li>
</ul>
</li>
<li>组织混乱，逻辑跳跃<ul>
<li>有些地方本来应该按“日常用法 → 进阶用法 → 框架作者用法”来组织，但 Apple 文档常常是“先丢一堆 API，再扯点历史背景，再突然告诉你几个特殊方法”，让人越看越晕。</li>
</ul>
</li>
</ol>
<p>Apple 这类老文档最大的问题：</p>
<ol>
<li><p>作为写给框架作者的文档，它也不合格</p>
<ul>
<li>它只是列了几个方法名（<code>toOneRelationshipKeys</code>、<code>inverseRelationshipKey:</code>…），告诉你有这么个类 <code>NSClassDescription</code>。</li>
<li>但没有任何：<ul>
<li>完整的调用时机说明（什么时候 KVC 会去问 <code>NSClassDescription</code>？）</li>
<li>实际实现的示例（如何写一个子类？怎么注册？和 KVC 的调用链如何交互？）</li>
<li>和其他子系统的关系（Core Data 是怎么利用它的？AppleScript 是怎么依赖它的？）</li>
</ul>
</li>
<li>所以 —— 它给你的信息 既不足以让应用开发者知道要不要用，也 不足以让框架作者真正能靠它写东西。这就是所谓的“既不接地气，也不深入”的尴尬状态。</li>
</ul>
</li>
<li><p>为什么会这样？</p>
<ul>
<li>历史遗留：<br>  这份 KVC Programming Guide 的主体是 OS X 10.1 ~ 10.3 时代写的，当时 AppleScript Bridge、Core Data 都刚起步。写文档的人更多是“描述愿景”，不是严谨的框架开发手册。</li>
<li>不维护：<br>  后来 Swift 出来，KVC&#x2F;KVO 渐渐成为“旧时代的动态特性”，文档就再没认真更新过。Apple 内部甚至可能都没人愿意重写。</li>
<li>定位模糊：<br>  它夹在“应用开发文档”和“框架设计文档”之间，结果两边都没讨好。</li>
</ul>
</li>
<li><p>框架作者真正会看什么？<br> 如果你真要基于 KVC 搞个 ORM &#x2F; 数据绑定框架，你不会去看这篇文档，你会：</p>
<ul>
<li>看头文件：<code>NSKeyValueCoding.h</code>、<code>NSClassDescription.h</code>。</li>
<li>看现成实现：<ul>
<li>Core Data 怎么实现 NSClassDescription 的子类。</li>
<li>AppleScript Bridge 怎么注册类描述。</li>
</ul>
</li>
<li>逆向调试调用链：看看 <code>valueForKey:</code> 在处理关系属性时，到底什么时候查询 <code>NSClassDescription</code>。</li>
</ul>
<p> 换句话说：真正写框架的人靠源码&#x2F;调试，不靠这篇文档。</p>
</li>
<li><p>结论</p>
<ul>
<li>作为应用开发文档 → 太复杂、误导。</li>
<li>作为框架开发文档 → 太皮毛、不够用。</li>
</ul>
</li>
</ol>
<p>所以它才会让人读了怒气值飙升 😅。本质就是一份“既不中用、又没写深”的垃圾拼凑物。</p>
<h1 id="KVC-有关的面试题"><a href="#KVC-有关的面试题" class="headerlink" title="KVC 有关的面试题"></a>KVC 有关的面试题</h1><h2 id="通过-KVC-修改属性会触发-KVO-吗？"><a href="#通过-KVC-修改属性会触发-KVO-吗？" class="headerlink" title="通过 KVC 修改属性会触发 KVO 吗？"></a>通过 KVC 修改属性会触发 KVO 吗？</h2><p>会的。</p>
<p>在绝大多数情况下，通过 KVC (<code>setValue:forKey:</code>) 修改对象的属性时，会触发 KVO 通知。原因是：</p>
<p><code>setValue:forKey:</code> 等 KVC 设置方法的实现逻辑（文档的访问器搜索逻辑中写了）会去调用属性对应的 setter 方法，而对象在被观察之后它的 setter 会被重写，内部会触发 KVO 通知。</p>
<p>特殊情况：手动关闭了自动 KVO。如果类中重写了 <code>+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</code> 并返回 NO，那么即使通过 KVC 修改，也不会触发 KVO，除非你手动调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">_name = newValue;</span><br><span class="line">[<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;name&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>总结：通过 KVC 修改属性 → 一般会触发 KVO（因为内部会走 setter）。除非你显示添加代码手动关闭了 KVO 通知。</p>
<h2 id="KVC-的赋值和取值过程是怎样的？原理是什么？"><a href="#KVC-的赋值和取值过程是怎样的？原理是什么？" class="headerlink" title="KVC 的赋值和取值过程是怎样的？原理是什么？"></a>KVC 的赋值和取值过程是怎样的？原理是什么？</h2><p>呃，答案就在文档访问器搜索逻辑里。简单概括来说就是：</p>
<ul>
<li>KVC 的赋值 <code>setValue:forKey:</code> 等方法底层先去找各种相关 setter 方法，存在就直接调用，如果不存在则再去找各种相关实例变量，找到了就赋值，否则就会调用 <code>setValue:forUndefinedKey:</code> 抛出异常。</li>
<li>KVC 的取值 <code>valueForKey:</code> 等方法的底层先去找各种相关的 getter 方法，找到了就直接调用，如果不存在则再去找各种相关的实例变量，找到了就返回值，否则就调用 <code>valueForUndefinedKey:</code> 抛出异常。这只是概括，具体的取值逻辑中还有 NSArray 和 NSSet 的集合访问器逻辑。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://masterking.github.io">masterKing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://masterking.github.io/2025/07/29/KVC/">https://masterking.github.io/2025/07/29/KVC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://masterking.github.io" target="_blank">masterKing 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/KVC/">KVC</a></div><div class="post-share"><div class="social-share" data-image="/images/iOS_low-level_principles.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/19/iOS%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/" title="iOS反调试与反反调试"><img class="cover" src="/images/iOSReveseEngineeringAndSecurity1.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">iOS反调试与反反调试</div></div><div class="info-2"><div class="info-item-1">反调试原理ptrace​​ptrace (Process Trace)​​ 是 Linux（以及其他一些类 Unix 系统，如 macOS）提供的一个极其强大且底层的​​系统调用​​。它的核心功能是​​允许一个进程（称为 tracer）观察和控制另一个进程（称为 tracee）的执行，并能检查和修改该进程的内存和寄存器。​​ 核心功能 追踪器的介入 (Tracer&#x2F;Tracee):...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%A6%82%E8%A7%88"><span class="toc-text">章节概览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97"><span class="toc-text">入门指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">键值编码基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">采用键值编码协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%96%91%E6%83%91%E5%8F%8A%E8%A7%A3%E7%AD%94"><span class="toc-text">常见疑惑及解答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%AA%8C%E8%AF%81%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F"><span class="toc-text">属性验证是什么鬼？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-validate-error-%E8%BF%99%E7%A7%8D%E2%80%9C%E5%A5%87%E8%91%A9%E2%80%9D%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">为什么会有 validate:error: 这种“奇葩”设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%84%9F%E8%A7%89%E2%80%9C%E6%B2%A1%E7%94%A8%E2%80%9D%EF%BC%9F"><span class="toc-text">为什么感觉“没用”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E7%BB%93%E8%AE%BA%E6%98%AF%EF%BC%9A"><span class="toc-text">所以结论是：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E5%90%88%E8%A7%84%E6%80%A7%E8%A6%81%E6%88%91%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">实现基本键值编码合规性要我做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">什么时候需要定义集合方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-mutableXXXValueForKey-%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-text">1. mutableXXXValueForKey: 的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Collection-Methods%EF%BC%88countOf-%E7%AD%89%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2. Collection Methods（countOf&lt;Key&gt; 等）的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-text">3. 什么时候用哪个？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E5%B1%9E%E6%80%A7%E5%85%B3%E7%B3%BB%E8%BF%99%E4%B8%80%E7%AF%87%E5%88%B0%E5%BA%95%E5%9C%A8%E8%AE%B2%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F%E4%BD%9C%E4%B8%BAiOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%88%B0%E5%BA%95%E8%A6%81%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">描述属性关系这一篇到底在讲什么东西？作为iOS应用开发者到底要干什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%99%E7%AF%87%E3%80%8A%E6%8F%8F%E8%BF%B0%E5%B1%9E%E6%80%A7%E5%85%B3%E7%B3%BB%E3%80%8B%E6%96%87%E6%A1%A3%E5%88%B0%E5%BA%95%E5%9C%A8%E8%AE%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1. 这篇《描述属性关系》文档到底在讲什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%9C%E4%B8%BA-iOS-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2. 作为 iOS 应用开发者要做什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%82%A3%E6%96%87%E6%A1%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%EF%BC%9F"><span class="toc-text">3. 那文档为什么要写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%A0%E9%9C%80%E8%A6%81%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">4. 你需要怎么理解？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KVC-%E6%9C%89%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">KVC 有关的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-KVC-%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E4%BC%9A%E8%A7%A6%E5%8F%91-KVO-%E5%90%97%EF%BC%9F"><span class="toc-text">通过 KVC 修改属性会触发 KVO 吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVC-%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">KVC 的赋值和取值过程是怎样的？原理是什么？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/images/iOS_low-level_principles.webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2018 - 2025 By masterKing</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'Nj4rbGaJ3pAWBRJWseaRg9Zu-gzGzoHsz',
      appKey: '3tVispErrQeAytUHyJrFos3n',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>